      program dempla
c
c-----an f77 Fortran program for applying the Discrete Element Method
c     to wave propagation and liquefaction analysis
c
c-----Version dempla-0.2.2.f , as created/ammended on Mar. 29, 2021 
c
c     Based on oval-0.7.292.f 
c
c---------------
c     Copyright (C) 2017  Matthew R. Kuhn
c
c     This program is free software; you can redistribute it and/or
c     modify it under the terms of the GNU General Public License
c     as published by the Free Software Foundation; either version 3
c     of the License, or (at your option) any later version.
c
c     This program is distributed in the hope that it will be useful,
c     but WITHOUT ANY WARRANTY; without even the implied warranty of
c     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
c     GNU General Public License for more details.
c     
c     You should obtain and read a copy of the GNU General Public License
c     before using this program. It can be obtained on-line or by writing
c     to the Free Software Foundation, Inc., 51 Franklin Street,
c     Fifth Floor, Boston, MA 02110-1335 USA 
c----------------
c
c     Written by:
c
c     Matthew R. Kuhn            kuhn@up.edu
c     University of Portland
c     5000 N. Willamette Blvd.
c     Portland OR 97203
c
c     The source code and complete documentation is available at the
c     web site http://faculty.up.edu/kuhn/dempla or from the author.   
c     When you download the DEMPLA files, please send me an email message 
c     so that I can send you a notice whenever a newer version is released.
c
c     The program simulates the deformation behavior of an assembly(ies) of
c     two- or three-dimensional particles.  The Discrete Element Method
c     is used.  The program is primarily intended for "element tests" 
c     of an assembly of particles surrounded by rigid or periodic 
c     boundaries.  The program will require modification if it is used 
c     for more complex boundary value problems such as silos, direct
c     shear boxes, etc.  
c
c-----"dempla" can be compiled with two modes:
c       imode=1  conventional OVAL (imode = 1) for analyzing a single
c                assembly. This mode can be compiled for analyzing a
c                single assembly (nRVEs=1) or multiple assemblies 
c                (nRVEs > 1) with OpenMP parallelization
c       imode=2  to run wave propagation (imode = 2) with a series
c                of assemblies.  Should usually be compiled with OpenMP
c                parallelization
c
c     The program currently accomodates the following types of particles:
c         2D:
c           circles
c           ovals (a convex 4-arc composite, non-circular particle)
c           ellipses
c           nobbies (a non-convex composite particle created from
c             circles placed symmetrically around a central circle)
c         3D:
c           spheres
c           ovoids (a convex composite, non-spherical particle)
c           bumpies (a non-convex composite particles created
c           from spheres placed symmetrically around a central sphere)
c
c     Two separate input files are required when running the program
c     in imode=1.  With imode=2, these two input files play an important
c     role in analyzing wave propagation in a soil column, but the two
c     files are referenced within other input files.  Download the
c     documentation for a complete description of the two files.
c
c       1) The first file (a "RunFile") gives the controlling 
c       stress-strain path, the desired output format, the contact 
c       properties (contact stiffnesses, viscosities, ect.), the 
c       desired stress-strain path, and various other control parameters.
c
c       2) The other file (a "StartFile") gives the initial particle 
c       positions, radii, and (with non-circular or non-spherical particles)
c       their orientations.  This file, which can be of three different forms, 
c       is read in subroutins 'readit' and 'dumpin'.  
c
c         a) The first form (istart=1) provides only the particle 
c         positions, sizes, and orientations in a formatted (ASCI) file.  
c
c         b) The second form (istart=2) is the same as the first, but with 
c         an unformatted (non-ASCI) file.  With these first two forms, 
c         the simulation can begin with the particles motionless 
c         (rmsvel=0) or with random velocities (rmsvel>0). 
c
c         c) The third form provides sufficient information to entirely 
c         restart a simulation from the condition at the end of a previous 
c         simulation (istart=3).
c
c       Each of these three types of files will have variations, 
c       depending on the type of particle (2D or 3D, circle, sphere, oval,
c       ellipse, etc.).  Please see the documentation.
c
c     The output from a simulations will be written to various output files,
c     have names that begin with letters A*, B*, C*, D*, F*, etc.
c
c     For analyzing wave propagation (imode=2), other files are needed
c     (G* and L* files), and a particular folder structure must be contructed.
c
c     The program was originally compiled with a UNIX-VAX f77 compiler.
c     It has also been compiled with the Solaris f77 compiler, the
c     Linux (gcc) gfortran compiler and the Intel ifort compiler.
c
c     With some exceptions, the program is written in ANSI Fortran 77.
c     Some idiosyncracies include:
c         1) some symbolic names are longer than 6 characters (hopefully,
c            not too many).
c         2) integers of 2 byte length are used (integer*2).  I did this
c            with some very early versions to reduce file sizes to accomodate
c            my 20MB hard drive.  (On some systems, the use of 2 btye
c            integers will make necessary the use of the system-local 
c            function int2(), which converts a 4-byte integer to a 2-byte 
c            integer.  This function is included in the code.),
c         3) system-local screen prompts.
c         4) a system-local "include" option that inserts the code of the
c            files 'param-dempla-0.2.2.f' and 'common-dempla-0.1.52.f' at 
c            the beginning of every program unit.  These files are required 
c            to compile the program.  The program will not compile 
c            without these two files.
c         5) occasional 'do while' loops.
c         6) the use of the intrinsic "modulo" function, which properly 
c            performs integer modulo math.  This function is include with 
c            the gfortran, intel, and lahey compilers, but was not part of 
c            the original f77 specification (and the gnu g77 compiler).  
c            If your compiler does not support the intrinsic function 
c            "modulo", replace all calls to modulo() with calls to nwmod4()
c         7) some embedded OpenMP commands '!$OMP' for parallelization
c
c      Some lines of code have been 'commented out' so that they are not
c      compiled.  These include the following:
c
c         c--------usual comment lines like this one
c         c        and this one
c
c-----this work is licenced under GNU General Public Licence, as described
c     above.  This "open source" licence includes, among other provisions,
c     the following statement:
c
c       2. You may modify your copy or copies of the Program or any portion 
c          of it, thus forming a work based on the Program, and copy
c          and distribute such modifications or work under the terms of 
c          Section 1 above, provided that you also meet all of these 
c          conditions: 
c          a) You must cause the modified files to carry prominent notices 
c             stating that you changed the files and the date of any change. 
c          b) You must cause any work that you distribute or publish, that 
c             in whole or in part contains or is derived from the Program
c             or any part thereof, to be licensed as a whole at no charge 
c             to all third parties under the terms of this License. 
c          c) If the modified program normally reads commands interactively 
c             when run, you must cause it, when started running for such 
c             interactive use in the most ordinary way, to print or display 
c             an announcement including an appropriate copyright notice and 
c             a notice that there is no warranty (or else, saying that you 
c             provide a warranty) and that users may redistribute the program 
c             under these conditions, and telling the user how to view a copy 
c             of this License. (Exception: if the Program itself is interactive
c             but does not normally print such an announcement, your work 
c             based on the Program is not required to print an announcement.) 
c
c-----the default integer type is integer*2, which is accomplished with
c     the "implicit integer*2(i-n)" in the 'param-dempla-0.2.2.f' file.
c     Integer*2 variables have a maximum value of about 32000, and are
c     fine for many integer variables, but integer*4 variables must be
c     used in many situations to allow for more particles: particle
c     indices, linked lists, etc.
c
c-----the default real type is real*8 (double precision), which is 
c     accomplished with the "implicit double precision(a-h,o-z)" line
c     in the 'param-dempla-0.2.2.f' file.
c
c-----we use the following notation for the particle indices, noting that
c     a particle can be composed of more than one component piece (as with
c     four-arc ovals and three-component ovoids).  In general, integer 
c     variables begin with the letters "i", "j", "k", "m", and "n".
c     Logical variable begin with the letter "l", and fixed parameters
c     begin with the letter "m".  Integers that begin with the letter 
c     "n" are usual a maximum number for the particular assembly.  
c
c     As stated, integers that begin with the letter "m" are usually 
c     limiting values and are usually PARAMETERs that can only be changed 
c     by altering the source code (usually the "param" file) and 
c     then recompiling:
c       mdim1  - the number of spatial dimensions (2D or 3D)
c       mdim2  - the number of rotational "dimensions"
c       mp     - maximum number of particles
c       mpiece - maximum number of component pieces (for oval particles)
c       lc1    - maximum number of stress-strain control periods, 
c                should be an odd integer
c       lc2    - maximum number of force-separation data
c       ldiams - maximum number of diameters in force-separation data
c       mlist  - maximum size of the linked list of neighbors: max. number
c                of particle pairs that are near neighbors
c       mlist2 - maximum size of the linked list of contact forces: max. number
c                of particle pairs that are touching
c       mlistJ - maximum size of the linked lists for storing information
c                for Jager contacts
c       mholes - maximum number of vacancies in list of touching particles
c       mcells - maximum number of void cells in 2D topology
c       mlimbs - maximum number of edges (valence) of a void cell
c       mstack - maximum number in arrays for stress-control
c       mfiles - maximum number of output files
c       mconvx - maximum number of contacts between a pair of two particles,
c                which might be non-convex (2D or 3D)
c       mboxes - maximum nubmer of bins for finding near neighbor pairs
c       mparts - maximum number of parts in a composite 2D particle
c       mbumps - maximum number of satellite spheres in a bumpy particle
c       mLayer - maximum number of stratigraphic soil layers
c       mrve   - maximum number of nodes and RVEs in the dempla algorithm
c
c-------The following are commonly used integer indices
c         igrain, jgrain, kgrain   an index for a particle
c                                    igrain = 1:np
c         np                       the total number of particles in the assembly
c         ipiece, jpiece, kpiece   a component piece of a particle
c                                    ipiece = 1:npiece
c         njoin                    the number of component pieces in a particle
c         npiece                   the total number of pieces in the assembly
c                                    npiece = njoin*np
c
c-----From version (about) dempla-0.1.30.f onward, we have parallelized 
c     the code using the OpenMP shared memory multiple-threads interface.
c     To take advantage of parallelization, one must do several things,
c     within the shell environment and within the code:
c
c     1) the program must be compiled with the proper OpenMP flag, for
c        example, with the gcc gfortran version 4.8.4 and Intel ifort
c        version 18.0.0 compilers, this flags are as follows:
c          gfortran: -fopenmp
c          ifort:    -qopenmp
c        For example, to compile the program within a Linux shell:
c          gfortran -std=gnu -O3 -mtune=native \
c                   -mcmodel=large \
c                   -fopenmp \
c                   -o dempla.exe
c                   dempla-0.2.2.f
c          ifort -ipo -O3 -no-prec-div -fp-model fast=2 -xHost
c                -fpconstant \
c                -mcmodel=large \
c                -qopenmp -heap-arrays \
c                -o dempla.exe 
c                dempla-0.2.2.f
c        In these examples, the options are as follows:
c           * "-std=gnu -O3 -mtune=native"
c               or 
c             "-ipo -O3 -no-prec-div -fp-model fast=2 -xHost" 
c             produce optimized code.
c           * "-fltconsistency -fpconstant"
c             improve floating point precision.
c           * "-mcmodel=large"
c             accomodates large compiled arrays (as might be needed
c             when there are millions of particles or when there are 
c             thousands of particles but with mlistJ being exceptional large).
c           * "-fopenmp"
c               or
c             "-qopenmp"
c             specifiy compiling with the OpenMP library
c           * "-heap-arrays" 
c             places temporary arrays that are used within subroutins 
c             (i.e., arrays that are treated as privat and take new 
c             values with each threaded instance) onto the heap instead 
c             of the stack
c           * "-o dempla.exe"
c             name of the executable file
c
c     2) to preclude parallelization and always run as a single thread, simply
c        recompile dempla without the "-fopenmp" or "-qopenmp" flags
c
c     3) within the shell in which dempla is being run, specify the 
c        number of threads to be used during runtime.  Within a Linux 
c        bash shell:
c          export OMP_NUM_THREADS=4
c        To query the current value of OMP_NUM_THREADS:
c          echo $OMP_NUM_THREADS
c        This step must be done within any shell that will run the
c        program, or it can be included in the .bashrc or other
c        shell initialization script
c
c        To query the number of threads available on the computer's hardware:
c          lscpu | grep -E '^Thread|^Core|^Socket|^CPU\('
c
c        See this for multiple sockets:
c         https://software.intel.com/en-us/forums/intel-moderncode-for-parallel-architectures/topic/739878
c
c        Note that if no value of OMP_NUM_THREADS is set, then the
c        code will run with all possible threads on the CPU
c
c        Instead of setting the parameter in the shell, the
c        parameter can also be assigned at runtime.  For example,
c        if the executable code is "dempla.exe", the following can
c        be run in the bash shell:
c           OMP_NUM_THREADS=4 ./dempla.exe
c
c--------There is another approach, which I have not yet tried.
c        One might be able to set the number of threads within
c        this source code.  Maybe by uncommenting these 2 lines??
c        parameter(mTHREADS=4)
c        CALL OMP_SET_NUM_THREADS(mTHREADS)
c
c     4) to delete the OMP_NUM_THREADS variable, within a Linux bash shell:
c             unset OMP_NUM_THREADS
c
c     5) for parallelized code, you might need to incread the stack
c        size that for the threads.  For example,
c            export OMP_STACKSIZE=80m
c        The default size is usually small, 1m or 2m, and can lead
c        to segmentation fault errors during runtime.  You might need
c        to try different sizes, until an adequate stack size is found,
c        but without exhausting the machine memory.  See this explanation:
c        https://stackoverflow.com/questions/13264274/why-segmentation-fault-is-happening-in-this-openmp-code
c
c        This can also be assigned at runtime.  In the bash shell:
c            OMP_NUM_THREADS=4 OMP_STACKSIZE=80m ./dempla.exe
c
c     6) set the value of parameter "mrve" in the file "param-dempla-0.2.2.f".
c        When running a wave propagation simulation (imode=2), mrve should
c        be set to the number of rve's in the simulation.  For only running
c        OVAL, enable parallelization by setting mrve to a value as large
c        as the number of threads.  For example, if OMP_NUM_THREADS=2, 
c        then set the parameter:
c          mrve=2
c
c     7) one must provide sufficient memory for parallel execution.
c        The "gfortran" and "ifort" compilers create executable programs 
c        that use stack memory instead of static memory.  The limit 
c        on stack memory size will need to be increased.  With Linux,
c        use the following shell command:
c          ulimit -s unlimited
c        This command must be entered in any shell that will run the 
c        executable program, or it can be included in the .bashrc or other
c        shell initialization script.  Without this command, you will
c        likely receive a segmentation fault error.
c
c     8) here is my Linux bash script file "dempla.bsh" for setting up 
c        the use of dempla in a bash shell:
c            #!/bin/bash
c            #
c            ulimit -s unlimited
c            export OMP_STACKSIZE=80m
c            export OMP_NUM_THREADS=6
c        To run the script in the script:
c            source dempla.bsh
c
c
c-----Now, the program . . . .
c
c-----the "param" file in the following "include" statement contains 
c     statements that are shared by multiple program units.
c     These statement include the following:
c        a) 'implicit' statement of default variable naming types.
c           In general, variables beginning with letters "i" to "n" are
c           2-byte integers.  Variables beginning with letters a-h and o-z
c           are 8-byte double-precission reals.
c        b) parameters that are used in array dimensions (see above
c           for descriptions of some of these parameters.
c
c-----the "common" file in the following "include" statements contain
c     statements that are shared by multiple program units.
c        c) declarations of the types of several hundred variables
c           that are used in numerous program units
c        d) 'common' statements of shared (global) variables
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*4 listk, listJ, nboxs(0:mrve), 
     x          nlist(0:mrve), nlist2(0:mrve), nlist3(0:mrve), switch
      integer*2 extent, imode, iremov, islip2, istartchng, 
     x          nnnear(0:mrve), rve
c
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag, zeta_o, zeta_s0, zeta_s1, zeta_s
c
c-----Boolean variables
      logical lcont, lfirst
c
c-----character strings (used for the names of files and folders)
      character*400 OutputDir, RunFileDir
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c
c-----numerical constants
      pi = 3.14159265358979323846d0
c
c-----whether to print certain output to the screen (lScreen=.true.)
      lScreen = .true.
c
c-----this label is placed at the top of several output files so that you
c     can later distinguish which DEMPLA version was use for the particular
c     simulation
      version = 'dempla-0.2.2.f'
c
c-----set default condition of creating A and B files.  For wave propagation,
c     we can dissallow these files with the input iABfile in the G-file
      lABfile = .true.
c
c-----whether to run wave propagation (imode = 2)
c     or conventional OVAL (imode = 1)
c     imode = 0
      print *, ' Mode: single-assembly (1) or wave propagation (2): '
      read(*,*) imode
c
      if(imode.eq.2) then
c-------in this mode, we simulate wave propagation in a soil column
c
c-------write the dempla version to the screen
        write(*,910) version(1:LEN_TRIM(version))
  910   format(a24)
c
c-------establish the Simulation name. This is the name of the main folder
c       containing the input and output files and contains other folders
c       that contain other input and output files.  This name should
c       contain no spaces or slashes ("/" or "\"), and the main folder
c       should located within the folder in which dempla is run
        print *,' BaseName of the simulation (main folder name):'
        read(*,600) MainDir
c
c-------name of the variation of the simulation name.  We introduce this
c       variation to change the name of the "G" file and the output files
c       in the 04_RunOutput folder.  This maintains the main folder as
c       "MainDir" and the various L-files maintain their same names with
c       the "MainDir" names.  We also preclude the need to rerun the
c       creation of files in the 02_LayerSetup/ and 03_RVESetup/ folders
        print *,' Suffix of variation (if none, press return):'
        read(*,600) cVar
c
c-------name of the rock motion file. The name should contain no spaces
c       or splashes.  The file name should be relatively terse, as the 
c       name will be embedded in the names of the DEMPLA output files.
c       The rock motion file contains three columns: time, vertical (x_1)
c       displacement, and horizontal (x_2) displacement.  The file should
c       be contained within the folder MainDirNAME/MotionInput/
        print *,' MotionFile (name of rock motion file):'
        read(*,600) RockMotionFile
c
c-------this subroutin does the following:
c         1) reads information about each stratigraphic layer,
c         2) if necessary, runs a DEM simulation for each layer, using a
c            RunFile and StartFile, to create an assembly at a certain 
c            stress-level for each stratigraphic layer
c         3) if necessary, runs a DEM simulation, using the results of
c            step (2), to create an assembly for each RVE within each
c            of the stratigraphic layers, so that the vertical stress
c            and water pressure of each RVE matches the layers' conditions.
c            The results of these simulations are stored in a C-file
        call setup
c
c-------this subroutin soes the following:
c         1) reads the C-files created in part (3) of subroutin setup,
c            and then computes various properties for each RVE (density,
c            porosity, permeability, etc.)
c         2) runs DEM simulations to determine the stiffness moduli of
c            each RVE
c         3) uses the results of (2) to determine the time step for applying
c            the wave propagation algorithm
c         4) rereads the C-files of all RVEs, and quiesces each assembly
c         5) runs the finite-difference Dempla algorithm to solve the
c            wave equation
        call pla
      elseif(imode.eq.1) then
c-------in this mode, we run as conventional OVAL
c
c-------the number of assemblies that will be analyzed.  Each assembly
c       is a "rve"
        nRVEs = 1
c
c-------additional points for stress servo-control
        npnts_xtra = 0
c
c-------check whether the program was compiled for a sufficiently large
c       number of nRVEs. If not, print error message and stop
        if(nRVEs.gt.mrve) then
          print *,
     x     'nRVEs is too large, change mrve in param-file and recompile'
          stop
        endif
c
        do 2 rve=1,nRVEs
c---------in this loop, we read the RunFile and StartFile of each simulation
c         and initialize the output file for each simulation.
c
c---------in the current implementation, nRVEs=1, and only a single
c         assembly is analyzed with mode=1
c
          if(.true.) then
c-----------establish the names of the two input files.  First, the name of 
c           the RunFile
            print *,' Name of the RunFile:'
            read (*,600) file1(rve)
c
c-----------now the name of the StartFile
            print *,' Name of the StartFile:'
            read (*,600) file2(rve)
c
c-----------note the use of Unix conventions, here.  I have not tried
c           to compile and run with Windows systems, using "\" instead of "/"
            OutputDir = './'
            RunFileDir = './'
          endif
c
c---------open a file for recording error messages
          call initFilesRS(rve,OutputDir,file1(rve),file2(rve),
     x                   ErrUnit(rve),
     x                   mdim1,mp,mpiece,version,ScrUnit(rve),
     x                   lScreen)
c
c---------do not change the type of StartFile
          istartchng = -1
c
c---------read both the RunFile and the StartFile
          extent = 0
c
c---------read the input data files. This step is "critical", as only
c         one processing thread should perform this step, rather than
c         parallel with other threads
          call readit2(rve,istartchng,file1(rve),file2(rve),extent)
c
c---------initialize general parameters, particle properties, ect.
          call init(rve)
c
c---------initialize the output A and B files for the single assembly
c         of rve "rve"
          call initFilesAB(rve,
     x      OutputDir,file1(rve),file2(rve),
     x      ndim1,iheat(rve),hmodel(rve),lout,lporo(rve),mfiles,
     x      iporo(rve),
     x      version, partyp(rve), np(rve), ravg(rve), voidn(rve),
     x      lHertz(rve),lJager(rve),lJagr2(rve),lJagr3(rve),
     x      lJagr4(rve),
     x      AUnit(rve),BUnit(rve),itxt(rve),Bversn)
c
c---------create the link list of near-neighbors
          nnnear(rve) = mnear
          nlist(rve) = mlist
          nlist2(rve) = mlist2
          nlist3(rve) = mlist3
          nboxs(rve) = mboxes
          call lister(rve,nnnear(rve),
     x              nlist(rve),nlist2(rve),nlist3(rve),nboxs(rve))
c
c---------elastic energy due to tangential force in Jager contacts
          if(lJager(rve) .or. lJagr2(rve)
     x       .or. lJagr3(rve) .or. lJagr4(rve)) then
c-----------work done in tangential contact movement (includes both elastic
c           deformation and sliding).
            if(istart(rve).le.2) then
              workc(rve) = 0.
            endif
          endif
    2   continue
c
c-------here, we parallelize the analysis of nRVEs.  In the current
c       implementation, only a single assembly is analyzed with imode=1
!$OMP   PARALLEL DO SCHEDULE(STATIC) PRIVATE(rve,lcont,lfirst)
        do 1 rve=1,nRVEs
c---------whether to continue from a previous run (as when a restart "C" file is
c         used to start a run)
          lcont = istart(rve).eq.3
c
c---------whether to print output of the initial conditions
          lfirst = lcont
c
c---------the DEM algorithm
          call dem(rve,lcont,OutputDir,file1(rve),lfirst)
    1   continue
!$OMP   END PARALLEL DO
c
c-------some finishing touches: create C-files and close file units
        do 3 rve = 1,nRVEs
c---------'iend' is given in the input RunFile to specify whether and how the
c          final particle arrangement will be written to a file
          if(iend(rve).ne.0) then
c-----------create a file containing information about the final particle
c           positions, etc.:
            if(iend(rve).eq.3 .or. iend(rve).eq.6) then
c-------------for binary restart files, remove the '.txt' extension if it exists
              if(itxt(rve).eq.0) then
c---------------'apend' is the name of the C-type output file
                apend(rve) = 'C'//file1(rve)(1:LEN_TRIM(file1(rve)))
              else
                apend(rve) =
     x          'C'//file1(rve)(1:index(file1(rve),'.txt')-1)
              endif
            elseif(iend(rve).eq.1 .or. iend(rve).eq.4) then
c-------------for binary restart files, remove the '.txt' extension if it exists
              if(itxt(rve).eq.0) then
c---------------'apend' is the name of the C-type output file
                apend(rve) = 'D'//file1(rve)(1:LEN_TRIM(file1(rve)))
              else
                apend(rve) =
     x          'D'//file1(rve)(1:index(file1(rve),'.txt')-1)
              endif
            endif
c
c-----------create a (binary) restart file named 'apend'
            call dumpot(rve)
          endif
c
c---------close all output files
          call closem(lout, lScreen, 
     x              AUnit(rve), BUnit(rve), ErrUnit(rve),
     x              ScrUnit(rve),mfiles)
c
    3   continue
      endif
c
      stop
c
  600 format(a400)
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine mssage(mdim1,mp,mpiece,version,ScrUnit)
c
c-------this subroutin prints some informational messages to the screen at the 
c       start of a run
c
        implicit double precision(a-h,o-z)
        integer*2 mdim1, ScrUnit
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 mp,mpiece
        character*24 version
c
c-------the version number of the code
        write(ScrUnit,910) version(1:index(version,' ')-1)
  910   format(/,'Program DEMPLA: version',a24,/,/,
     x    'c Matthew R. Kuhn 2001, Licensed under the GPL, version 2',
     x    /,/,
     x    'The program was compiled with the following parameters',
     x    ' (among others):')
c
c-------now the circumstance of the particular compile (the dimension
c       of problems that are allowed and whether the compile allows for
c       composite particles)
        if(mdim1.eq.2) then
          write(ScrUnit,*) '  1) 2D problems only. (mdim1=2)'
          if(mp.eq.mpiece) then
            write(ScrUnit,*)
     x        '  2) Circular disks only. (mpiece=mp)'
          elseif(4*mp.eq.mpiece) then
            write(ScrUnit,*)
     x        '  2) Circular disks or 4-arc ovals. (mpiece=4*mp)'
          endif
        elseif(mdim1.eq.3) then
          write(ScrUnit,*) '  1) 2D or 3D problems. (mdim1=3)'
          if(mp.eq.mpiece) then
            write(ScrUnit,*)
     x        '  2) Circular, spherical, and elliptical',
     x        '     particles.  No ovals or ovoids. (mpiece=mp)'
          elseif(4*mp.eq.mpiece) then
            write(ScrUnit,921)
  921       format('   2) Circular, spherical, elliptical, oval, ',
     x             'nobby, bumpy, ',/,
     x             '      and ovoid particles. (mpiece=4*mp)')
          endif
        endif
c
c-------the maximum number of particles allowed in the compile
        write(ScrUnit,920) mp
  920   format('   3) A maximum of',i8,' particles. (mp)')
        write(ScrUnit,925)
  925   format('Errors will occur if your input data is otherwise',
     x         ' (but you can always make',/, 
     x         'changes to the param-dempla-0.2.2.f file ',
     x         'and recompile).')
        write(ScrUnit,*) ' '
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine setup
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 extent, extent2,
     x            iLayer, iremov, islip2,
     x            istartchng,
     x            nbetwn,nLayerEff, 
     x            rve, rve_o(0:mrve), rve_f(0:mrve), rveo,
     x            nnnear(0:mrve), nRuns,
     x            RunLayer(0:mrve), RunLayerUpDn(0:mrve),
     x            RVELayerDn, RVELayerNu, RVELayerUp,
     x            RVEsInLayerDn, RVEsInLayerUp, RVEsInLayerNu,
     x            UpDn(0:mrve)
c
        integer*4 iStage,nboxs(0:mrve),
     x            listk, listJ, 
     x            nlist(0:mrve), nlist2(0:mrve), nlist3(0:mrve)
c
        double precision BaseRate, BaseRate_p,
     x                   EffStressPrev,
     x                   Integ_rho_b, 
     x                   Integ_rho_f_surface, Integ_rho_s_surface,
     x                   k_kappa,
     x                   pfluidz, pPrev,
     x                   sigmaz, StressTol, TotalStress
        double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0,p_s1,
     x                   RJag,
     x                   zeta_o, zeta_s0, zeta_s1, zeta_s
        logical lcont, lfirst
c
        character*4 strLayer, strRVE, strRVE_o, strRVE_f
        character*400 filenameC,
     x                InputRunFile,
     x                OutputFolderName,
     x                OutputSetupDir,
     x                OutputLayerFolder, OutputRunFile
        character*800 filename1, filename2, filename3
c
        dimension BaseRate(3,0:mrve), BaseRate_p(0:mrve),
     x            EffStressPrev(3,0:mrve), Integ_rho_b(0:mrve),
     x            pfluidz(0:mrve), pPrev(0:mrve),
     x            sigmaz(3,0:mLayer), TotalStress(3)
c
        dimension iStage(0:mrve)
c
        dimension RVEsInLayerUp(mLayer),
     x            RVEsInLayerDn(mLayer),
     x            RVEsInLayerNu(mLayer),
     x            RVELayerUp(mLayer,0:mrve),
     x            RVELayerDn(mLayer,0:mrve),
     x            RVELayerNu(mLayer,0:mrve),
     x            rveo(0:mrve)
c
        dimension InputRunFile(0:mrve), OutputRunFile(0:mrve), 
     x            strRVE(0:mrve)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-------the integration scheme for integrating velocities to update the
c       displacements.  With ischeme=1, we use the full-Biot equations,
c       and the soil skeleton displacements "u" and relative water 
c       displacements "w" are the primary variables.
        ischeme = 1
c
c-------a parameter for computing the numerical derivative that is used
c       in finding the gradients of stress and pressure at the nodes.
c       each node (from node 1 to node nRVEs) is centered between two
c       RVEs.  We compute the derivative from these two RVEs, but we 
c       find the weighted average of that derivate with the derivative
c       computed from twice-distance RVEs.  alpha_d is a factor between
c       0 and 1.  When zero, we use only the two nearest RVEs.  When 1,
c       we use only the two twice-distant RVES
        alpha_d = 0.
c
c-------check the value of alpha_d, in the event that alpha_d is read
c       from an input file
        epsd = 1.d-10
        if(.not.(alpha_d.ge.0. .and. alpha_d.le.1.d0+epsd)) then
          print *,'  alpha_d must be between 0 and 1'
          print *,'  Your value =',epsd
          stop
        endif
c
c-------with this integration scheme, the lowest rve is midway between
c       nodes 0 and 1.  It begins with rve=1, ends with rve=nRVEs
        botrve = 1
c
c-------create DEM assemblies for all RVEs
        topdif = 0
c
c-------with the full Biot theory is used (see Zienkiewicz
c       and Bettess), weighting factors can be used in the integration of
c       velocities.  The weighted past velocities at a node and nearby
c       nodes are used in finding the new velocity at the node
        ainteg(-1) = 0.
        ainteg(0) =  1.00d0
        ainteg(1) =  0.
        ainteg(2) =  0.
c
c       ainteg(-1) = 0.20d0
c       ainteg(0) =  0.60d0
c       ainteg(1) =  0.20d0
c       ainteg(2) =  0.
c
c-------create a pair of blank lines on the screen
        print *,' '//' '
c
c-------no body forces and no rigid platens (periodic boundaries will be used)
        lbodyf = .false.
        lplatn = .false.
c
c-------in the subroutin, the term "rve" is used to designate a 
c       material point represented by the RVE of a DEM assembly.  
c       In conducting the double-integration of the wave equation, 
c       a "node" is a point (the midpoint of two RVEs) where displacement 
c       is measured.  The bottom "0th" node is the bedrock, and the 
c       highest node is the ground surface.
c
c-------a screen message
        print *,'  Reading the G-file with general information...'
c
c-------read the G-file that gives general information about the
c       simulation: number of RVEs, gravity acceleration, etc.
        call ReadGfile
c
c-------check whether the limitation on the number of nRVEs, "mrve",
c       is sufficiently large to accomodate the rve thickness
        if(nRVEs.gt.mrve) then
          write(*,902)
  902     format('The nRVEs is too large or ',
     x           'mrve is not sufficiently large.',/,
     x           'Change nRVEs and rerun, ',
     x           'or change mrve (in the common file) ',/,
     x           'and recompile.')
          stop
        endif
c
c-------check whether the number of layers exceeds the maximum
        if(nLayers.gt.mLayer) then
          write(*,901)
  901     format('The number of stratigraphic layers in the input ',
     x           'file exceeds mLayer.',/,
     x           'Change the input file and rerun, ',
     x           'or change mLayer (in the common file) ',/,
     x           'and recompile.')
          stop
        endif
c
c-------whether to run DEM simulations to find the stiffness moduli
c       of all RVEs
        lFindModuli = .false.
c
c-------read the L-files that give information about the stratigraphic
c       soil layers. The file name should have the following format:
c       LXXXX_XXX, for example L0003_MySimulation, where the "0003" means
c       the 3rd layer below the ground surface, and the "MySimulation" is
c       the MainDir name.  For example, if the soil profile has 5 layers,
c       then nLayers=4, and there should be 4 files located inside the
c       MainDir: L0001_MySimulation, L0002_MySimulation, L0003_MySimulation,
c       L0004_MySimulation
        do 20 iLayer = 1,nLayers
c---------note that the information for each layer is in a separate L-file
          call ReadLfile(iLayer)
c
c---------whether to run DEM simulations to find the stiffness moduli
c         of all RVEs
          if(iRunRVEModuli(iLayer).ne.0) then
c-----------a DEM simulation will be run to determine stiffness moduli
            lFindModuli = .true.
          endif
   20   continue
c
c-------print a message to the screen
        if(lFindModuli) then
          print *,'  An L-file has iRunRVEModuli=1, so '//
     x            'a DEM preparation must be run'
        endif
c
c-------number of strain (time) steps between rves when progressively creating
c       rve assemblies
        nbetwn = 500
c
c-------compute the direction cosines of the sloping ground triad.  We
c       assume that both the ground and rock surfaces have an equal slope.
c       For the Dempla analysis, we use the following directions:
c         x_3 = upward (but sloping) direction perpendicular to the rock base
c       Direct_soil is the direction of (downward) dip of the ground
c       slope, measured in degrees CCW from the x_1 direction.
c       Dip_soil is the (downward) dip angle of the ground slope
c         
        cosin_s(3) =  cos(Dip_soil*pi/180.d0)
        cosin_s(1) = -sin(Dip_soil*pi/180.d0)*cos(Direct_soil*pi/180.d0)
        cosin_s(2) = -sin(Dip_soil*pi/180.d0)*sin(Direct_soil*pi/180.d0)
c
c-------compute the direction cosines of the sloping water table.
c       For the Dempla analysis, we use the following directions:
c         x_3 = upward (but sloping) direction perpendicular to the rock base
c       Direct_water is the direction of (downward) dip of the water
c       table, measured in degrees CCW from the x_1 direction.
c       Dip_water is the (downward) dip angle of the water table.
c         
        cosin_w(3) =  cos(Dip_water*pi/180.d0)
        cosin_w(1) = -sin(Dip_water*pi/180.d0)
     x                *cos(Direct_water*pi/180.d0)
        cosin_w(2) = -sin(Dip_water*pi/180.d0)
     x                *sin(Direct_water*pi/180.d0)
c
c-------gravitational acceleration components
        gaccel(1) = -grav*cosin_s(1)
        gaccel(2) = -grav*cosin_s(2)
        gaccel(3) = -grav*cosin_s(3)
c
c-------thickness of the computational elements represented by a
c       DEM RVE.  This is the thickness of the computational elements.
        dx_rve = BaseDepth / nRVEs
c
c-------this will be a bit confusing, since the layers in the input
c       file start at the top(surface), with each input row giving
c       information about a layer that is lower than the row above it.
c       On the other hand, to solve the wave equation, the nodes
c       start with 0 at bedrock and increase to nRVEs at the surface.
c       The RVEs begin with 1 for the computational element above
c       bedrock to nRVE for the element nearest the ground surface
c
c-------now that the input file has been read, giving information
c       on the stratigraphic layers, determine the lowest layer
c       that is above bedrock (since lower, extraneous input layers
c       might have been given).  Also check whether the total
c       thicknesses of the input layers is less than the depth to
c       rock (an error)
c
c-------the depths at the bottoms of the stratigraphic layers
        LayerBottom(0) = 0.
        do 100 iLayer = 1,nLayers
            LayerBottom(iLayer) = LayerBottom(iLayer-1)
     x                            + LayerThickness(iLayer)
c
c---------height of the layer's bottom above the base
          xLayerBottom(iLayer) = BaseDepth - LayerBottom(iLayer)
  100   continue
c
c-------find the lowest layer that is still (at least partially)
c       above rock
        do 102 iLayer = 1,nLayers
          if(LayerBottom(iLayer-1).lt.BaseDepth) then
            nLayerEff = iLayer
          endif
  102   continue
c
c-------the lowest (non-extraneous) soil layer. That is, ignore
c       any layers that have been input but lie entirely below
c       the rock depth
        nLayers = nLayerEff
c
c-------replace the depth of the bottom of the lowest layer
        LayerBottom(nLayers) = BaseDepth
        xLayerBottom(nLayers) = 0.
c
c-------if the bottom of the lowest layer is above the BaseDepth
        if(LayerBottom(nLayers).lt.BaseDepth) then
          write(*,903)
  903     format('The stratigraphic layers do not extend '
     x           'to the base depth.',/,
     x           'Change input file and rerun.')
          stop
        endif
c
c-------assemblies will likely need to be created at the RVEs,
c       based upon the StartFiles for the layers within which the
c       nRVEs reside.  There are likely more nRVEs than layers.  
c       For some layers, the StartFile of the layer will be used to
c       create assemblies at each of multiple nRVEs.  The assemblies
c       for all of the nRVEs that lie within a layer will be derived 
c       from the StartFile of that layer.  These assemblies will be
c       created by increasing (or decreasing) the mean stress,
c       starting with the conditions of the StartFile and running
c       the DEM algorithm to reach the target mean stress (a sort of
c       consolidation or rebound process).
c
c-------for each layer, do the following:
c         1) for each layer, determine the mean stress of the input
c            StartFile for the layer
c         2) identify the nRVEs (assemblies) that will be created
c            within that layer
c         3) determine whether the mean stress will be increased
c            or decreased for each rve, relative to the mean
c            stress of the StartFile
c         4) for efficiency, all nRVEs for which the mean stress
c            is increased will be created progressively from
c            DEM runs.  Separately, all nRVEs for which the mean
c            stress is decreased will be created in a progressive
c            manner from DEM runs.
c
c-------for each layer, read its StartFile to determine the vertical
c       (geostatic) effective stress
        do 110 iLayer = 1,nLayers
c
          if(iRunLayer_DEM(iLayer).ne.0) then
c-----------we must setup and run a DEM simulation to create the initial
c           C-file for this layer.  The DEM simulation is run from the
c           RunFile and StartFile (probably a D-file) in the "RunFiles/"
c           and "StartFiles" folders
c
c-----------path of the layer's RunFile, which will be used to create
c           the initial assembly for the layer, which will later be used
c           to create the initial assemblies of the RVEs within each
c           layer
            RunFilePath(iLayer) =
     x        'RunFiles/'//
     x        RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c    x        MainDir(1:LEN_TRIM(MainDir))//
c    x        '/01_LayerInput/'//
c    x        RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c-----------path of the RunFile for this layer
            filename1 = RunFilePath(iLayer)
c
c-----------path the layer's StartFile
            StartFilePath(iLayer) = 
     x        'StartFiles/'//
     x        StartFileLayer(iLayer)
     x         (1:LEN_TRIM(StartFileLayer(iLayer)))
c
c    x        MainDir(1:LEN_TRIM(MainDir))//
c    x        '/01_LayerInput/'//
c    x        StartFileLayer(iLayer)
c    x         (1:LEN_TRIM(StartFileLayer(iLayer)))
c
c-----------path of the StartFile for this layer
            filename2 = StartFilePath(iLayer)
c
c-----------string for this layer.  For example, 0023 for layer 23
            call int2str4(iLayer, strLayer)
c
c-----------print a message to the screen
            print *,'  Reading input and running DEM for layer '//
     x              strLayer//'...'
c
c-----------folder name
            OutputLayerFolder = 
     x        MainDir(1:LEN_TRIM(MainDir))//'/02_LayerSetup/'
c-----------RunFile name
            OutputRunFile(iLayer) = 
     x          'L'//strLayer//'-'//
     x          RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c-----------StartFile name
            filenameC = 
     x        StartFileLayer(iLayer)(1:LEN_TRIM(StartFileLayer(iLayer)))
c
c-----------this name will become the name of the C-file when the
c           the output of this run becomes the input of a later run
            InputRunFile(iLayer) = OutputRunFile(iLayer)
c
c-----------do not print DEM diagnoistics to the screen.  Print them
c           to an S-file
            lScreen = .false.
c
c-----------initialize files for recording error messages and screen output
            call initFilesRS(
     x             iLayer,
     x             OutputLayerFolder,
     x             OutputRunFile(iLayer),
     x             StartFileLayer(iLayer)
     x               (1:LEN_TRIM(StartFileLayer(iLayer))),
     x             ErrUnit(iLayer),
     x             mdim1,mp,mpiece,version,ScrUnit(iLayer),
     x             lScreen)
c
c-----------for the moment, we use rve=1 for reading the StartFile
            rve = 1
c
c-----------do not change the type of StartFile
            istartchng = -1
c
c-----------read both the RunFile and the StartFile
            extent2 = 0
c
c-----------read the RunFile and StartFile for this soil layer,
c           which will be used for creating the initial assemblies
c           for each of the RVEs within the layer
            call readit2(iLayer,istartchng,filename1,filename2,extent2)
c
c-----------initialize general parameters, particle properties, ect.
            call init(iLayer)
c
c-----------initialize the output A and B files for the process of 
c           running the DEM algorithm to create an initial assembly
c           for the layer.  This assembly will have an stress that
c           results from whatever loading is prescribed in the RunFile.
c           The following subroutin does the following: 1) assigns the
c           file numbers for the A and B output files, 2) opens these
c           files, 3) adds header information at the start of the files
c
            call initFilesAB(iLayer,
     x        OutputLayerFolder, OutputRunFile(iLayer), filenameC,
     x        ndim1,iheat(iLayer),hmodel(iLayer),lout,lporo(iLayer),
     x        mfiles,
     x        iporo(iLayer),
     x        version, partyp(iLayer), np(iLayer), ravg(iLayer), 
     x        voidn(iLayer),
     x        lHertz(iLayer),
     x        lJager(iLayer),lJagr2(iLayer),lJagr3(iLayer),
     x        lJagr4(iLayer),
     x        AUnit(iLayer),BUnit(iLayer),itxt(iLayer),Bversn)
c
c-----------create the link list of near-neighbors
            nnnear(iLayer) = mnear
            nlist(iLayer) = mlist
            nlist2(iLayer) = mlist2
            nlist3(iLayer) = mlist3
            nboxs(iLayer) = mboxes
            call lister(iLayer,nnnear(iLayer),
     x                  nlist(iLayer),nlist2(iLayer),nlist3(iLayer),
     x                  nboxs(iLayer))
c
c-----------elastic energy due to tangential force in Jager contacts
            if(lJager(iLayer) .or. lJagr2(iLayer)
     x         .or. lJagr3(iLayer) .or. lJagr4(iLayer)) then
c-------------work done in tangential contact movement (includes both elastic
c             deformation and sliding).
              if(istart(iLayer).le.2) then
                workc(iLayer) = 0.
              endif
            endif
c
c-----------whether to continue from a previous run (as when a 
c           restart "C" file is used to start a run)
            lcont = istart(iLayer).eq.3
c
c-----------print output of the initial conditions
            lfirst = .true.
c
c-----------force the DEM algorithm to create a C restart file at the
c           end of the DEM run
            iend(iLayer) = 3
c
c-----------the DEM algorithm
            call dem(iLayer,lcont,
     x               OutputLayerFolder,OutputRunFile(iLayer),lfirst)
c
c-----------flush the file buffers
            flush(AUnit(iLayer))
            flush(BUnit(iLayer))
            flush(ScrUnit(iLayer))
            flush(ErrUnit(iLayer))
c
c-----------close all output files
            call closem(lout, lScreen,
     x                  AUnit(iLayer), BUnit(iLayer),
     x                  ErrUnit(iLayer),
     x                  ScrUnit(iLayer),mfiles)
c
c-----------create a file to store the value of the void ratio at the
c           end of this dem run for the stratigraphic layer.  This value 
c           will be needed when iRunLayer_DEM=0
            filename3 = 
     x        OutputLayerFolder(1:LEN_TRIM(OutputLayerFolder))//
     x        'V'//
     x        InputRunFile(iLayer)(1:LEN_TRIM(InputRunFile(iLayer)))
c
c-----------create the file of void ratio for this layer
            open(unit=0,file=filename3)
            write(0,900) voidn(iLayer), vs(iLayer), vso(iLayer)
  900       format('# current void ratio, volume of solids, ',
     x             'and initial void ratio',/,
     x             3(1pe25.17))
            close(unit=0)
c
          elseif(iRunLayer_DEM(iLayer).eq.0) then
c-----------the C-file has already been created for the initial assembly
c           of this stratigraphic layer.  We will need to open this C-file
c           to read the initial stress.  This C-file will later be used
c           for creating the assemblies of the RVEs within this layer.
c           The layer's C-file should be located inside of the 
c           "MainDir"/02_LayerSetup/ folder, and its name should be
c           CLXXXX_YYYYY, where XXXX is the layer number and YYYYY is
c           the name of the setup file for this layer
c
c-----------string for this layer.  For example, 0023 for layer 23
            call int2str4(iLayer, strLayer)
c
            RunFilePath(iLayer) =
     x        'RunFiles/'//
     x        RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c    x        MainDir(1:LEN_TRIM(MainDir))//
c    x        '/01_LayerInput/'//
c    x        RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c-----------path of the RunFile for this layer
            filename1 = RunFilePath(iLayer)
            filename2 = ' '
c
c-----------do not change the type of StartFile
            istartchng = -1
c
c-----------read only the RunFile
            extent2 = 1
c
c-----------read the RunFile and StartFile for this soil layer,
c           which will be used for creating the initial assemblies
c           for each of the RVEs within the layer
            call readit2(iLayer,istartchng,filename1,filename2,extent2)
c
c-----------path of the layer's StartFile
            filename1 = 
     x        MainDir(1:LEN_TRIM(MainDir))//
     x        '/02_LayerSetup/'//
     x        'CL'//
     x        strLayer//
     x        '-'//
     x        RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c-----------only read the first part of the StartFile, to capture
c           the vertical stress
            extent = 1
c
c-----------read the StartFile to capture the vertical stress
            call dumpin(iLayer,filename1,extent)
c
c-----------folder name
            OutputLayerFolder = 
     x        MainDir(1:LEN_TRIM(MainDir))//'/02_LayerSetup/'
c
c-----------RunFile name, if the DEM simulation had been run
            InputRunFile(iLayer) = 
     x          'L'//strLayer//'-'//
     x          RunFileLayer(iLayer)(1:LEN_TRIM(RunFileLayer(iLayer)))
c
c-----------read the file which stores the value of the void ratio at the
c           end of the dem run of this layer.
            filename3 = 
     x        OutputLayerFolder(1:LEN_TRIM(OutputLayerFolder))//
     x        'V'//
     x        InputRunFile(iLayer)(1:LEN_TRIM(InputRunFile(iLayer)))
c
            open(unit=0,file=filename3,status='old')
            read(0,*) filename3
            read(0,*) voidn(iLayer), vs(iLayer), vso(iLayer)
            close(unit=0)
          endif
c
c---------the void ratio from the dem run
          lvoidno(iLayer) = voidn(iLayer)
c
c---------the horizontal and vertical effective stresses of this layer
          sigmaz(1,iLayer) = stress(1,3,iLayer)
          sigmaz(2,iLayer) = stress(2,3,iLayer)
          sigmaz(3,iLayer) = stress(3,3,iLayer)
c
c---------the pore fluid pressure of this layer
          pfluidz(iLayer) = pfluid(iLayer)
c
          if(VoidRatio(iLayer).lt.0.) then
c-----------if the input value of VoidRatio in the L-file is less than
c           zero, then use the actual void ratio of the dem assembly.
c           This void ratio will become the basis of computing the
c           evolution of the void ratios withn the rve assemblies during
c           the dempla run
            VoidRatio(iLayer) = lvoidno(iLayer)
          endif
c
c---------porosity of the layer
          lPorosity(iLayer) = VoidRatio(iLayer)
     x                       / (1.d0 + VoidRatio(iLayer))
c
c---------dry bulk density of soil, kg/m^3.  Note that we ignore two
c         minor effects when using rho_dry: (1) we ignore changes in 
c         G_s due to compression of the grains, and (2) we ignore the
c         mass of the air in the voids
          rho_dry(iLayer) = G_s(iLayer)
     x                      * rho_w / (1.d0 + VoidRatio(iLayer))
c
c---------saturated bulk density of soil, kg/m^3
          rho_sat(iLayer) = (G_s(iLayer) + VoidRatio(iLayer))
     x                      * rho_w / (1.d0 + VoidRatio(iLayer))
c
c---------the Biot (Zienkiowicz) permeability of water.  The geotechnical
c         hydraulic conductivity has units m/s and is defined by Darcy's
c         flow equation: (Q = k_geot*i*A), where "i" is the hydraulic
c         gradient and "A" is the flow area.  The geotechnical hydraulic
c         conductivity applies to water at 20 degrees Celsius and with the
c         earth's gravity..  At this temperature, the viscosity of water 
c         is 1.0 mPa*s.  We must use the visc_w to find the permeability 
c         for the input water viscosity.  Begin by finding the "kappa"
c         permeability, which is independent of the pore fluid and depends 
c         only on the grain matrix
          k_kappa = k_geot(iLayer) * 1.0d-3 / (rho_w * 9.81d0)
          k_w(iLayer) = k_kappa / visc_w
c
c         k_w(iLayer) = k_geot(iLayer) / (rho_w * grav)
c    x                  * 1.0d-3 / visc_w
c
c---------the Biot (Zienkiowicz) permeability of air
c         k_a(iLayer) = (visc_w / visc_a) * k_w(iLayer)
          k_a(iLayer) = k_kappa / visc_a
c
  110   continue
c
c-------print a message to the screen
        print *,'  Finished reading and running DEM for layers'
c
c-------in the remainder of this subroutin, we create the assemblies
c       for each RVE.  The assemblies are created so that the effective
c       stress and water pressure are at the geostatic conditions of
c       the RVE
c
c-------depths and positions of the nodes and RVEs
        do 120 rve = botrve,nRVEs
c---------depth of each node, measure downward from ground surface
          DepthNode(rve) = (nRVEs - rve) * dx_rve
c
c---------position of each node, measured upward from rock
          xNode(rve,1) = 0.
          xNode(rve,2) = 0.
          xNode(rve,3) = BaseDepth - DepthNode(rve)
c
c---------depths of the RVEs. The RVEs are midway between nodes.
c         Depth of each RVE, measure downward from ground surface
          DepthRVE(rve) =  DepthNode(rve) + 0.5d0*dx_rve
c
c---------position of each RVE, measured upward from rock
          xRVE(rve) =  BaseDepth - DepthRVE(rve)
  120   continue
c
c-------the bottom-most node
        DepthNode(0) = BaseDepth
        xNode(0,1) = 0.
        xNode(0,2) = 0.
        xNode(0,3) = 0.
c
c-------water height above the base.  Note that negative water depths are
c       allowed (i.e., when the ground surface is submerged)
        xWater = xNode(nRVEs,3) - WaterDepth
c
c-------map each rve to a layer
        do 140 rve = botrve,nRVEs
          do 142 iLayer = 1,nLayers
            if(      DepthRVE(rve).gt.LayerBottom(iLayer-1)
     x         .and. DepthRVE(rve).le.LayerBottom(iLayer  )) then
c
c-------------this rve lies within iLayer
              LayerRVE(rve) = iLayer
            endif
  142     continue
  140   continue
c
c-------the integrated density at the ground surface
        if(WaterDepth.ge.0.) then
          Integ_rho_s_surface = 0.
          Integ_rho_f_surface = 0.
        else
          Integ_rho_s_surface = -WaterDepth * rho_w
          Integ_rho_f_surface = -WaterDepth * rho_w
        endif
c
c-------find the integrated densities of the soil and of the pore fluid, 
c       measured from the ground surface downward to the RVEs. When 
c       multiplied by the acceleration of gravity, when find the total 
c       vertical stress at each RVE's depth.  We use the dry and 
c       saturated densities for those soils above and below the water 
c       table, respectively.
        do 150 rve = botrve,nRVEs
c---------we will add the soil densities of all stratigraphic layers 
c         above the RVE and at the RVE depth
          if(WaterDepth.ge.0.) then
            Integ_rho_s(rve) = 0.
          else
            Integ_rho_s(rve) = -WaterDepth * rho_w
          endif
c
c---------add the contributions of the integrated density at each RVE depth
          do 152 iLayer = 1,LayerRVE(rve)
c-----------the contribution of the stratigraphic layer to the integrated 
c           density at the RVE can be due to either dry soil (above the water 
c           table) and saturated soil (below the water table).  The thickness
c           of dry soil within the layer can not exceed:
c              * the space between the layer above and the RVE
c              * the space between the layer above and the water table
c              * the thickness of the layer
c           and this thickness must be greater than zero.
c           The thickness of the saturated soil within the layer can not
c           exceed:
c              * the space between the water table and the layer bottom
c              * the space between the water table and the RVE
c              * the space between the layer above and the RVE
c              * the thickness of the layer
c           and the thickness must be greater than zero
            Integ_rho_s(rve) =
     x        Integ_rho_s(rve)
     x          + dmax1(dmin1(dmin1(
     x                      (DepthRVE(rve)-LayerBottom(iLayer-1)),
     x                      (WaterDepth   -LayerBottom(iLayer-1)) ),
     x                    (LayerBottom(iLayer) -LayerBottom(iLayer-1))),
     x                  0.)
     x            * rho_dry(iLayer)
     x          + dmax1(dmin1(dmin1(dmin1(
     x                        (LayerBottom(iLayer) - WaterDepth),
     x                        (DepthRVE(rve)       - WaterDepth)  ),
     x                      (DepthRVE(rve) - LayerBottom(iLayer-1))),
     x                    (LayerBottom(iLayer)-LayerBottom(iLayer-1))),
     x                  0.)
     x            * rho_sat(iLayer)
  152     continue
  150   continue
c
c-------integrated pore fluid density at each RVE depth. This pressure 
c       will include the "density" of air for those RVEs above the water 
c       table.
        do 160 rve = botrve,nRVEs
          if(WaterDepth.ge.0.) then
            Integ_rho_f(rve) =
     x          dmin1(DepthRVE(rve), WaterDepth)      * rho_a
     x        + dmax1((DepthRVE(rve)-WaterDepth), 0.) * rho_w
          else
            Integ_rho_f(rve) = (DepthRVE(rve)-WaterDepth) * rho_w
          endif
c
c---------integrated bouyant density at the RVE.
c         EffStressRVE(rve) = Integ_rho_s(rve) - Integ_rho_f(rve)
c         Integ_rho_b(rve) = Integ_rho_s(rve) - Integ_rho_f(rve)
c
c---------total stresses in directions 1, 2, 3 (stresses 13, 23, and 33).
c         Note that we have integrated downward, so a change in sign
          TotalStress(1) = -grav*(  cosin_s(1)*Integ_rho_s(rve)
     x                            - cosin_w(1)*Integ_rho_f(rve))
          TotalStress(2) = -grav*(  cosin_s(2)*Integ_rho_s(rve)
     x                            - cosin_w(2)*Integ_rho_f(rve))
          TotalStress(3) = -grav*cosin_s(3)*Integ_rho_s(rve)
c
c---------the effective normal stress in the rotated directions, 
c         noting that the coordinate frame is rotated, so that 
c         the x_3 direction is perpendicular to the rock and soil surfaces
          EffStressRVE(1,rve) = TotalStress(1)
     x                          + grav*cosin_s(1)*Integ_rho_f(rve)
          EffStressRVE(2,rve) = TotalStress(2)
     x                          + grav*cosin_s(2)*Integ_rho_f(rve)
          EffStressRVE(3,rve) = TotalStress(3)
     x                          + grav*cosin_s(3)*Integ_rho_f(rve)
  160   continue
c
c-------we must create an assembly at each RVE.  These assemblies
c       are created from the StartFile of the stratigraphic layer
c       in which the RVE lies. The StartFile assembly is either
c       compressed or rebounded, so that the vertical effective 
c       stress of the assembly equals the effective stress at the 
c       RVE's depth.
c
c-------we also create each RVE assembly with the correct fluid pressure
c
c-------count the number of runs for creating new assemblies at the nRVEs
        nRuns = 0
c
c-------we begin this process by determining whether the effective stress
c       at each RVE is greater than or equal to the initial StartFile stress
        StressTol = 0.001d0
        do 170 iLayer = 1,nLayers
c---------create the string "strLayer" of the layer integer
          call int2str4(iLayer, strLayer)
          if(iRunRVE_DEM(iLayer).ne.0) then
            print *,'  The L-file for Layer '//strLayer//
     x              ' has iRunRVE_DEM=1, so a'//
     x              ' DEM preparation must be run'
c
c-----------initialize numbers of the RVEs within the layer that require
c           a higher, lower, and the same confinement stress
            RVEsInLayerUp(iLayer) = 0
            RVEsInLayerDn(iLayer) = 0
            RVEsInLayerNu(iLayer) = 0
c
            do 172 rve = botrve,nRVEs-topdif
c-------------for each RVE, determine whether the geostatic stress is
c             higher, lower, or the same as the confinement stress of
c             the input layer file
              if(LayerRVE(rve) .eq. iLayer) then
                if(EffStressRVE(3,rve) 
     x             .lt. (1.d0+StressTol)*sigmaz(3,iLayer)) then
c-----------------at this RVE, the stress of the initial DEM assembly
c                 is lower (more negative) than the geostatic stress
c                 for the RVE in the soil profile.  The DEM assembly 
c                 must be expanded to raise the stress upward
                  RVEsInLayerUp(iLayer) = RVEsInLayerUp(iLayer) + 1
                  RVELayerUp(iLayer,RVEsInLayerUp(iLayer)) = rve
                elseif(EffStressRVE(3,rve) 
     x             .gt. (1.d0-StressTol)*sigmaz(3,iLayer)) then
c-----------------at this RVE, the stress of the initial DEM assembly
c                 is higher (less negative) than the geostatic stress
c                 for the RVE in the soil profile.  The DEM assembly 
c                 must be compressed to lower the stress downward
                  RVEsInLayerDn(iLayer) = RVEsInLayerDn(iLayer) + 1
                  RVELayerDn(iLayer,RVEsInLayerDn(iLayer)) = rve
                else
c-----------------at this RVE, the stress of the initial DEM assembly
c                 is about the same as the geostatic stress for the RVE.
                  RVEsInLayerNu(iLayer) = RVEsInLayerNu(iLayer) + 1
                  RVELayerNu(iLayer,RVEsInLayerNu(iLayer)) = rve
                endif
              endif
  172       continue
c
c-----------the number of runs in which the vertical stress will be increased
            if(RVEsInLayerUp(iLayer).gt.0) then
              nRuns = nRuns + 1
              RunLayer(nRuns) = iLayer
              RunLayerUpDn(nRuns) = 1
            endif
c
c-----------the number of runs in which the vertical stress will be decreased
            if(RVEsInLayerDn(iLayer).gt.0) then
              nRuns = nRuns + 1
              RunLayer(nRuns) = iLayer
              RunLayerUpDn(nRuns) = -1
            endif
c
c-----------the number of runs in which the vertical stress will
c           not be changed, but in which the shearing stress may change
            if(RVEsInLayerNu(iLayer).gt.0) then
              if(.not.(Dip_soil.eq.0. .and. Dip_water.eq.0.)) then
                nRuns = nRuns + 1
                RunLayer(nRuns) = iLayer
                RunLayerUpDn(nRuns) = 0
              endif
            endif
          endif
  170   continue
c
c-------we now run DEM to raise or lower the effective stress and water
c       pressure of each RVE.  For a given layer, the RVEs that are raised
c       are done so with a loop that increases the stress in an RVE using
c       the state of the previous RVE
c
c-------the folder in which the output files are placed when the RVE
c       assemblies are created
        OutputSetupDir =
     x    MainDir(1:LEN_TRIM(MainDir))//'/03_RVESetup/'
c
c-------prepare each of the runs for creating the rve assemblies
        do 200 iRun = 1,nRuns
          iLayer = RunLayer(iRun)
          if(RunLayerUpDn(iRun).ne.0) then
            UpDn(iRun) = RunLayerUpDn(iRun)
          else
            UpDn(iRun) = -1
          endif
c
c---------the first and final RVE created with the DEM run
          if(RunLayerUpDn(iRun).eq.1) then
            rve_f(iRun) = RVELayerUp(iLayer,1)
            rve_o(iRun) = RVELayerUp(iLayer,RVEsInLayerUp(iLayer))
          elseif(RunLayerUpDn(iRun).eq.-1) then
            rve_f(iRun) = RVELayerDn(iLayer,RVEsInLayerDn(iLayer))
            rve_o(iRun) = RVELayerDn(iLayer,1)
          elseif(RunLayerUpDn(iRun).eq.0) then
            rve_f(iRun) = RVELayerNu(iLayer,1)
            rve_o(iRun) = RVELayerNu(iLayer,1)
          endif
c
c---------the StartFile that was placed in the "02_LayerSetup" folder
          filenameC = 'C'//
     x                InputRunFile(iLayer)
     x                  (1:LEN_TRIM(InputRunFile(iLayer)))
c
c---------create strings that represent nodes and layer
          call int2str4(rve_o(iRun), strRVE_o)
          call int2str4(rve_f(iRun), strRVE_f)
          call int2str4(iLayer, strLayer)
c
c---------the RunFile that will be used to create the RVE assemblies
          OutputRunFile(iLayer) = 
     x                  MainDir(1:LEN_TRIM(MainDir))//
     x                  '_RVEs_'//strRVE_o//'_'//strRVE_f//
     x                  '_Layer_'//strLayer
c
c---------do not print DEM diagnoistics to the screen.  Print them
c         to an S-file
          lScreen = .false.
c
c---------initialize files for recording error messages and screen output
          call initFilesRS(
     x           rve_o(iRun),
     x           OutputSetupDir,
     x           OutputRunFile(iLayer),
     x           filenameC,
     x           ErrUnit(rve_o(iRun)),
     x           mdim1,mp,mpiece,version,ScrUnit(rve_o(iRun)),
     x           lScreen)
c
c---------filenames containing input data for the DEM runs
          filename1 = RunFilePath(iLayer)
          filename2 =      
     x      MainDir(1:LEN_TRIM(MainDir))//
     x      '/02_LayerSetup/'//
     x      filenameC(1:LEN_TRIM(filenameC))
c
c---------force subroutin readit2 to read a C-type StartFile
          istartchng = 3
c
c---------read both the RunFile and the StartFile
          extent2 = 0
c
c---------read the RunFile and StartFile for this soil layer,
c         which will be used for creating the initial assemblies
c         for each of the RVEs within the layer
          call readit2(rve_o(iRun),istartchng,filename1,filename2,
     x                 extent2)
c
c---------initialize general parameters, particle properties, ect.
          call init(rve_o(iRun))
c
c---------create the linked list of near-neighbors
          nnnear(rve_o(iRun)) = mnear
          nlist(rve_o(iRun)) = mlist
          nlist2(rve_o(iRun)) = mlist2
          nlist3(rve_o(iRun)) = mlist3
          nboxs(rve_o(iRun)) = mboxes
          call lister(rve_o(iRun),nnnear(rve_o(iRun)),
     x          nlist(rve_o(iRun)),nlist2(rve_o(iRun)),
     x          nlist3(rve_o(iRun)),
     x          nboxs(rve_o(iRun)))
c
c---------initialize the A and B files
          call initFilesAB(rve_o(iRun),
     x      OutputSetupDir,OutputRunFile(iLayer),
     x      filenameC,
     x      ndim1,iheat(rve),hmodel(rve_o(iRun)),
     x      lout,lporo(rve_o(iRun)),mfiles,iporo(rve),
     x      version, partyp(rve_o(iRun)), np(rve_o(iRun)), 
     x      ravg(rve_o(iRun)),
     x      voidn(rve_o(iRun)),
     x      lHertz(rve_o(iRun)),
     x      lJager(rve_o(iRun)),lJagr2(rve_o(iRun)),
     x      lJagr3(rve_o(iRun)),
     x      lJagr4(rve_o(iRun)),
     x      AUnit(rve_o(iRun)),BUnit(rve_o(iRun)),
     x      itxt(rve_o(iRun)),Bversn)
c
c---------assign the control parameters for the first stage of
c         the run: a quiescent stage of zero stresss change
          iStage(iRun) = 1
          defrat(1,iStage(iRun),rve_o(iRun)) = 0.
          defrat(2,iStage(iRun),rve_o(iRun)) = 0.
          defrat(3,iStage(iRun),rve_o(iRun)) = 0.
          defrat(4,iStage(iRun),rve_o(iRun)) = 0.
          defrat(5,iStage(iRun),rve_o(iRun)) = 0.
          defrat(6,iStage(iRun),rve_o(iRun)) = 0.
          defrat(8,iStage(iRun),rve_o(iRun)) = 0.
          ipts(iStage(iRun),rve_o(iRun)) = 20
          idump(iStage(iRun),rve_o(iRun)) = 0
          imicro(iStage(iRun),rve_o(iRun)) = 0
          defdot(iStage(iRun),rve_o(iRun)) = 0.
          ipts2(iStage(iRun),rve_o(iRun)) = 0
          iplot(iStage(iRun),rve_o(iRun)) = 0
c
c---------with the first run, let the assembly quiesce
          icontr(iStage(iRun),rve_o(iRun)) = 111000
          icontp(iStage(iRun),rve_o(iRun)) = 1
          igoal(iStage(iRun),rve_o(iRun)) = 70
          finalv(iStage(iRun),rve_o(iRun)) = 100.d0
  200   continue
c
c-------folder for placing output files that will be created when creating
c       the RVE assemblies
        OutputFolderName = 
     x    MainDir(1:LEN_TRIM(MainDir))//
     x    '/03_RVESetup/'
c
c-------initialize the stress rates for creating the initial RVEs
        do 244 rve = botrve,nRVEs-topdif
          BaseRate(1,rve) = 0.
          BaseRate(2,rve) = 0.
          BaseRate(3,rve) = 0.
  244   continue
c
c-------with each of the stratigraphic layers, do one or two series
c       of DEM runs to create rve assemblies
c
c-------this loop can be parallelized, but I am unable to find an error
c       in the shared variables, so I will comment for now
c!$OMP   PARALLEL DO SCHEDULE(STATIC)
c!$OMP+              PRIVATE(iRun, rve, iLayer, lcont)
        do 240 iRun = 1,nRuns
c
c---------step of the DEM run
          iStage(iRun) = 1
c
c---------the initial horizontal and vertical effective stresses
          EffStressPrev(1,iRun) = sigmaz(1,RunLayer(iRun))
          EffStressPrev(2,iRun) = sigmaz(2,RunLayer(iRun))
          EffStressPrev(3,iRun) = sigmaz(3,RunLayer(iRun))
          pPrev(iRun) = pfluidz(RunLayer(iRun))
c
          do 242 rve = rve_o(iRun),rve_f(iRun),-UpDn(iRun)
c-----------run the DEM algorithm to create the rve assemblies
c
c-----------use common output files for all RVEs that are being created
c           with this DEM run
            ErrUnit(rve) = ErrUnit(rve_o(iRun))
            ScrUnit(rve) = ScrUnit(rve_o(iRun))
            AUnit(rve) = AUnit(rve_o(iRun))
            BUnit(rve) = BUnit(rve_o(iRun))
c
c-----------convert the RVE number to a string
            call int2str4(rve,strRVE(iRun))
c
            print *,'  Running DEM code for RVE '//strRVE(iRun)//'...'
c
c-----------first, assign control parameters to the remaining stages of
c           the dem run:  one stage for each of the nRVEs that are
c           being created with this run
c
c-----------the control stage
            iStage(iRun) = iStage(iRun) + 1
c
c-----------here, we "clone" the previous rve assembly into the next
c           rve assembly, before increasing the stress of the next rve
c           assembly, so that the next assembly attains the target
c           stress (i.e. depth)
c!$OMP       CRITICAL
            if(rve.ne.rve_o(iRun)) then
              rveo(iRun) = rve + UpDn(iRun)
              call clonify(rveo(iRun),rve)
            endif
c!$OMP       END CRITICAL
c
c-----------the reference effective stress for the layer conditions
c           is the initial stress developed with the layer's StartFile,
c           and the first part of the run starts with this stress
c           EffStressRVE(0) = -sigmaz(RunLayer(iRun))
c
c-----------to progressively prepare rve assemblies, we will load
c           at a constant rate of stress, "BaseRate", so that the next
c           rve assembly is created from the previous rve assembly
c           after "nbetwn" time steps (i.e. strain steps)
c           if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
            if(.false.) then
c-------------level ground and water
              BaseRate(1,rve) = 0.
              BaseRate(2,rve) = 0.
            else
c-------------sloping ground or water
              BaseRate(1,rve) =
     x          (EffStressRVE(1,rve) - EffStressPrev(1,iRun)) / nbetwn
              BaseRate(2,rve) =
     x          (EffStressRVE(2,rve) - EffStressPrev(2,iRun)) / nbetwn
            endif
c
            BaseRate(3,rve) =
     x        (EffStressRVE(3,rve) - EffStressPrev(3,iRun)) / nbetwn
c
c-----------progressively prepare rve assemblies with the target
c           pore fluid pressure
            BaseRate_p(rve) = 
     x        (grav*cosin_s(3)*Integ_rho_f(rve) - pPrev(iRun)) 
     x        / nbetwn
c
c-----------isotropic or anisotropic consolidation
            if(     Isotropic(RunLayer(iRun)).eq.0
     x         .or. Isotropic(RunLayer(iRun)).eq.1) then
c-------------isotropic consolidation.  Change the effective stress at
c             an equal stress rate in all directions
              icontp(iStage(iRun),rve) = 1
              defrat(1,iStage(iRun),rve) = BaseRate(3,rve)
              defrat(2,iStage(iRun),rve) = BaseRate(3,rve)
              defrat(3,iStage(iRun),rve) = BaseRate(3,rve)
              defrat(8,iStage(iRun),rve) = BaseRate_p(rve)
c             if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
              if(.false.) then
c---------------level ground and level water surface
                icontr(iStage(iRun),rve) = 111000
                defrat(4,iStage(iRun),rve) = 0.
                defrat(5,iStage(iRun),rve) = 0.
                defrat(6,iStage(iRun),rve) = 0.
              else
c---------------sloping ground or water surface
                icontr(iStage(iRun),rve) = 111011
                defrat(4,iStage(iRun),rve) = 0.
                defrat(5,iStage(iRun),rve) = BaseRate(1,rve)
                defrat(6,iStage(iRun),rve) = BaseRate(2,rve)
              endif
              igoal(iStage(iRun),rve) = 70
              finalv(iStage(iRun),rve) = nbetwn
            elseif(Isotropic(RunLayer(iRun)).eq.2) then
c-------------anisotropic consolidation.  Change the vertical effective
c             stress at a constant stress rate, while maintaining constant
c             lateral stresses
              icontp(iStage(iRun),rve) = 1
              defrat(1,iStage(iRun),rve) = 0.
              defrat(2,iStage(iRun),rve) = 0.
              defrat(3,iStage(iRun),rve) = BaseRate(3,rve)
              defrat(8,iStage(iRun),rve) = BaseRate_p(rve)
c             if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
              if(.false.) then
c---------------level ground and level water surface
                icontr(iStage(iRun),rve) = 001000
                defrat(4,iStage(iRun),rve) = 0.
                defrat(5,iStage(iRun),rve) = 0.
                defrat(6,iStage(iRun),rve) = 0.
              else
c---------------sloping ground or water surface
                icontr(iStage(iRun),rve) = 001011
                defrat(4,iStage(iRun),rve) = 0.
                defrat(5,iStage(iRun),rve) = BaseRate(1,rve)
                defrat(6,iStage(iRun),rve) = BaseRate(2,rve)
              endif
              igoal(iStage(iRun),rve) = 70
              finalv(iStage(iRun),rve) = nbetwn
            endif
c
c-----------remaining control parameters for consolidating the rve assembly
c           defrat(4,iStage(iRun),rve) = 0.
c           defrat(5,iStage(iRun),rve) = 0.
c           defrat(6,iStage(iRun),rve) = 0.
            ipts(iStage(iRun),rve) = 20
            idump(iStage(iRun),rve) = 0
            imicro(iStage(iRun),rve) = 0
            defdot(iStage(iRun),rve) = 0.
            ipts2(iStage(iRun),rve) = 0
            iplot(iStage(iRun),rve) = 0
c
c-----------a quiescent stage that follows consolidation
            iStage(iRun) = iStage(iRun) + 1
c
c-----------assign control parameters for the quiesent period
            defrat(1,iStage(iRun),rve) = 0.
            defrat(2,iStage(iRun),rve) = 0.
            defrat(3,iStage(iRun),rve) = 0.
            defrat(4,iStage(iRun),rve) = 0.
            defrat(5,iStage(iRun),rve) = 0.
            defrat(6,iStage(iRun),rve) = 0.
            defrat(8,iStage(iRun),rve) = 0.
            ipts(iStage(iRun),rve) = 100
            idump(iStage(iRun),rve) = 0
            imicro(iStage(iRun),rve) = 0
            defdot(iStage(iRun),rve) = 0.
            ipts2(iStage(iRun),rve) = 0
            iplot(iStage(iRun),rve) = 0
c
c-----------with the first run, let the assembly quiesce
            if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
c-------------with level ground and water, maintain constant normal stresses
              icontr(iStage(iRun),rve) = 111000
            else
c-------------with sloping ground or water, maintain constant normal
c             and shear stresses
              icontr(iStage(iRun),rve) = 111011
            endif
            icontp(iStage(iRun),rve) = 1
            igoal(iStage(iRun),rve) = 70
            finalv(iStage(iRun),rve) = 2000.d0
c
c-----------the starting control step
            if(rve.eq.rve_o(iRun)) then
c-------------with the first run, we had added an extra quiescent stage, so
c             that 
              istep(rve) = 0
            else
c-------------we begine the subroutin dem with the previous "istep", which
c             is immediately increased when the next stage is registered
              istep(rve) = iStage(iRun) - 2
            endif
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the control step, which, when it is reached, causes 
c           subroutin dem to exit
            istepm(rve) = iStage(iRun)
c
c-----------whether to continue from a previous run (as when a restart 
c           "C" file is used to start a run)
            lcont = .true.
c
c-----------do not print output of the initial conditions
            lfirst = .false.
c
c-----------the layer in which the RVE resides
            iLayer = RunLayer(iRun)
c
c-----------the DEM algorithm. Run DEM to establish the initial stress
c           conditions for the RVEs within the soil column
            call dem(rve,lcont,OutputFolderName,OutputRunFile(iLayer),
     x               lfirst)
c
c-----------hold the result of this run
            EffStressPrev(1,iRun) = stress(1,3,rve)
            EffStressPrev(2,iRun) = stress(2,3,rve)
            EffStressPrev(3,iRun) = stress(3,3,rve)
            pPrev(iRun) = pfluid(rve)
c
c-----------straighten the Jager equivalent load paths, to save memory
c!$OMP       CRITICAL
            if(     lJager(rve) .or. lJagr2(rve) 
     x         .or. lJagr3(rve) .or. lJagr4(rve)) then
              call stratn(rve)
            endif
c
c-----------path of the C-file where the RVE run is saved
            apend(rve) =
     x        MainDir(1:LEN_TRIM(MainDir))//
     x        '/03_RVESetup/'//
     x        'C'//
     x        MainDir(1:LEN_TRIM(MainDir))//
     x        '_RVE_'//
     x        strRVE(iRun)
c
c-----------create a (binary) restart path named in 'apend(rve)'
            iend(rve) = 3
            call dumpot(rve)
            iend(rve) = 0
c!$OMP       END CRITICAL
c
  242     continue
c
c---------close all output files
          call closem(lout, lScreen,
     x                AUnit(rve_o(iRun)), BUnit(rve_o(iRun)),
     x                ErrUnit(rve_o(iRun)),
     x                ScrUnit(rve_o(iRun)),mfiles)
c
  240   continue
c!$OMP   END PARALLEL DO
c
c-------print message to screen
        print *,'  Finished reading and running DEM for RVE assemblies'
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine pla
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        parameter(mrms=1)
c
        integer*2 extent, iat, iDempla_out, ier, iGrad,
     x            iLayer, iLayer_sav, 
     x            imod, imrve, irms, irve, 
     x            itask, itrate, izero,
     x            jLayer,
     x            n2, nmods, node, nnnear, rve, rve_sav,
     x            Unit_chi, Unit_ddu3, Unit_ddw, Unit_grad_max, Unit_I,
     x            Unit_kn, Unit_kperm, Unit_mass,
     x            Unit_p, Unit_Porosity, Unit_rms,
     x            Unit_rho_soil, Unit_rho_fluid, Unit_sat,
     x            Unit_s_11, Unit_s_12, Unit_s_13, 
     x            Unit_s_22, Unit_s_23, Unit_s_33, Unit_steps,
     x            Unit_time,
     x            Unit_u_1, Unit_u_2, Unit_u_3,
     x            Unit_w, Unit_water
c
        integer*4 i4, iAbove, iConsol, iPostShake, iShake,
     x            iStage, iStage2, iStage_m1, iStage_0, 
     x            nboxs, nlist, nlist2, nlist3, nlistJ,
     x            nDEMsteps, nSteps_rve
c
        double precision AAk BB, C_1, C_2, C_2inv, 
     x                   C_w, chi_target, chidat_sav, 
     x                   CC, chi_now, Cnumber, Courant, 
     x                   ddef_shake, ddu, ddw, Dcurnt, 
     x                   def_old, defsav, defw_tmp, defw_new,
     x                   dm_stress, dp, dp2, dt_ref, dt_rve, 
     x                   duNode, dwNode,
     x                   epsv, frms,
     x                   G_h, G_h_1, G_h_1_sav, G_h_2, G_h_2_sav,
     x                   grad_grad_p, grad_max, grad_max2, 
     x                   grad_max_avg, 
     x                   grad_p, grad_p_old, grad_p1, grad_p2, 
     x                   grad_rho_kZ, grad_rho_udd_kZ,
     x                   grad_sigma, grad_sigma_old,
     x                   grad_sigma1, grad_sigma2,
     x                   grad_u_dot, grad_u_dot2, 
     x                   grad_u_rve, grad_w_rve,
     x                   grad_u_rve_sum, grad_w_rve_sum,
     x                   hdef_sav, hstress_sav, 
     x                   I_now, I_ref, Integ_rho_f_surface,
     x                   Integ_rho_s_sav, Integ_rho_s_surface,
     x                   J_f, J_fo, J_w,
     x                   K_fluid, K_w_1, K_w_1_sav, K_w_2, K_w_2_sav,
     x                   kmdat_sav, kn_now, kperm, kperm_avg,
     x                   M_h, M_h_1, M_h_1_sav, M_h_2, M_h_2_sav,
     x                   mass_now, massdat_sav, modulus_RVE, ovrdat_sav,
     x                   p_above, p_below, p_dot, 
     x                   p_next, p_old, p_ref_rve, p_ref_surface,
     x                   p_table,
     x                   pdat_sav, pfluid_tmp, pfluidRVEo, pgrad,
     x                   Porosity, Porosity_avg, prop_chi_ref,
     x                   rho_d, rho_f, rho_fluid, rho_fluid_avg, 
     x                   rho_s, rho_soil,
     x                   rho_soil_avg, RightSide, 
     x                   rms_grad_factor, rms_grad_max, rms_grad_target,
     x                   S_tmp, srms, 
     x                   stress_dot, stress_old, stressRVEo,
     x                   tBase, TotStressRVEsav,
     x                   Total_stress_rve, Total_stress_rve_sav,
     x                   Total_stress_surface,
     x                   tRock, tRock_max,
     x                   u_dot, u_dot_next, u_dot_old, uNode,
     x                   v_RVE, v_max, vdef_sav, voidnb, voidnp,
     x                   vsol,vstress_sav,
     x                   w_dot, w_dot_next, w_dot_old,
     x                   wdef_sav, wstress_sav,
     x                   wNode, 
     x                   xat, xBase, xBaseSave, xfill, xGrad, xin, xtmp,
     x                   yat, ydiff, yin
c
        logical lAbove, lConsol, lcont, ldelay, ldemrun, lfirst,
     x          lKeepRock, lPostShake, lShake, ltoggl
c
        character*4 strLayer, strRVE
        character*32 errmsg
        character*400 InputCfileDir, InputRunFileDir, filenameC,
     x                filename3, filename4,
     x                OutputDir, OutputDir2, OutputRunFile,
     x                OutputPrefix, OutputSuffix
        character*800 filename1, filename2
c
        dimension C_1(8,8),C_2(8,8),C_2inv(8,8),
     x            chidat_sav(0:mrve), chi_now(0:mrve),
     x            ddef_shake(0:mrve), ddu(3,0:mrve),ddw(0:mrve),
     x            def_old(3,3,0:mrve), defw_new(0:mrve),
     x            defsav(3,3,0:mrve), duNode(0:mrve,3), dwNode(0:mrve),
     x            frms(mrms),
     x            G_h(0:mrve), G_h_1(0:mrve), G_h_1_sav(modsav), 
     x            G_h_2(0:mrve), G_h_2_sav(modsav), 
     x            grad_grad_p(0:mrve), grad_max(0:mrve), 
     x            grad_max2(0:mrve),
     x            grad_p(0:mrve), grad_p_old(0:mrve),
     x            grad_p1(0:mrve), grad_p2(0:mrve),
     x            grad_rho_kZ(0:mrve), grad_rho_udd_kZ(0:mrve),
     x            grad_sigma(0:mrve,3), grad_sigma_old(0:mrve,3),
     x            grad_sigma1(0:mrve,3), grad_sigma2(0:mrve,3),
     x            grad_u_dot(0:mrve), grad_u_dot2(0:mrve),
     x            grad_u_rve(0:mrve,3), 
     x            grad_w_rve(0:mrve),
     x            grad_u_rve_sum(0:mrve,3), grad_w_rve_sum(0:mrve),
     x            hdef_sav(0:2,0:mrve), hstress_sav(0:2,0:mrve),
     x            I_now(0:mrve), I_ref(0:mrve),
     x            iLayer_sav(modsav), Integ_rho_s_sav(0:mrve), 
     x            J_fo(0:mrve),
     x            K_w_1(0:mrve), K_w_1_sav(modsav), 
     x            K_w_2(0:mrve), K_w_2_sav(modsav),
     x            kmdat_sav(0:mrve), kn_now(0:mrve), 
     x            kperm(0:mrve), kperm_avg(0:mrve),
     x            M_h(0:mrve), M_h_1(0:mrve), M_h_1_sav(modsav),
     x            M_h_2(0:mrve), M_h_2_sav(modsav), 
     x            mass_now(0:mrve), massdat_sav(0:mrve),
     x            ovrdat_sav(0:mrve),
     x            p_dot(0:mrve), p_next(0:mrve), p_old(0:mrve), 
     x            p_ref_rve(0:mrve), pdat_sav(0:mrve),
     x            pfluidRVEo(0:mrve), 
     x            Porosity(0:mrve), Porosity_avg(0:mrve),
     x            prop_chi_ref(0:mrve),
     x            rho_d(0:mrve), rho_f(0:mrve), rho_fluid(0:mrve), 
     x            rho_fluid_avg(0:mrve),
     x            rho_s(0:mrve), rho_soil(0:mrve), rho_soil_avg(0:mrve),
     x            RightSide(8), rve_sav(modsav),
     x            S_avg(0:mrve),
     x            stress_dot(3,3,0:mrve), stress_old(3,3,0:mrve), 
     x            stressRVEo(0:mrve,3,3),
     x            tBase(0:mbase), 
     x            Total_stress_rve(0:mrve,3), 
     x            Total_stress_rve_sav(0:mrve,3), 
     x            Total_stress_surface(3),
     x            TotStressRVEsav(0:mrve),
     x            tRock(0:mRock),
     x            u_dot(3,0:mrve), u_dot_next(3,0:mrve),
     x            u_dot_old(3,0:mrve),uNode(0:mrve,3),
     x            vdef_sav(0:2,0:mrve), voidnb(0:mrve),
     x            vsol(0:mrve), vstress_sav(0:2,0:mrve),
     x            w_dot(0:mrve), w_dot_next(0:mrve), 
     x            w_dot_old(0:mrve),
     x            wdef_sav(0:2,0:mrve), wstress_sav(0:2,0:mrve),
     x            wNode(0:mrve), xBase(3,0:mbase), xBaseSave(3),
     x            xin(3), yin(3)
c
        dimension filenameC(0:mrve), OutputRunFile(0:mrve), 
     x            strLayer(0:mrve), strRVE(0:mrve)
c
        dimension lAbove(0:mrve),ldelay(0:mrve)
c
        dimension nboxs(0:mrve),
     x            nlist(0:mrve), nlist2(0:mrve), nlist3(0:mrve)
c
        dimension iStage(0:mrve), iStage2(0:mrve),
     x            nDEMsteps(0:mrve), nnnear(0:mrve)
c
c-------this subroutin does the following:
c         1) reads the StartFiles that were created with subroutin setup
c         2) computes the stiffness moduli of the assemblies and finds
c            the dempla time step
c         3) runs the time-stepping dempla algorithm to compute motions
c            and stresses during wave propagation and consolidation
c
c-------whether to use a 1st-order or 2nd-order approximation 
c       of the gradients of stress and pressaure at the gournd surface.
c       iGrad=1 (1st-order), iGrad=2 (2nd-order)
        iGrad = 1
c
c-------the gradients at times t and t-dt will be weighted, by the ratios
c       xGrad and (1.d0 - xGrad)
        xGrad = 1.d0
c
c-------the folder that will contain the A, B, R, and S files for the
c       wave propagation analysis
        OutputDir =
     x    MainDir(1:LEN_TRIM(MainDir))//'/04_RunOutput/'
c
c-------the folder that will contain the A, B, R, and S files for
c       finding the stiffnes moduli, which are needed to find the
c       dempla time step.  The files in this folder were already
c       created in subroutin setup
        OutputDir2 =
     x    MainDir(1:LEN_TRIM(MainDir))//'/03_RVESetup/'
c
c-------the folder in which the input layer RunFiles had been placed
        InputRunFileDir = 'Runfiles/'
c    x    MainDir(1:LEN_TRIM(MainDir))//'/01_LayerInput/'
c
c-------the folder in which the input C-files have been placed when 
c       the RVE assemblies were created in subroutin setup
        InputCfileDir =
     x    MainDir(1:LEN_TRIM(MainDir))//'/03_RVESetup/'
c
c-------do not display the run output details on the screen, but write
c       the details to files
        lScreen = .false.
c
c-------no body forces and no rigid platens (periodic boundaries will be used)
        lbodyf = .false.
        lplatn = .false.
c
c-------whether to print output of the initial conditions
        lfirst = .true.
c
c-------a 2-byte zero
        izero = 0
c
c-------used for toggling whether to reset servo-control parameters at the
c       start of consolidation
        ltoggl = .false.
c
c-------initialize matrices used for advancing node displacements
        do 10 i =1,8
          RightSide(i) = 0.
          do 12 j = 1,8
            C_1(i,j) = 0.
            C_2(i,j) = 0.
            C_2inv(i,j) = 0.
   12     continue
   10   continue
c
c-------initialize node velocities
        do 20 node=0,nRVEs
c---------velocities in directions 1, 2, and 3
          u_dot(1,node) = 0.
          u_dot(2,node) = 0.
          u_dot(3,node) = 0.
c---------relative velocity of the fluid in the vertical direction
          w_dot(node) = 0.
c
          u_dot_old(1,node) = 0.
          u_dot_old(2,node) = 0.
          u_dot_old(3,node) = 0.
          w_dot_old(node) = 0.
c
          u_dot_next(1,node) = 0.
          u_dot_next(2,node) = 0.
          u_dot_next(3,node) = 0.
          w_dot_next(node) = 0.
c
c---------accelerations
          ddu(1,node) = 0.
          ddu(2,node) = 0.
          ddu(3,node) = 0.
          ddw(node) = 0.
c
c---------initialize gradients of the total stress and fluid pressure
          grad_sigma(node,1) = 0.;
          grad_sigma(node,2) = 0.;
          grad_sigma(node,3) = 0.;
          grad_p(node) = 0.
c
c---------inertial number
          I_now(node) = 0.
          kn_now(node) = 0.
          chi_now(node) = 0.
          mass_now(node) = 0.
          nDEMsteps(node) = 0
   20   continue
c
c-------in this loop, we read the C-file of each RVE assembly and assign
c       basic properties to each RVE: porosity, permeability, pore fluid
c       stiffness, etc.  
        do 100 rve = botrve,nRVEs-topdif
c---------the stratigraphic layer within which the RVE lies
          iLayer = LayerRVE(rve)
c
c---------convert the RVE and Layer numbers to strings
          call int2str4(rve,strRVE(rve))
          call int2str4(iLayer,strLayer(rve))
c
c---------print message to screen
          print *,'  Reading the C-file input for RVE '//
     x            strRVE(rve)//
     x            ' in Layer '//
     x            strLayer(rve)//
     x            '...'
c
c---------the StartFile that was placed in the "03_RVESetup" folder
          filenameC(rve) = 'C'//
     x                     MainDir(1:LEN_TRIM(MainDir))//
     x                     '_RVE_'//
     x                     strRVE(rve)
c
          filename1 = RunFilePath(iLayer)
          filename2 =      
     x      InputCfileDir(1:LEN_TRIM(InputCfileDir))//
     x      filenameC(rve)(1:LEN_TRIM(filenameC(rve)))
c
c---------force subroutin readit2 to read a C-type StartFile
          istartchng = 3
c
c---------read both the RunFile and the StartFile
          extent = 0
c
c---------read the RunFile and StartFile for this soil layer,
c         which will be used for creating the initial assemblies
c         for each of the RVEs within the layer
          call readit2(rve,istartchng,filename1,filename2,extent)
c
  100   continue
c
c-------a kluge to recover the volume of solids.  "vso" is not stored in
c       C-files.  The value for each stratigraphic layer was stored within
c       the V-file of subroutin setup.  We must assign the layer values
c       to values for the RVEs. First, save the values to another array
        do 102 iLayer=1,nLayers
          vsol(iLayer) = vso(iLayer)
  102   continue
c
c-------now, assign the saved value to the RVEs
        do 104 rve = botrve,nRVEs
c---------the stratigraphic layer in which the rve lies
          iLayer = LayerRVE(rve)
c
c---------assign the solid volume to each RVE
          vso(rve) = vsol(iLayer)
c
c---------saved deformations
          defsav(1,1,rve) = def(1,1,rve)
          defsav(1,2,rve) = def(1,2,rve)
          defsav(1,3,rve) = def(1,3,rve)
          defsav(2,2,rve) = def(2,2,rve)
          defsav(2,3,rve) = def(2,3,rve)
          defsav(3,3,rve) = def(3,3,rve)
          defsav(2,1,rve) = 0.
          defsav(3,1,rve) = 0.
          defsav(3,2,rve) = 0.
c
c---------performance parameter for RVEs
          grad_max(rve) = 0.
  104   continue
c
c-------the analysis in subroutin setup was based upon an approximate void
c       ratio and an approximate saturation.  We will solve the void ratio,
c       saturation, water density, and soil density and the initial total 
c       stress and water pressure at each rve.  An iterative approach is 
c       needed
        do 300 itrate=1,3
c
          do 310 rve = botrve,nRVEs-topdif
c
c-----------the stratigraphic layer in which the rve lies
            iLayer = LayerRVE(rve)
c
c-----------First, the void ratio of the rve's.  This void ratio is based 
c           upon the reference Porosity in the L-file (when this input value 
c           is < 0, then we use the porosity of the dem assembly).  This
c           reference porosity is assumed as the state of the soil after 
c           the initial dem run of the L-files, but before the rve's were
c           consolidated at their various depths.  Note that this reference
c           porosity changes when the rve's are consolidated at the various
c           depths within the layer.
c
c-----------the assumed initial void ratio of the assembly
            voidno(rve) = VoidRatio(iLayer)
c
c-----------the actual void ratio of the assembly
            voidnp = (xcell(1,1,rve)*xcell(2,2,rve)*xcell(3,3,rve)
     x                - vso(rve))
     x               /vso(rve)
c
c-----------the void ratio of the RVE, based upon the assumed and
c           actual initial void ratios (voidno and voidna) and the 
c           current void ratio
            voidnb(rve) = voidno(rve)
     x                    - (lvoidno(iLayer) - voidnp)
     x                      * (1.d0 + voidno(rve))
     x                      / (1.d0 + lvoidno(iLayer))
c
c-----------revise the Porosity
            Porosity(rve) = voidnb(rve) / (1.d0 + voidnb(rve))
c
c-----------dry bulk density of soil, kg/m^3.  Note that we ignore two
c           minor effects when using rho_dry: (1) we ignore changes in 
c           G_s due to compression of the grains, and (2) we ignore the
c           mass of the air in the voids
            rho_d(rve) = (G_s(iLayer)*rho_w + voidnb(rve)*rho_a)
     x                   / (1.d0 + voidnb(rve))
c
c-----------saturated density of soil, kg/m^3
            rho_s(rve) = (G_s(iLayer) + voidnb(rve))
     x                   * rho_w / (1.d0 + voidnb(rve))
c
c-----------second, the saturation of the pore fluid
c
            if(.true.) then
c-------------bulk density
              if(iporo(rve).eq.1) then
c---------------the assembly is assumed to be saturated
c               rho_soil(rve) = rho_s(rve)
c
c---------------density of pore fluid, if the fluid is water/air
                rho_f(rve) = rho_w
              elseif(iporo(rve).eq.3) then
c---------------the assemply can contain bubbles or bubbles might form.  We
c               must find the current saturation
c
c---------------a model of pore fluid compressibility that includes 
c               dissolution of pore gas and includes surface tension 
c               of gas bubbles.  Besides the parameters listed above, 
c               these other parameters are involved in computing the 
c               water pressure.  Note that "pfluid" is the liquid-phase 
c               pore pressure, measured relative to atmospheric pressure
c
c               * gamm is the bubble surface tension
c               * p_atm is the reference atmospheric pressure
c               * Hcc is the dimensionless Henrys coefficient
c               * S_o is the initial saturation of the pore fluid with liquid
c               * D_o is the initial bubble size
c               * N_o is the initial number/density of bubbles
c
c---------------Jacobian of the bulk deformation gradient
                J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c---------------compressibility of pore liquid
                C_w = 1.d0 / K_f(rve)
c
c---------------change in mean effective stress from the original (reference)
c               condition
                dm_stress = 
     x            ( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x             -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve)))
     x            /3.d0
c
c---------------whether to compute (1) water pressure for a given strain, or
c               (2) fluid strain for a given water pressure
                itask = 1
c
c---------------small number that is used to find the threshold
c               volumetric strain (or water pressure) of the pore
                epsv = 1d-10
c
c---------------temporary values when calling bubble
                pfluid_tmp = pfluid(rve)
                S_tmp = S_now(rve)
                defw_tmp = defw(rve)
c
c---------------subroutin for finding water pressure and bubble size
c               of quasi-saturated soil
                call bubble(gamm(rve), p_atm(rve), p_o(rve), 
     x                    Hcc(rve), C_w, S_o(rve), D_o(rve), N_o(rve),
     x                    J_f, pfluid_tmp, p_vap(rve), p_wcav(rve), 
     x                    Dcurnt, S_tmp,
     x                    K_s(rve), poros0(rve), defw_tmp, dm_stress,
     x                    Dlast(rve), itask)
c
c---------------save current bubble diameter, to expedite the next time step
                Dlast(rve) = Dcurnt
c
c---------------now, the bulk density, including the effect of partial
c               saturation, if the soil was saturated
                rho_s(rve) = (1.d0 - S_tmp)*rho_d(rve)
     x                        + S_tmp*rho_s(iLayer)
c
c---------------density of pore fluid for air-water mixture, if the soil
c               was water/air (not air only)
                rho_f(rve) = (1.d0 - S_tmp)*rho_a
     x                       + S_tmp*rho_w
              elseif(iporo(rve).eq.4) then
c---------------air-filled voids
c
c---------------now, the bulk density, including the effect of partial
c               saturation, if the soil was saturated
                rho_s(rve) = (1.d0 - S_o(rve))*rho_d(rve)
     x                        + S_o(rve)*rho_s(iLayer)
c
c---------------density of pore fluid for air-water mixture, if the soil
c               was water/air (not air only)
                rho_f(rve) = (1.d0 - S_o(rve))*rho_a
     x                       + S_o(rve)*rho_w
              endif
            endif
c
            if(DepthRVE(rve).lt.WaterDepth) then
c-------------the assembly is above the water table
c
c-------------effective permeability to air
              kperm(rve) = k_a(LayerRVE(rve))
c
c-------------bulk density of soil
              rho_soil(rve) = rho_d(rve)
c
c-------------density of pore fluid
              rho_fluid(rve) = rho_a
c
c-------------the soil is above the water table. This soil will be treated
c             as dry soil
              lAbove(rve) = .true.
            else
c-------------the assembly is below the water table
c
c-------------effective permeability to water
              kperm(rve) = k_w(LayerRVE(rve))
c
c-------------the assembly is assumed to be saturated
              rho_soil(rve) = rho_s(rve)
c
c-------------density of pore fluid
              rho_fluid(rve) = rho_f(rve)
c
c-------------the soil is below the water table
              lAbove(rve) = .false.
            endif
  310     continue
c
c---------now, using the adjusted densities, compute the geostatic stresses
c         and the hydrostate pressures at the RVEs
c
c---------the integrated density at the ground surface
          if(WaterDepth.ge.0.) then
            Integ_rho_s_surface = 0.
            Integ_rho_f_surface = 0.
          else
            Integ_rho_s_surface = -WaterDepth * rho_w
            Integ_rho_f_surface = -WaterDepth * rho_w
          endif
c
c---------begin by finding the integrated densities at the top RVE
c---------the top RVE is midway between the surface and the node below it
          if(.not.lAbove(nRVEs)) then
c-----------the water table is above the top RVE
c
            if(WaterDepth.ge.0.) then
c-------------the water table is between the ground surface and the top RVE
              Integ_rho_s(nRVEs) = 
     x            rho_d(nRVEs)*WaterDepth
     x          + rho_soil(nRVEs)*(DepthRVE(nRVEs)-WaterDepth)
              Integ_rho_f(nRVEs) = 
     x            rho_a*WaterDepth 
     x          + rho_fluid(nRVEs)*(DepthRVE(nRVEs)-WaterDepth)
            else
c-------------the water table is above the ground surface
              Integ_rho_s(nRVEs) = 
     x          - rho_w*WaterDepth
     x          + rho_soil(nRVEs)*DepthRVE(nRVEs)
              Integ_rho_f(nRVEs) = 
     x          - rho_w*WaterDepth 
     x          + rho_fluid(nRVEs)*DepthRVE(nRVEs)
            endif
          else
c-----------the water table is below the top RVE
            Integ_rho_s(nRVEs) = rho_soil(nRVEs)*DepthRVE(nRVEs)
            Integ_rho_f(nRVEs) = rho_fluid(nRVEs)*DepthRVE(nRVEs)
          endif
c
c---------accumulate the integrated density from the next-to-top RVE to 
c         the bottom RVE
          do 320 rve = nRVEs-1,botrve,-1
            if(     (      lAbove(rve) 
     x               .and. lAbove(rve+1))
     x         .or. (      .not.lAbove(rve)
     x               .and. .not.lAbove(rve+1))) then
c-------------water table is not between the current RVE and the RVE above it
              if(LayerRVE(rve+1).eq.LayerRVE(rve)) then
c---------------both RVEs are in the same layer. Use the average of the
c               RVE's densities
                Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x            + 0.5d0*(rho_soil(rve) + rho_soil(rve+1))
     x                   *(DepthRVE(rve) - DepthRVE(rve+1))
c
                Integ_rho_f(rve) = Integ_rho_f(rve+1) 
     x                       + rho_fluid(rve)
     x                         *(DepthRVE(rve) - DepthRVE(rve+1))
              else
c---------------the RVEs are in different layers. Use the densities of the
c               respective layers
                Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x            + rho_soil(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                               - DepthRVE(rve+1))
     x            + rho_soil(rve)*(DepthRVE(rve)
     x                             - LayerBottom(LayerRVE(rve+1)))
c
                Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x            + rho_fluid(rve+1)
     x              *(LayerBottom(LayerRVE(rve+1))
     x                - DepthRVE(rve+1))
     x            + rho_fluid(rve)
     x              *(DepthRVE(rve)
     x                - LayerBottom(LayerRVE(rve+1)))
              endif
            else
c-------------the water table is between the current RVE and the RVE above it
              if(LayerRVE(rve+1).eq.LayerRVE(rve)) then
c---------------the two RVEs are in the same layer.  This means that the
c               upper RVE is dry (with the density that is dry):
c                 rve+1 / WT / rve
                Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x            + rho_soil(rve+1)*(WaterDepth -DepthRVE(rve+1))
     x            + rho_soil(rve)  *(DepthRVE(rve) - WaterDepth)
c
                Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x            + rho_fluid(rve+1)*(WaterDepth-DepthRVE(rve+1))
     x            + rho_fluid(rve)  *(DepthRVE(rve) - WaterDepth)
              elseif(WaterDepth.lt.LayerBottom(LayerRVE(rve+1))) then
c---------------the water table is above the layer interface:
c                  rve+1 / WT / Interface / rve
                Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x            + rho_d(rve+1)*(WaterDepth - DepthRVE(rve+1))
     x            + rho_s(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                            - WaterDepth)
     x            + rho_soil(rve)*(DepthRVE(rve) 
     x                             -LayerBottom(LayerRVE(rve+1)))
c
                Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x            + rho_a*(WaterDepth - DepthRVE(rve+1))
     x            + rho_f(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                            - WaterDepth)
     x            + rho_fluid(rve)*(DepthRVE(rve) 
     x                              - LayerBottom(LayerRVE(rve+1)))
              else
c---------------the water table is below the layer interface:
c                  rve+1 / Interface / WT / rve
                Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x            + rho_d(rve+1)*(LayerBottom(LayerRVE(rve+1)) 
     x                            - DepthRVE(rve+1))
     x            + rho_d(rve)*(WaterDepth
     x                          - LayerBottom(LayerRVE(rve+1)))
     x            + rho_soil(rve)*(DepthRVE(rve) - WaterDepth)
c
                Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x            + rho_a         *(LayerBottom(LayerRVE(rve+1)) 
     x                              - DepthRVE(rve+1))
     x            + rho_a         *(WaterDepth
     x                              - LayerBottom(LayerRVE(rve+1)))
     x            + rho_fluid(rve)*(DepthRVE(rve) - WaterDepth)
              endif
            endif
  320     continue
c
  300   continue
c
c-------use the integrated density to compute the hydrostatic pressure,
c       which is used to place a cap on the water pressure to prevent
c       pressure surges due to bubble collapse
        do 312 rve = botrve,nRVEs-topdif
          iLayer = LayerRVE(rve)
          if(iCap(iLayer).eq.1) then
            pCap(rve) = grav*Integ_rho_s(rve) + xCap(iLayer)
            jCap(rve) = 1
          else
            pCap(rve) = 0.
            jCap(rve) = 0
          endif
  312   continue
c
c-------print message to screen
        print *,'  Finding stiffness moduli'
c
c-------in the next loop, we determine the stiffness moduli (the p-wave
c       and s-wave moduli), so that we can later find the time step for
c       the finite-difference wave equation algorithm.  when iRunRVEModuli=0
c       for the layer, then these moduli have already been computed and
c       can be retrieved from a file.  Othewise, we must run DEM simulations
c       to find the moduli
c
c-------this loop can be parallelized
!$OMP   PARALLEL DO SCHEDULE(STATIC)
!$OMP+              PRIVATE(rve, iLayer, lcont)
        do 110 rve = botrve,nRVEs-topdif
c---------the stratigraphic layer within which the RVE lies
          iLayer = LayerRVE(rve)
c
          if(iRunRVEModuli(iLayer).ne.0) then
c-----------when iRunRVEModuli=1 in the Layer file, then we must run a DEM
c           simulation to find the stiffness moduli, so that we can estimate
c           the wave speed and an appropriate wave-equation time-step.
c           When iRunRVEModuli=0, then this has already been done, and we
c           will read the moduli from a file, thus saving a lot of compute
c           time
c
c-----------convert the RVE and Layer numbers to strings
            call int2str4(rve,strRVE(rve))
            call int2str4(iLayer,strLayer(rve))
c
c-----------print message to screen
            print *,'  READING the C-file input for RVE '//
     x              strRVE(rve)//
     x              ' in Layer '//
     x              strLayer(rve)//
     x              '...'
c
c-----------the StartFile that was placed in the "03_RVESetup" folder
            filenameC(rve) = 'C'//
     x                       MainDir(1:LEN_TRIM(MainDir))//
     x                       '_RVE_'//
     x                       strRVE(rve)
c
c-----------force subroutin readit2 to read a C-type StartFile
            istartchng = 3
c
c-----------read both the RunFile and the StartFile
            extent = 0
c
c-----------the following code is "critical" and can only be executed by
c           a single thread, as other RVEs wait for a thread to become
c           available.  Without being critical, I found that errors occur
c           when multiple thread are reading files
!$OMP       CRITICAL
c-----------read the RunFile and StartFile for this soil layer,
c           which will be used for creating the initial assemblies
c           for each of the RVEs within the layer
            filename3 = RunFilePath(iLayer)
            filename4 = InputCfileDir(1:LEN_TRIM(InputCfileDir))//
     x                    filenameC(rve)(1:LEN_TRIM(filenameC(rve)))
c
            call readit2(rve,istartchng,filename3,filename4,extent)
!$OMP       END CRITICAL
c
c-----------the name of the output file, as if it were a RunFile
            OutputRunFile(rve) = MainDir(1:LEN_TRIM(MainDir))//
     x                           '_Moduli_RVE_'//
     x                           strRVE(rve)//
     x                           '_Layer_'//
     x                           strLayer(rve)
c
c-----------initialize files for recording error messages and screen output.
c           Assign unit numbers to the various output files
            call initFilesRS(
     x             rve,
     x             OutputDir2,
     x             OutputRunFile(rve),
     x             filenameC(rve),
     x             ErrUnit(rve),
     x             mdim1,mp,mpiece,version,ScrUnit(rve),
     x             lScreen)
c
!$OMP       CRITICAL
c-----------initialize general parameters, particle properties, ect.
            call init(rve)
!$OMP       END CRITICAL
c
c-----------the following code is "critical" and can only be entered by a
c           single thread.  I found that errors occur when multiple threads
c           are running this code.  I don't know why, but there might be
c           a subtle error within subroutin lister
!$OMP       CRITICAL
c-----------create the linked list of near-neighbors
            nnnear(rve) = mnear
            nlist(rve) = mlist
            nlist2(rve) = mlist2
            nlist3(rve) = mlist3
            nboxs(rve) = mboxes
            call lister(rve,nnnear(rve),
     x            nlist(rve),nlist2(rve),
     x            nlist3(rve),
     x            nboxs(rve))
!$OMP       END CRITICAL
c
c-----------initialize the A and B files
            call initFilesAB(
     x        rve,
     x        OutputDir2,
     x        OutputRunFile(rve),
     x        filenameC(rve),
     x        ndim1,iheat(rve),hmodel(rve),
     x        lout,lporo(rve),mfiles,iporo(rve),
     x        version, partyp(rve), np(rve), 
     x        ravg(rve),
     x        voidn(rve),
     x        lHertz(rve),
     x        lJager(rve),lJagr2(rve),
     x        lJagr3(rve),
     x        lJagr4(rve),
     x        AUnit(rve),BUnit(rve),
     x        itxt(rve),Bversn)
c
c-----------print message to screen
            print *,'  Running DEM to quiesce 1 the RVE '//
     x              strRVE(rve)//
     x              ' in Layer '//
     x              strLayer(rve)//
     x              '...'
c
c-----------step in the sequence of stress-strain control
            iStage(rve) = 1
c
c-----------assign control parameters for the quiesent-moduli period.
c           In OVAL, these parameters are input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------with the first run, let the assembly quiesce with constant
c           stresses
            if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
c-------------level ground and level water surface
              icontr(iStage(rve),rve) = 001000
            else
c-------------sloping ground or water surface
              icontr(iStage(rve),rve) = 001011
            endif
c
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 200.d0
c
c-----------reset the current constrol step to zero
            istep(rve) = 0
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 1
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------whether to continue from a previous run (as when a restart 
c           "C" file is used to start a run)
            lcont = .true.
c
c-----------print output of the initial conditions
            lfirst = .true.
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
            print *,'  Running DEM to find stiffness of RVE '//
     x              strRVE(rve)//
     x              ' in Layer '//
     x              strLayer(rve)//
     x              '...'
c
c-----------now, run a DEM simulation with this RVE to determine the uniaxial
c           compression modulus and the shear modulus of the soil skeleton 
c           (i.e. drained stiffnesses)
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for vertical undrained constrained compression.
c           In OVAL, these parameters are input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = -50.d0
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters.  Control the 33 effective stress;
c           control the five remaining strain components
            icontr(iStage(rve),rve) = 001000
            if(lAbove(rve)) then
c-------------treat soil above water table as dry soil. Find drained modulus
              icontp(iStage(rve),rve) = 1
            else
c-------------treat soil above water table as wet. Find undrained modulus
              icontp(iStage(rve),rve) = 0
            endif
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for vertical undrained constrained extension.
c           In OVAL, these parameters are input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 50.d0
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters.  Control the 33 effective stress;
c           control the five remaining strain components
            icontr(iStage(rve),rve) = 001000
            if(lAbove(rve)) then
c-------------treat soil above water table as dry soil. Find drained modulus
              icontp(iStage(rve),rve) = 1
            else
c-------------treat soil above water table as wet. Find undrained modulus
              icontp(iStage(rve),rve) = 0
            endif
c-----------control the number of dem time steps
            igoal(iStage(rve),rve) = 70
c-----------the number of dem time steps
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for drained horizontal shear, loading.
c           In OVAL, these parameters are input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 50.d0
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters.  Control 33 and 23 stresses. Control
c           the remaining four strain components
            icontr(iStage(rve),rve) = 001010
c-----------drained loading
            icontp(iStage(rve),rve) = 1
c-----------run for a given number of dem time steps
            igoal(iStage(rve),rve) = 70
c-----------number of dem time steps
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for drained horizontal shear, unloading.
c           In OVAL, these parameters are input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = -50.d0
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters
            icontr(iStage(rve),rve) = 001010
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for fluid inflow: find the bulk modulus
c           of the pore fluid by increasing the fluid pressure with
c           drained conditions.
c           In OVAL, these parameters would be input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = 50.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters. Control all strain components (all zero)
            icontr(iStage(rve),rve) = 000000
c-----------drained loading
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for fluid inflow. Undo the fluid pressure
c           increase of the previous step
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = 0.
            defrat(8,iStage(rve),rve) = -50.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters
            icontr(iStage(rve),rve) = 000000
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 50.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------these are the control parameters that will be used for a trial
c           shear loading at a controlled shear strain rate.  We do this to
c           capture performance parameters that will be used to adjust the
c           DEM strain increment when we are simulating dynamic loading.
c           Although this adjustment is, at the moment, experimental,
c           if we do invoke this adjustment, we would use the data collected
c           with this trial loadings to reduce the DEM strain increment
c           when the effective stress becomes very low.  We will use the
c           parameters that are caputred in this controlled loading to find
c           a reference intertial number, force imbalance parameter, etc.
c
c           In OVAL, these parameters would be input within the RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = ddef_target
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters. Control all strain components (all zero)
            icontr(iStage(rve),rve) = 001000
c-----------drained loading
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 200.d0
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------control parameters for fluid inflow. Undo the fluid pressure
c           increase of the previous step
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(3,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
            defrat(5,iStage(rve),rve) = 0.
            defrat(6,iStage(rve),rve) = -ddef_target
            defrat(8,iStage(rve),rve) = 0.
            ipts(iStage(rve),rve) = 20
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters
            icontr(iStage(rve),rve) = 001000
            icontp(iStage(rve),rve) = 1
            igoal(iStage(rve),rve) = 70
            finalv(iStage(rve),rve) = 200.d0
c
c-----------whether to continue from a previous run (as when a restart 
c           "C" file is used to start a run)
            lcont = .true.
c
c-----------do not print output of the initial conditions
            lfirst = .false.
c
c-----------reset the current constrol step to zero
            istep(rve) = 1
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 2
c
c-----------the initial vertical strain and total stress for computing the 
c           constrained undrained (P-wave) modulus of the soil skeleton
            vdef_sav(0,rve) = def(3,3,rve)
            vstress_sav(0,rve) = stress(3,3,rve) - pfluid(rve)
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the vertical strain and total stress after loading for computing 
c           the constrained undrained (P-wave) modulus of the soil skeleton
            vdef_sav(1,rve) = def(3,3,rve)
            vstress_sav(1,rve) = stress(3,3,rve) - pfluid(rve)
c
c-----------reset the current constrol step to zero
            istep(rve) = 2
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 3
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the vertical strain and total stress after unloading for computing 
c           the constrained undrained (P-wave) modulus of the soil skeleton
            vdef_sav(2,rve) = def(3,3,rve)
            vstress_sav(2,rve) = stress(3,3,rve) - pfluid(rve)
c
c-----------the constrained undrained (P-wave) modulus for loading and unloading
            M_h_1(rve) =   (vstress_sav(1,rve) - vstress_sav(0,rve))
     x                   / (vdef_sav(1,rve) - vdef_sav(0,rve))
            M_h_2(rve) =   (vstress_sav(2,rve) - vstress_sav(1,rve))
     x                   / (vdef_sav(2,rve) - vdef_sav(1,rve))
c
c-----------reset the current constrol step to zero
            istep(rve) = 3
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 4
c
c-----------the initial horizontal strain and effective stress for computing 
c           the drained shear modulus of the soil skeleton
            hdef_sav(0,rve) = def(1,3,rve)
            hstress_sav(0,rve) = stress(1,3,rve)
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the horizontal strain and effective stress after loading for
c           computing the drained shear modulus of the soil skeleton
            hdef_sav(1,rve) = def(1,3,rve)
            hstress_sav(1,rve) = stress(1,3,rve)
c
c-----------reset the current constrol step to zero
            istep(rve) = 4
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 5
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the horizontal strain and effective stress after unloading for
c           computing the drained shear modulus of the soil skeleton
            hdef_sav(2,rve) = def(1,3,rve)
            hstress_sav(2,rve) = stress(1,3,rve)
c
c-----------the drained shear (S-wave) modulus for loading and unloading
            G_h_1(rve) =   (hstress_sav(1,rve) - hstress_sav(0,rve))
     x                   / (hdef_sav(1,rve) - hdef_sav(0,rve))
            G_h_2(rve) =   (hstress_sav(2,rve) - hstress_sav(1,rve))
     x                   / (hdef_sav(2,rve) - hdef_sav(1,rve))
c
c-----------reset the current constrol step to zero
            istep(rve) = 5
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 6
c
c-----------the initial horizontal strain and effective stress for computing 
c           the drained shear modulus of the soil skeleton
            wdef_sav(0,rve) = defw(rve)
            wstress_sav(0,rve) = pfluid(rve)
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the horizontal strain and effective stress after loading for
c           computing the drained shear modulus of the soil skeleton
            wdef_sav(1,rve) = defw(rve)
            wstress_sav(1,rve) = pfluid(rve)
c
c-----------reset the current constrol step to zero
            istep(rve) = 6
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 7
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------the horizontal strain and effective stress after unloading for
c           computing the drained shear modulus of the soil skeleton
            wdef_sav(2,rve) = defw(rve)
            wstress_sav(2,rve) = pfluid(rve)
c
c-----------the drained shear (S-wave) modulus for loading and unloading
            K_w_1(rve) =   (wstress_sav(1,rve) - wstress_sav(0,rve))
     x                   / (wdef_sav(1,rve) - wdef_sav(0,rve))
            K_w_2(rve) =   (wstress_sav(2,rve) - wstress_sav(1,rve))
     x                   / (wdef_sav(2,rve) - wdef_sav(1,rve))
c
c-----------we now run a trial shear loading at a controlled shear strain
c           rate.  We do this to capture performance parameters that will be 
c           used to adjust the DEM strain increment when we are simulating
c           dynamic loading.
c           Although this adjustment is, at the moment, experimental,
c           if we do invoke this adjustment, we would use the data collected
c           with this trial loadings to reduce the DEM strain increment
c           when the effective stress becomes very low.  We will use the
c           parameters that are caputred in this controlled loading to find
c           a reference intertial number, force imbalance parameter, etc.
c
c-----------reset the current constrol step to zero
            istep(rve) = 7
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 8
c
c-----------initialize data to be collected during DEM run
            ldat(rve) = .true.
            ndat(rve) = 0
            ovrdat(rve) = 0.
            kmdat(rve) = 0.
            chidat(rve) = 0.
            pdat(rve) = 0.
            massdat(rve) = 0.
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------average the data here
            ldat(rve) = .false.
            ovrdat(rve) = ovrdat(rve) / ndat(rve)
            kmdat(rve) = kmdat(rve) / ndat(rve)
            chidat(rve) = chidat(rve) / ndat(rve)
            pdat(rve) = pdat(rve) / ndat(rve)
            massdat(rve) = massdat(rve) / ndat(rve)
            ndat(rve) = 0
c
c-----------reset the current constrol step to zero
            istep(rve) = 8
c
c-----------the control step that is reported in the screen output
            istep2(rve) = istep(rve)
c
c-----------the last control step of this DEM runstage
            istepm(rve) = 9
c
c-----------the DEM algorithm
            call dem(rve,lcont,OutputDir2,OutputRunFile(rve),lfirst)
c
c-----------collect data here
c
c-----------close all output files
            call closem(lout, lScreen, 
     x             AUnit(rve), BUnit(rve), ErrUnit(rve), ScrUnit(rve),
     x             mfiles)
c
c-----------open a "Mod" file (which can be new or might already exist)
c           and write the information about the moduli of this RVE
!$OMP       CRITICAL
            open(unit=0, 
     x           access='append',
     x           file=MainDir(1:LEN_TRIM(MainDir))//
     x           '/03_RVESetup/'//
     x           'Mod_'//
     x           MainDir(1:LEN_TRIM(MainDir))//
     x           '_Layer_'//
     x           strLayer(rve)//
     x           '.txt')
c
            write(0,910) iLayer, 
     x                   rve, 
     x                   G_h_1(rve),
     x                   G_h_2(rve),
     x                   M_h_1(rve),
     x                   M_h_2(rve),
     x                   K_w_1(rve),
     x                   K_w_2(rve),
     x                   ovrdat(rve),
     x                   kmdat(rve),
     x                   chidat(rve),
     x                   pdat(rve),
     x                   massdat(rve)
  910       format(i5, i5, 11(1pe11.3))
            close(unit=0)
!$OMP       END CRITICAL
          else
c-----------the DEM simulations have already been run for finding the
c           RVE stiffness moduli of this layer.  These moduli have been
c           stored in a "Mod" file.  We will open the file and then look
c           for the particular RVE in the file
!$OMP       CRITICAL
            open(unit=1, 
     x           status='old',
     x           file=MainDir(1:LEN_TRIM(MainDir))//
     x           '/03_RVESetup/'//
     x           'Mod_'//
     x           MainDir(1:LEN_TRIM(MainDir))//
     x           '_Layer_'//
     x           strLayer(rve)//
     x           '.txt')
c
c-----------read the entire file of moduli.  Note that the file is created
c           in apend mode, so an RVE can have several entries in the file,
c           as entries are added with run of dempla
            nmods = 1
  105         read(1,*,end=107) iLayer_sav(nmods), 
     x                          rve_sav(nmods), 
     x                          G_h_1_sav(nmods),
     x                          G_h_2_sav(nmods),
     x                          M_h_1_sav(nmods),
     x                          M_h_2_sav(nmods),
     x                          K_w_1_sav(nmods),
     x                          K_w_2_sav(nmods),
     x                          ovrdat_sav(nmods),
     x                          kmdat_sav(nmods),
     x                          chidat_sav(nmods),
     x                          pdat_sav(nmods),
     x                          massdat_sav(nmods)
              nmods = nmods + 1
c
c-------------check whether nmods exceed the size of the 'sav' arrays
              if(nmods.gt.modsav) then
                print *,'  Oops!!  The value of nmods exceeds modsav '//
     x                  'in subroutin pla'
                print *,'  That is, too many rows of moduli have been'//
     x                  ' added to the Mod_* file in folder 03_RVESetup'
                print *,'  Try removing the Mod_* file, then rerun '//
     x                  'dempla with iRunRVEModuli=1 in the L-file, '//
     x                  ' and then make future runs with '//
     x                  'iRunRVEModuli=0.  Not that with '//
     x                  'iRunRVEModuli=1, new lines will be appended'//
     x                  ' to the Mod_* file with each dempla run '//
     x                  'until the Mod_* file fills again'
                print *, '  Alternatively, increase modsav in the '//
     x                   'param file, recompile, and rerun dempla'
                stop
              endif
              goto 105
  107       close(unit=1)
            nmods = nmods - 1
c
c-----------search for the moduli of this RVE.  Scan the file backward,
c           so that the most recent moduli are extracted
            do 120 imod = nmods,1,-1
              if(iLayer_sav(imod).eq.iLayer 
     x           .and. rve_sav(imod).eq.rve) then
                G_h_1(rve) = G_h_1_sav(imod)
                G_h_2(rve) = G_h_2_sav(imod)
                M_h_1(rve) = M_h_1_sav(imod)
                M_h_2(rve) = M_h_2_sav(imod)
                K_w_1(rve) = K_w_1_sav(imod)
                K_w_2(rve) = K_w_2_sav(imod)
                ovrdat(rve) =  ovrdat_sav(imod)
                kmdat(rve) =   kmdat_sav(imod)
                chidat(rve) =  chidat_sav(imod)
                pdat(rve) =    pdat_sav(imod)
                massdat(rve) = massdat_sav(imod)
                goto 122
              endif
  120       continue
  122       continue
!$OMP       END CRITICAL
          endif
c
c---------the constrained modulus used in computing the propagation time step
          M_h(rve) = max(M_h_1(rve), M_h_2(rve))
c
c---------the shear modulus used in computing the propagation time step
          G_h(rve) = max(G_h_1(rve), G_h_2(rve))
  110   continue
!$OMP   END PARALLEL DO
c
c-------print message to screen
        print *,'  Finished finding the initial RVE moduli'
c
c-------the wave velocity used to compute the propagation time step
        v_max = 0.
c
        do 140 rve = botrve,nRVEs-topdif
c---------the larger of the P and S wave moduli of this RVE assembly
          modulus_RVE = max(G_h(rve), M_h(rve))
c
c---------the larger wave velocity of this RVE assembly
          v_RVE = sqrt(modulus_RVE / rho_soil(rve))
c
c---------the largest velocity among the RVE assemblies
          v_max = max(v_max, v_RVE)
c
c---------Courant number
          Courant = 0.75d0;
c
c---------the effective Courant number
          Cnumber = Courant * C_factor
c
c---------the time step to be used in the wave propagation analysis
          dt_ref = Cnumber * dx_rve / v_max
  140   continue
c
c-------read the file with the input rock motion.  The first line contains
c       the time increment of the motion.  Three columns separated with 
c       spaces: vertical (x1) displacement, horizontal (x2) displacement,
c       horizontal (x3) displacement. Each of these rows are the displacement
c       at a time, and the rows are for equally spaced times.  The first 
c       motion line should be three zeros.
        call ReadMfile
c
c-------the number of time steps to be used for completing the input
c       rock motion
        nSteps_rve = nRock*dtRock / dt_ref
        write(*,900) nSteps_rve, dt_ref
  900   format(
     x    '   Number of steps of rock motion to complete the full',
     x    ' motion:',i9,' at dt_ref = ',1pe11.4,/)
c
c-------vector of times, separated by the Dempla time increment
        do 150 i4 = 0,nRock
          tRock(i4) = i4*dtRock
  150   continue
c
c-------re-read the RVE C-file (thus ignoring the previous stiffness test)
c       as the starting condition for the rock motion
c
c-------do not display the run output details on the screen, but write
c       the details to files
        lScreen = .false.
c
c-------whether to create A and B files during the dempla run
        lABfile = iABfile.ne.0
c
c-------no body forces and no rigid platens (periodic boundaries will be used)
        lbodyf = .false.
        lplatn = .false.
c
        do 160 rve = botrve,nRVEs-topdif
c---------reading the C-files and doing setup for the DEM runs 
c
c---------the stratigraphic layer within which the RVE lies
          iLayer = LayerRVE(rve)
c
c---------convert the RVE and Layer numbers to strings
          call int2str4(rve,strRVE(rve))
          call int2str4(iLayer,strLayer(rve))
c
          print *,'  Reading the C-file input for RVE '//
     x            strRVE(rve)//
     x            ' in Layer '//
     x            strLayer(rve)//
     x            '...'
c
c---------the StartFile that was placed in the "03_RVESetup" folder
          filenameC(rve) = 'C'//
     x                     MainDir(1:LEN_TRIM(MainDir))//
     x                     '_RVE_'//
     x                     strRVE(rve)
c
c---------the name of the output file, as if it were a RunFile
          OutputRunFile(rve) = MainDir(1:LEN_TRIM(MainDir))//
     x                         cVar(1:LEN_TRIM(cVar))//
     x                         '_Dempla_RVE_'//
     x                         strRVE(rve)//
     x                        '_'//
     x                        RockMotionFile(1:LEN_TRIM(RockMotionFile))
c
c---------initialize files for recording error messages and screen output.
c         Assign unit numbers to the various output files
          call initFilesRS(
     x           rve,
     x           OutputDir,
     x           OutputRunFile(rve),
     x           filenameC(rve),
     x           ErrUnit(rve),
     x           mdim1,mp,mpiece,version,ScrUnit(rve),
     x           lScreen)
c
c---------force subroutin readit2 to read a C-type StartFile
          istartchng = 3
c
c---------read both the RunFile and the StartFile
          extent = 0
c
c---------read the RunFile and StartFile for this soil layer,
c         which will be used for creating the initial assemblies
c         for each of the RVEs within the layer
!$OMP     CRITICAL
          filename3 = RunFilePath(iLayer)
          filename4 = InputCfileDir(1:LEN_TRIM(InputCfileDir))//
     x                  filenameC(rve)(1:LEN_TRIM(filenameC(rve)))
c
          call readit2(rve,istartchng, filename3, filename4, extent)
!$OMP     END CRITICAL
c
c---------initialize general parameters, particle properties, ect.
          call init(rve)
c
c---------create the linked list of near-neighbors
!$OMP     CRITICAL
          nnnear(rve) = mnear
          nlist(rve) = mlist
          nlist2(rve) = mlist2
          nlist3(rve) = mlist3
          nboxs(rve) = mboxes
          call lister(rve,nnnear(rve),
     x          nlist(rve),nlist2(rve),
     x          nlist3(rve),
     x          nboxs(rve))
!$OMP     END CRITICAL
c
          if(lABfile) then
c-----------initialize the A and B files
            call initFilesAB(
     x        rve,
     x        OutputDir,
     x        OutputRunFile(rve),
     x        filenameC(rve),
     x        ndim1,iheat(rve),hmodel(rve),
     x        lout,lporo(rve),mfiles,iporo(rve),
     x        version, partyp(rve), np(rve), 
     x        ravg(rve),
     x        voidn(rve),
     x        lHertz(rve),
     x        lJager(rve),lJagr2(rve),
     x        lJagr3(rve),
     x        lJagr4(rve),
     x        AUnit(rve),BUnit(rve),
     x        itxt(rve),Bversn)
          endif
c
c---------create a pseudo-RunFile that will record the input data
c         for this DEM run
          call WriteInput1(rve,OutputDir,OutputRunFile(rve))
c
  160   continue
c
        print *,' '
c
c-------small number
        epsv = 1d-10
c
c-------run DEM for the initial quiescent period before begining the
c       DEMPLA algorithm
!$OMP   PARALLEL DO SCHEDULE(STATIC)
!$OMP+              PRIVATE(rve, J_f, J_w, lcont)
        do 162 rve = botrve,nRVEs-topdif
c
c---------print message to screen
          print *,'  Running DEM to quiesce 2 the RVE '//
     x            strRVE(rve)//
     x            ' in Layer '//
     x            strLayer(rve)//
     x            '...'
c
          if(lSat(LayerRVE(rve)).ne.0 .and. S_o(rve).gt.1.d0-epsv
     x       .and. iporo(rve).eq.3 .and. .not.lAbove(rve)) then
c-----------special approach to handling saturated soil, so that
c           the pore fluid can cavitate with the water pressure is
c           reduced to a treshold level.  This requires that we now reset
c           the value of p_wcav, which requires that we reset the
c           initial values of various parameters from the the values
c           that were originally given in the RunFile for the layer.
c           Note that cavitation is disallowed unless the following aspects
c           are included in the layer RunFile:  iporo=3, S_o=1.0,
c           N_o is non-zero, and Hcc is non-zero
c
c-----------reference stress at the start of the simulation
            stres0(1,1,rve) = stress(1,1,rve)
            stres0(2,2,rve) = stress(2,2,rve)
            stres0(3,3,rve) = stress(3,3,rve)
c
c-----------reference porosity at the start of the simulation
            poros0(rve) = porosn(rve)
c
c-----------Jacobian of the bulk deformation gradient
            J_fo(rve) = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c-----------reference water influx value.  This is being reset so that the
c           value of 1 - J_f + poros0*defw = 0 in the calculation of pfluid
            defw(rve) = -(1.d0 - J_fo(rve)) / poros0(rve)
c
c-----------reference water pressure
            p_o(rve) = pfluid(rve)
c
c-----------the cavitation pressure
            if(lSat(LayerRVE(rve)).eq.1) then
c-------------the cavitation water pressure (relative to atmospheric pressure)
c             is equal to the water pressure minus xSat (given in the L-file)
              p_wcav(rve) = p_o(rve) - xSat(LayerRVE(rve))
c
              if(p_wcav(rve).lt. -p_atm(rve)) then
c---------------cavitation pressure must be no smaller than zero absolute
                p_wcav(rve) = -p_atm(rve)
              endif
            elseif(lSat(LayerRVE(rve)).eq.2) then
c-------------the cavitation water pressure (relative to atmospheric pressure)
c             is equal to the water pressure times xSat (given in the L-file)
              p_wcav(rve) = 
     x          (p_o(rve) + p_atm(rve)) * xSat(LayerRVE(rve))
     x          - p_atm(rve)
            endif
          elseif(lAbove(rve)) then
c-----------treat soil above the water table with a different poroelastic
c           model.  We assume that this soil is dry (S_o = S_now = 0)
c
c-----------use the model for dry soil.
            iporo(rve) = 4
c-----------model poroelastic effects
            lporo(rve) = .true.
c
c-----------we assume that the soil above the water table has no water
            S_now(rve) = 0.
c
c-----------we must reset the net influx, "defw", so that it is consistent
c           with the current and original air pressures, porosities, and
c           effective stresses.  
c
c-----------Jacobian of the skeleton deformation gradient
            J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c-----------Jacobian of the fluid deformation gradient
            J_w = (p_o(rve) + p_atm(rve)) / (pfluid(rve) + p_atm(rve))
     x            * (1.d0
     x               - (1.d0 - poros0(rve))
     x                 * ( (  (  stress(1,1,rve) + stress(2,2,rve)
     x                         + stress(3,3,rve))
     x                      - (stres0(1,1,rve) + stres0(2,2,rve)
     x                         + stres0(3,3,rve)))
     x                     / (3.d0*K_s(rve))
     x                      - (pfluid(rve) - p_o(rve)) / K_s(rve)
     x                   )
     x              )
c
c-----------net influx of air
            defw(rve) = J_f - J_w
          endif
c
c---------step in the sequence of stress-strain control
          iStage(rve) = 1
c
c---------keep a second counting, in the event that we surpass lc1
          iStage2(rve) = 1
c
c---------assign control parameters for the initial quiesent period.
c         In OVAL, these parameters are input within the RunFile
          defrat(1,iStage(rve),rve) = 0.
          defrat(2,iStage(rve),rve) = 0.
          defrat(3,iStage(rve),rve) = 0.
          defrat(4,iStage(rve),rve) = 0.
          defrat(5,iStage(rve),rve) = 0.
          defrat(6,iStage(rve),rve) = 0.
          defrat(8,iStage(rve),rve) = 0.
          ipts(iStage(rve),rve) = 20
          idump(iStage(rve),rve) = 0
          imicro(iStage(rve),rve) = 0
          defdot(iStage(rve),rve) = 0.
          ipts2(iStage(rve),rve) = 0
          iplot(iStage(rve),rve) = 0
          vrate(iStage(rve),rve) = 0.
c
c---------with the first run, let the assembly quiesce with constant
c         33 stress
          if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
c-----------level ground and level water surface
            icontr(iStage(rve),rve) = 001000
          else
c-----------sloping ground or water surface
            icontr(iStage(rve),rve) = 001011
          endif
c
          icontp(iStage(rve),rve) = 1
          igoal(iStage(rve),rve) = 70
          finalv(iStage(rve),rve) = 200.d0
c
c---------reset the current constrol step to zero
          istep(rve) = 0
c
c---------the control step that is reported in the screen output
          istep2(rve) = istep(rve)
c
c---------the last control step of this DEM runstage
          istepm(rve) = 1
c
c---------write the control step information to the pseudo-RunFile
c         that will record the loading steps of the RVE assembly
          call WriteInput2(rve,iStage(rve),
     x                     OutputDir,OutputRunFile(rve))
c
c---------whether to continue from a previous run (as when a restart 
c         "C" file is used to start a run)
          lcont = .true.
c
c---------print output of the initial conditions
          lfirst = .true.
c
c---------the DEM algorithm
          call dem(rve,lcont,OutputDir,OutputRunFile(rve),lfirst)
c
c---------capture the initial stresses. For example, the horizontal
c         shearing stress will not be exactly zero, even though the
c         assembly was consolidated under nearly ideal conditions.
c         The subsequent Dempla algorithm will measure stress relative
c         to these initial conditions
          stressRVEo(rve,1,1) = stress(1,1,rve)
          stressRVEo(rve,1,2) = stress(1,2,rve)
          stressRVEo(rve,1,3) = stress(1,3,rve)
          stressRVEo(rve,2,2) = stress(2,2,rve)
          stressRVEo(rve,2,3) = stress(2,3,rve)
          stressRVEo(rve,3,3) = stress(3,3,rve)
          pfluidRVEo(rve) = pfluid(rve)
  162   continue
!$OMP   END PARALLEL DO
c
        print *,' '
        write(*,900) nSteps_rve
        print *,' '
c
c-------initialize the displacements at the nodes
        do 164 node = 0,nRVEs
c---------soil matrix displacement at node
          uNode(node,1) = 0.
          uNode(node,2) = 0.
          uNode(node,3) = 0.
c
c---------pore fluid displacement at node
          wNode(node) = 0.
c
c---------soil matrix incremental displacement at node
          duNode(node,1) = 0.
          duNode(node,2) = 0.
          duNode(node,3) = 0.
c
c---------pore fluid incremental displacement at node
          dwNode(node) = 0.
  164   continue
c
c-------the initial total stress and fluid pressure.  These values are
c       assigned here so that they can be printed to output files as the
c       initial values
        do 166 rve = botrve,nRVEs
c
c---------geostatic total stresses in directions 1, 2, 3 
c         (stresses 13, 23, and 33).  Note that we have integrated downward, 
c         so a change in sign.  With the shearing stresses, we add the stress
c         due to seepage forces
          Total_stress_rve(rve,1) = -grav*(  cosin_s(1)*Integ_rho_s(rve)
     x                                    - cosin_w(1)*Integ_rho_f(rve))
          Total_stress_rve(rve,2) = -grav*(  cosin_s(2)*Integ_rho_s(rve)
     x                                    - cosin_w(2)*Integ_rho_f(rve))
          Total_stress_rve(rve,3) = -grav*cosin_s(3)*Integ_rho_s(rve)
c
c---------fluid pressure
          p_ref_rve(rve) = grav*cosin_s(3)*Integ_rho_f(rve)
c
c---------the stratigraphic layer in which the rve lies
          iLayer = LayerRVE(rve)
c
c---------porosity of the rve's.  This porosity is based upon the reference
c         Porosity in the L-file (when this input value is < 0, then
c         we use the porosity of the dem assembly).  This reference porosity
c         is assumed as the state of the soil after the initial dem run
c         of the L-files, but before the rve's were consolidated at their
c         various depths.  Note that this reference porosity changes
c         when the rve's are consolidated at the various depths within the
c         layer.
c
c---------the assumed initial porosity of the RVE
          Porosity(rve) = lPorosity(LayerRVE(rve))
c
c---------the assumed initial void ratio of the assembly
          voidno(rve) = VoidRatio(LayerRVE(rve))
c
c---------the actual initial void ratio of the assembly
c         voidna(rve) = (vcello(rve) - vso(rve))/vso(rve)
c
c---------the void ratio of the RVE, based upon the assumed and
c         actual initial void ratios (voidno and voidna) and the 
c         current void ratio
          voidnb(rve) = voidno(rve)
     x                  - (lvoidno(iLayer) - voidn(rve))
     x                    * (1.d0 + voidno(rve))
     x                    / (1.d0 + lvoidno(iLayer))
c
c---------revise the Porosity
          Porosity(rve) = voidnb(rve) / (1.d0 + voidnb(rve))
  166   continue
c
c-------these values at node 0 are not used in calculations, but are only
c       given here as placeholders
        rho_soil_avg(0) = 0.
        rho_fluid_avg(0) = 0.
        Porosity_avg(0) = 0.
        kperm_avg(0) = 0.
        S_avg(0) = 0.
c
c-------soil and pore fluid densities at the nodes, which are approximated
c       from the integrated densities.  This will give an average
c       density that is consistent with the the stress and pressure gradients
        do 168 node = 1,nRVEs-1
c---------use a central difference of the total density and fluid density
c         of the RVEs above and below
          rho_soil_avg(node) = 
     x      -(Integ_rho_s(node+1) - Integ_rho_s(node))
     x      / (xNode(node+1,3) - xNode(node,3))
          rho_fluid_avg(node) = 
     x      -(Integ_rho_f(node+1) - Integ_rho_f(node))
     x      / (xNode(node+1,3) - xNode(node,3))
c
c---------the porosity, permeability,and saturation at the node is the
c         average of the RVEs above and below the node
          Porosity_avg(node) = 
     x      0.5d0*(Porosity(node+1) + Porosity(node))
          kperm_avg(node) = 
     x      0.5d0*(kperm(node+1) + kperm(node))
          S_avg(node) = 
     x      0.5d0*(S_now(node+1) + S_now(node))
  168   continue
c
c-------scaling factor for time during consolidation
        rms_grad_factor = 1.d0
c
c-------the soil and fluid densisties of soil at the ground surface
        rho_soil_avg(nRVEs) = 
     x                      (Integ_rho_s(nRVEs) - Integ_rho_s_surface)
     x                      / ((xNode(nRVEs,3) - xNode(nRVEs-1,3)) 
     x                         / 2.d0) 
        rho_fluid_avg(nRVEs) = 
     x                       (Integ_rho_f(nRVEs) - Integ_rho_f_surface)
     x                       / ((xNode(nRVEs,3) - xNode(nRVEs-1,3))
     x                          / 2.d0) 
c
        Porosity_avg(nRVEs) = Porosity(nRVEs)
        kperm_avg(nRVEs) = kperm(nRVEs)
        S_avg(nRVEs) = S_now(nRVEs)
c
c-------set up the output files for recording the results of the Dempla
c       simulation.  Each of the following files will begin with a single
c       line that gives the integer number of RVEs.  The 2nd and 3rd lines
c       give the Dempla time-step "dt_ref" and the thickness of a Dempla
c       element (the distance between nodes or between the RVEs). In these
c       files, the rest of the file is a sequence of lines, with each 
c       line being the result of a single Dempla time-step.  Each file
c       gives a different type of result:
c         Results_ ...
c         u_1 = vertical   displacement of the nRVEs+1 nodes (soil skeleton)
c         u_2 = horizontal displacement of the nRVEs+1 nodes (soil skeleton)
c         u_3 = horizontal displacement of the nRVEs+1 nodes (soil skeleton)
c         s_1 = vertical normal effective stress of the the nRVEs assemblies
c         s_2 = horizontal shearing stress of the the nRVEs assemblies
c         s_3 = horizontal shearing stress of the the nRVEs assemblies
c         p =   pressure liquid phase of the pore fluid of the nRVEs+1 nodes
c         w =   vertical displacement of the pore fluid of the nRVEs assemblies
c               relative to the soil skeleton of the nRVEs+1 nodes
c         rho_soil  = total soil density
c         rho_fluid = fluid density
c         Porosity  = soil porosity
c         kperm     = soil permeability
c         sat       = soil saturation
c         water     = water depth (below surface) and water height (above base)
c         time      = time
c         ddu       = acceleration of soil skeleton
c         ddw       = relative acceleration of pore fluid
c
        Unit_u_1 = 10 + 5*nRVEs + 5
        Unit_u_2 = 10 + 5*nRVEs + 6
        Unit_u_3 = 10 + 5*nRVEs + 7
        Unit_s_11 = 10 + 5*nRVEs + 8
        Unit_s_12 = 10 + 5*nRVEs + 9
        Unit_s_13 = 10 + 5*nRVEs + 10
        Unit_s_22 = 10 + 5*nRVEs + 11
        Unit_s_23 = 10 + 5*nRVEs + 12
        Unit_s_33 = 10 + 5*nRVEs + 13
        Unit_w =   10 + 5*nRVEs + 14
        Unit_p =   10 + 5*nRVEs + 15
        Unit_rho_soil =  10 + 5*nRVEs + 16
        Unit_rho_fluid = 10 + 5*nRVEs + 17
        Unit_Porosity =  10 + 5*nRVEs + 18
        Unit_kperm =     10 + 5*nRVEs + 19
        Unit_sat =       10 + 5*nRVEs + 20
        Unit_water =     10 + 5*nRVEs + 21
        Unit_time =      10 + 5*nRVEs + 22
c       Unit_ddu3 =      10 + 5*nRVEs + 23
c       Unit_ddw =       10 + 5*nRVEs + 24
c       Unit_grad_max =  10 + 5*nRVEs + 25
c       Unit_rms =       10 + 5*nRVEs + 26
        Unit_I =         10 + 5*nRVEs + 27
        Unit_kn =        10 + 5*nRVEs + 28
        Unit_chi =       10 + 5*nRVEs + 29
        Unit_mass =      10 + 5*nRVEs + 30
        Unit_steps =     10 + 5*nRVEs + 31
c
c-------strings that are common to all of the outuput file names
        OutputPrefix = MainDir(1:LEN_TRIM(MainDir))// 
     x                 '/04_RunOutput/'    
        OutputSuffix = '_'//
     x                 MainDir(1:LEN_TRIM(MainDir))//
     x                 cVar(1:LEN_TRIM(cVar))//
     x                 '_'//
     x                 RockMotionFile(1:LEN_TRIM(RockMotionFile))//
     x                 '.txt'
c
c-------open all of these files
        open(unit=Unit_u_1,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_u_1'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_u_2,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_u_2'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_u_3,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_u_3'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c
        open(unit=Unit_s_11,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_11'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_s_12,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_12'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_s_13,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_13'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_s_22,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_22'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_s_23,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_23'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_s_33,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_s_33'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c
        open(unit=Unit_w,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_w'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_p,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_p'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c
        open(unit=Unit_rho_soil,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_rho_soil'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_rho_fluid,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_rho_fluid'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_Porosity,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_Porosity'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_kperm,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_kperm'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_sat,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_sat'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_water,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_water'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_time,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_time'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c       open(unit=Unit_ddu3,
c    x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
c    x            'Results_ddu3'//
c    x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c       open(unit=Unit_ddw,
c    x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
c    x            'Results_ddw'//
c    x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c       open(unit=Unit_grad_max,
c    x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
c    x            'Results_grad_max'//
c    x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c       open(unit=Unit_rms,
c    x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
c    x            'Results_rms'//
c    x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_I,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_I'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_kn,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_kn'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_chi,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_chi'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_mass,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_mass'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
        open(unit=Unit_steps,
     x       file=OutputPrefix(1:LEN_TRIM(OutputPrefix))//
     x            'Results_steps'//
     x            OutputSuffix(1:LEN_TRIM(OutputSuffix)))
c
c       open(unit=150,file='rms_grad_max.txt')
c
c-------add information as three header lines to each file
c       Note that the first item in each file is a value
c       of 0, 1, 2, or 3:
c         0: each row will contain nRVEs data items
c         1: each row will contain nRVEs+1 data items
c         2: each row will contain one data item
c         3: each row will contain two data items
        write(Unit_u_1, 920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_u_2, 920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_u_3, 920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_11,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_12,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_13,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_22,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_23,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_s_33,920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_w,   920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_p,   920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_rho_soil, 920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_rho_fluid,920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_Porosity, 920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_kperm,    920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_sat,      920) 1,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_water,    920) 3,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_time,     920) 2,nRVEs, dt_ref, dx_rve, nDempla_out
c       write(Unit_ddu3,     920) nRVEs, dt_ref, dx_rve, nDempla_out
c       write(Unit_ddw,      920) nRVEs, dt_ref, dx_rve, nDempla_out
c       write(Unit_grad_max, 920) nRVEs, dt_ref, dx_rve, nDempla_out
c       write(Unit_rms,      920) nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_I,        920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_kn,       920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_chi,      920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_mass,     920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
        write(Unit_steps,    920) 0,nRVEs, dt_ref, dx_rve, nDempla_out
c
  920   format(i8,/,i8,/,1pe21.14,/,1pe21.14,/,i8)
c
c-------write node displacement results. Use formating with a limit 
c       of 10,000 columns
        write(Unit_u_1,'(10000(1pe18.10))')(uNode(node,1),node=0,nRVEs)
        write(Unit_u_2,'(10000(1pe18.10))')(uNode(node,2),node=0,nRVEs)
        write(Unit_u_3,'(10000(1pe18.10))')(uNode(node,3),node=0,nRVEs)
c
c-------write the vertical accelerations
c       write(Unit_ddu3,'(10000(1pe14.6))')(ddu(3,rve),rve=0,nRVEs)
c       write(Unit_ddw,'(10000(1pe14.6))')(ddw(rve),rve=0,nRVEs)
c
c-------write the performance parameter
c       write(Unit_grad_max,'(10000(1pe14.6))')
c    x       (grad_max(rve),rve=0,nRVEs)
c       write(Unit_rms,'(10000(1pe14.6))')
c    x       (rms_grad_factor)
c
c-------write rve stresses
        write(Unit_s_11,'(10000(1pe14.6))')
     x       (stress(1,1,rve),rve=botrve,nRVEs)
        write(Unit_s_12,'(10000(1pe14.6))')
     x       (stress(1,2,rve),rve=botrve,nRVEs)
        write(Unit_s_13,'(10000(1pe14.6))')
     x       (Total_stress_rve(rve,1),rve=botrve,nRVEs)
        write(Unit_s_22,'(10000(1pe14.6))')
     x       (stress(2,2,rve),rve=botrve,nRVEs)
        write(Unit_s_23,'(10000(1pe14.6))')
     x       (Total_stress_rve(rve,2),rve=botrve,nRVEs)
        write(Unit_s_33,'(10000(1pe14.6))')
     x       (Total_stress_rve(rve,3),rve=botrve,nRVEs)
c
c-------pore fluid pressure
        write(Unit_p,'(10000(1pe14.6))')
     x       (p_ref_rve(rve),rve=botrve,nRVEs)
c
c-------write pore fluid displacement results
        write(Unit_w,'(10000(1pe18.10))')(wNode(node),node=0,nRVEs)
c
c-------write soil properties
        write(Unit_rho_soil,'(10000(1pe14.6))')
     x    (rho_soil_avg(node),node=0,nRVEs)
        write(Unit_rho_fluid,'(10000(1pe14.6))')
     x    (rho_fluid_avg(node),node=0,nRVEs)
        write(Unit_Porosity,'(10000(1pe14.6))')
     x    (Porosity_avg(node),node=0,nRVEs)
        write(Unit_kperm,'(10000(1pe14.6))')
     x    (kperm_avg(node),node=0,nRVEs)
        write(Unit_sat,'(10000(1pe17.9))')
     x    (S_avg(node),node=0,nRVEs)
c
c-------write various performance factors
        write(Unit_I,'(10000(1pe17.9))')
     x    (I_now(rve),rve=botrve,nRVEs)
        write(Unit_kn,'(10000(1pe17.9))')
     x    (kmean(rve),rve=botrve,nRVEs)
        write(Unit_chi,'(10000(1pe17.9))')
     x    (chi1(rve),rve=botrve,nRVEs)
        write(Unit_mass,'(10000(1pe17.9))')
     x    (massav(rve),rve=botrve,nRVEs)
        write(Unit_steps,'(10000(1pe17.9))')
     x    (dble(nDEMsteps(rve)),rve=botrve,nRVEs)
c
        write(Unit_water,901) WaterDepth, xWater
        write(Unit_time,901) 0.
  901   format(2(1pe17.9))
c
c-------we will begin the Dempla algorithm soon.  Set up the loop that
c       will advance the rock movement
c
c-------the index of the rock-displacement history (from the input M-file)
c       that occurs after the current time.  The rock displacement at the
c       current time must be interpolated from the rock-displacement
c       history file
        iAbove = 0
c
c-------index of the current time
        i4 = 0
c
c-------start at a current time of zero
        tBase(0) = 0
c
c-------the maximum time in the rock-displacement history file
        tRock_max = nRock*dtRock
c
c-------the initial displacement of rock (node=0)
        xBase(1,0) = 0.
        xBase(2,0) = 0.
        xBase(3,0) = 0.
c
c-------a counter for intermittent output of Dempla results
        iDempla_out = 0
c
c-------within a dempla time-step and for each RVE, we place a threshold 
c       on the deformation increment that must be reached before we run 
c       the DEM algorithm is run.  We do not run DEM on an RVE unless the
c       necessary deformation increment exceeds "eps_grad" (an input
c       parameter in the G-file).  So we must accumulate the deformation
c       across multiple dempla time-steps until we accumulate enough
c       deformation to run DEM on an RVE
        do 178 rve = botrve,nRVEs
            grad_u_rve_sum(rve,1) = 0.
            grad_u_rve_sum(rve,2) = 0.
            grad_u_rve_sum(rve,3) = 0.
            grad_w_rve_sum(rve) = 0.
  178   continue
c
c-------initialize the stress since the previous dem run
        do 410 rve = botrve,nRVEs
          stress_old(1,1,rve) = stress(1,1,rve)
          stress_old(1,2,rve) = stress(1,2,rve)
          stress_old(1,3,rve) = stress(1,3,rve)
          stress_old(2,1,rve) = stress(2,1,rve)
          stress_old(2,2,rve) = stress(2,2,rve)
          stress_old(2,3,rve) = stress(2,3,rve)
          stress_old(3,1,rve) = stress(3,1,rve)
          stress_old(3,2,rve) = stress(3,2,rve)
          stress_old(3,3,rve) = stress(3,3,rve)
c
          def_old(1,1,rve) = def(1,1,rve)
          def_old(1,2,rve) = def(1,2,rve)
          def_old(1,3,rve) = def(1,3,rve)
          def_old(2,1,rve) = def(2,1,rve)
          def_old(2,2,rve) = def(2,2,rve)
          def_old(2,3,rve) = def(2,3,rve)
          def_old(3,1,rve) = def(3,1,rve)
          def_old(3,2,rve) = def(3,2,rve)
          def_old(3,3,rve) = def(3,3,rve)
c
c---------the current fluid pressure
          p_next(rve) = pfluid(rve)
  410   continue
c
c-------is used to save the final rock displacment at the end of shaking
        lKeepRock = .false.
c
c-------again, print the number of dempla time-steps and dt
        write(*,900) nSteps_rve, dt_ref
c
c-------whether dem has been run within the DEMPLA algorithm
        ldemrun = .false.
c
c-------the number of depla steps within each period of the simulation
        iShake = 0
        iPostShake = 0
        iConsol = 0
c
c-------recent history of time-scaling factors during consolidation
        irms = 0
        do 412 i = 1,mrms
          frms(i) = 1.d0
  412   continue
c
c-------the DEMPLA time-stepping loop begins here...
c
c-------continue the Dempla algorithm until the time exceeds the maximum
c       time in the rock-displacement history file plus any additional
c       settlement time.  Note that during the period tRock_max + t_PostShake,
c       the general field equations are solved.  During the period t_Setl
c       an approximation is used (assumes small acceleration of soil and
c       water)
        do 180 while(tBase(i4)+(1.d0+0.000001d0)*dt_ref 
     x               .lt. (tRock_max + t_PostShake + t_Setl))
c
c---------is the rock motion being controlled by the motion file?
          lShake = tBase(i4)+(1.d0+0.000001d0)*dt_ref .lt. tRock_max
c
c---------whether we are entering the post-shaking quiescent period of
c         rock motion, but before the consolidation period.  During 
c         this period, we use either the full-Biot equations
          lPostShake = .not.lShake
     x                 .and.
     x                   tBase(i4)+(1.d0+0.000001d0)*dt_ref
     x                   .lt. (tRock_max + t_PostShake)
c
c---------whether we use a consolidation algorithm
          lConsol = .not.(lShake .or. lPostShake)
c
c---------the time step for the dempla analysis
          if(lShake) then
c-----------we are within the rock motion (shaking) part of the simulation.
c           The DEMPLA time step is established by the Courant step
            dt_rve = dt_ref
c
c-----------number os DEMPLA steps within the 
            iShake = iShake + 1
c
          elseif(lPostShake) then
c-----------we are within the post-shaking part of the simulation,
c           but we are using the general Biot equations.
c
c           The DEMPLA time step is established by the Courant step
            dt_rve = dt_ref
c
c-----------number of DEMPLA steps within the post-shaking period
            iPostShake = iPostShake + 1
c
          elseif(lConsol) then
c-----------we are in the consolidation part of the simulation
            iConsol = iConsol + 1
c
c-----------additional points for stress servo-control
            npnts_xtra = 1
c
c-----------override the use of proportional loading control, otherwise
c           we will reset the servo-control parameters to zero with each
c           dempla step. We use ltoggl to allow the servo-control parameters
c           to be reset at the start of consolidation, but only this one time.
            if(ltoggl) then
              lovrid = .true.
            endif
            ltoggl = .true.
c
c-----------the weights that will be assigned to the past velocities at
c           the current node at its neighboring nodes
            ainteg(-1) = 0.05d0
            ainteg(0) =  0.90d0
            ainteg(1) =  0.05d0
            ainteg(2) =  0.
c
          endif
c
          if(lShake .or. lPostShake) then
c-----------advance the Dempla time. For the consolidation stage, the
c           accumulated time will be determined later
            tBase(i4+1) = tBase(i4) + dt_rve
          endif
c
c---------the Dempla time step
          i4 = i4 + 1
c
c---------check whether the number of dempla time steps has exceeded the
c         dimension of certain arrays
          if(i4.gt.mbase) then
            print *,'  The number of dempla steps '//
     x              '(i4 in subroutin pla) exceeds the parameter '//
     x              'mbase.'
            print *,'  Increase mbase in the param file, recompile, '//
     x              'and rerun dempla'
            print *,'  Value of mbase:',mbase
            stop
          endif
c
c---------interpolate to find the rock displacement...
c
c---------during the shaking period, we interpolate the rock displacement
c         from the contents of the input Motion file
          if(lShake) then
            if(.true.) then
c-------------use cubic spline interpolation to find the rock displacement
              call splint(tRockalt, x1Rockalt, y2_1Rock, nRockalt,
     x                    tBase(i4), xtmp)
              xBase(1,i4) = xtmp
c
              call splint(tRockalt, x2Rockalt, y2_2Rock, nRockalt,
     x                    tBase(i4), xtmp)
              xBase(2,i4) = xtmp
c
              call splint(tRockalt, x3Rockalt, y2_3Rock, nRockalt,
     x                    tBase(i4), xtmp)
              xBase(3,i4) = xtmp
            elseif(.false.) then
c-------------an older version of interpolation.  It led to accelerations
c             that were not continuously differtiable 3 times
c
c-------------search through the rock-displacement history until we reach the
c             first time that exceeds the current dempla time
              do 182 while(tRock(iAbove).le.tBase(i4))
                iAbove = iAbove + 1
  182         continue
c
c-------------interpolate within the rock-displacment history to find the
c             rock displacment at the current dempla time
              do 184 i = 1,3
c---------------we use cubic interpolation to find the rock-displacement,
c               so that the rock acceleration is a continuous and differentiable
c               function
                if(iAbove.gt.1 .and. iAbove.lt.nRock) then
c-----------------within the interior intervals of the input rock motion
                  xBase(i,i4) = (tBase(i4) - tRock(iAbove-1)) / dtRock *
     x                            ((       xRock(i,iAbove+1)
     x                              - 2.d0*xRock(i,iAbove)
     x                              +      xRock(i,iAbove-1))
     x                             * (tBase(i4) - tRock(iAbove-1))**2
     x                             / (2.d0*dtRock**2)
     x                           + (-      xRock(i,iAbove+1)
     x                              + 4.d0*xRock(i,iAbove)
     x                              - 3.d0*xRock(i,iAbove-1))
     x                             * (tBase(i4) - tRock(iAbove-1))
     x                             / (2.d0*dtRock)
     x                           + xRock(i,iAbove-1))
     x                        + (tRock(iAbove) - tBase(i4)) / dtRock *
     x                            ((       xRock(i,iAbove)
     x                              - 2.d0*xRock(i,iAbove-1)
     x                              +      xRock(i,iAbove-2))
     x                             * (tBase(i4) - tRock(iAbove-2))**2
     x                             / (2.d0*dtRock**2)
     x                           + (-      xRock(i,iAbove)
     x                              + 4.d0*xRock(i,iAbove-1)
     x                              - 3.d0*xRock(i,iAbove-2))
     x                             * (tBase(i4) - tRock(iAbove-2))
     x                             / (2.d0*dtRock)
     x                           + xRock(i,iAbove-2))
c                 xBase(i,i4) = 0.5d0 * xBase(i,i4)
                elseif(iAbove.eq.1 .and. iAbove.lt.nRock) then
c-----------------within the initial interval of the input rock motion. We use
c                 quadratic interpolation
                  xBase(i,i4) =   (       xRock(i,iAbove+1)
     x                             - 2.d0*xRock(i,iAbove)
     x                             +      xRock(i,iAbove-1))
     x                            * (tBase(i4) - tRock(iAbove-1))**2
     x                            / (2.d0*dtRock**2)
     x                          + (-      xRock(i,iAbove+1)
     x                             + 4.d0*xRock(i,iAbove)
     x                             - 3.d0*xRock(i,iAbove-1))
     x                            * (tBase(i4) - tRock(iAbove-1))
     x                            / (2.d0*dtRock)
     x                          + xRock(i,iAbove-1)
                elseif(iAbove.eq.nRock .and. iAbove.gt.1) then
c-----------------within the final interval of the input rock motion. We use
c                 quadratic interpolation
                  xBase(i,i4) =   (       xRock(i,iAbove)
     x                             - 2.d0*xRock(i,iAbove-1)
     x                             +      xRock(i,iAbove-2))
     x                            * (tBase(i4) - tRock(iAbove-2))**2
     x                            / (2.d0*dtRock**2)
     x                          + (-      xRock(i,iAbove)
     x                             + 4.d0*xRock(i,iAbove-1)
     x                             - 3.d0*xRock(i,iAbove-2))
     x                            * (tBase(i4) - tRock(iAbove-2))
     x                            / (2.d0*dtRock)
     x                          + xRock(i,iAbove-2)
                else
c-----------------for unusual case, we resort to linear interpolation
                  xBase(i,i4) = xRock(i,iAbove-1)
     x                          + (tBase(i4) - tRock(iAbove-1))
     x                            *(xRock(i,iAbove) - xRock(i,iAbove-1))
     x                            / (tRock(iAbove) - tRock(iAbove-1))
                endif
  184         continue
            endif
          else
c-----------the rock is stationary.  We grab the last rock displacement
c           and toggle lKeepRock
            if(.not.lKeepRock) then
              lKeepRock = .true.
c-------------save the final displacement during shaking
              xBaseSave(1) = xBase(1,i4-1)
              xBaseSave(2) = xBase(2,i4-1)
              xBaseSave(3) = xBase(3,i4-1)
            endif
c
c-----------set the rock displacement to the final displacement during shaking
            xBase(1,i4) = xBaseSave(1)
            xBase(2,i4) = xBaseSave(2)
            xBase(3,i4) = xBaseSave(3)
          endif
c
c---------incremental displacement of the soil skeleton at the rock node,
c         in the 1, 2, and 3 directions
          duNode(0,1) = xBase(1,i4) - uNode(0,1)
          duNode(0,2) = xBase(2,i4) - uNode(0,2)
          duNode(0,3) = xBase(3,i4) - uNode(0,3)
c
c---------incremental the relative displacement of the fluid at the rock node
          dwNode(0) = 0.
c
c---------cumulative displacement of the soil skeleton at the rock node,
c         (node "0")
          uNode(0,1) = xBase(1,i4)
          uNode(0,2) = xBase(2,i4)
          uNode(0,3) = xBase(3,i4)
c
c---------displacement of the fluid at the rock node (node "0")
          wNode(0) = 0.
c
c---------velocities at the rock
          u_dot_old(1,0) = u_dot_next(1,0)
          u_dot_old(2,0) = u_dot_next(2,0)
          u_dot_old(3,0) = u_dot_next(3,0)
          w_dot_old(0) = w_dot_next(0)
c
c---------velocities at the rock
          u_dot_next(1,0) = duNode(0,1) / dt_rve
          u_dot_next(2,0) = duNode(0,2) / dt_rve
          u_dot_next(3,0) = duNode(0,3) / dt_rve
          w_dot_next(0) = dwNode(0) / dt_rve
c
c---------acceleration at the rock, using a backward difference
          ddu(1,0) = (u_dot_next(1,0) -u_dot(1,0))/dt_rve
          ddu(2,0) = (u_dot_next(2,0) -u_dot(2,0))/dt_rve
          ddu(3,0) = (u_dot_next(3,0) -u_dot(3,0))/dt_rve
c
c---------velocities at the rock
          u_dot(1,0) = u_dot_next(1,0)
          u_dot(2,0) = u_dot_next(2,0)
          u_dot(3,0) = u_dot_next(3,0)
          w_dot(0) = w_dot_next(0)
c
c---------for the consolidation phase, compute the rms activity of the
c         RVEs, so that the time-step can be adjusted
          rms_grad_max = 0.
c
c---------gradient of incremental displacements at the RVEs, which 
c         are the assembly locations and are located midway between the nodes
          do 190 rve = botrve,nRVEs-topdif
            grad_u_rve(rve,1) = 
     x        (duNode(rve,1) - duNode(rve-1,1)) 
     x        / (xNode(rve,3) - xNode(rve-1,3))
            grad_u_rve(rve,2) = 
     x        (duNode(rve,2) - duNode(rve-1,2)) 
     x        / (xNode(rve,3) - xNode(rve-1,3))
c
c-----------we control the deformation rate
            grad_u_rve(rve,3) = 
     x        (duNode(rve,3) - duNode(rve-1,3)) 
     x        / (xNode(rve,3) - xNode(rve-1,3))
c
c-----------with solving the full Biot equations), the primary
c           variable are the soil skeleton diplacements "u" and the relative
c           pore fluid displacements "w".  For the pore fluid, we compute
c           the fluid gradient (i.e., the pore fluid strain) from the
c           displacement.
            grad_w_rve(rve) = (dwNode(rve) - dwNode(rve-1)) 
     x                          / (xNode(rve,3) - xNode(rve-1,3))
c
c-----------the total change in deformations since the previous DEM run
            grad_u_rve_sum(rve,1) = grad_u_rve_sum(rve,1) 
     x                              + grad_u_rve(rve,1)
            grad_u_rve_sum(rve,2) = grad_u_rve_sum(rve,2)
     x                              + grad_u_rve(rve,2)
c-----------note that for consolidation phenomena, grad_u_rve is a stress
c           change, not a deformation change
            grad_u_rve_sum(rve,3) = grad_u_rve_sum(rve,3)
     x                              + grad_u_rve(rve,3)
c
c-----------we accumulate the increments of wdef since the previous dem run
            grad_w_rve_sum(rve) = grad_w_rve_sum(rve)
     x                            + grad_w_rve(rve)
c
c-----------the maximum of the strain increments.  We weight the inflow "w"
c           by a factor of 2.0 because of the pore fluid stiffness
            if(lShake) then
              grad_max(rve) = max(max(max(abs(grad_u_rve_sum(rve,1)),
     x                                    abs(grad_u_rve_sum(rve,2))),
     x                                    abs(grad_u_rve_sum(rve,3))),
     x                               2.d0*abs(grad_w_rve_sum(rve)))
              grad_max2(rve) = max(max(abs(grad_u_rve_sum(rve,1)),
     x                                 abs(grad_u_rve_sum(rve,2))),
     x                                 abs(grad_u_rve_sum(rve,3)))
            elseif(lPostShake) then
              grad_max(rve) = max(max(max(abs(grad_u_rve_sum(rve,1)),
     x                                    abs(grad_u_rve_sum(rve,2))),
     x                                    abs(grad_u_rve_sum(rve,3))),
     x                               2.d0*abs(grad_w_rve_sum(rve)))
              grad_max2(rve) = max(max(abs(grad_u_rve_sum(rve,1)),
     x                                 abs(grad_u_rve_sum(rve,2))),
     x                                 abs(grad_u_rve_sum(rve,3)))
            elseif(lConsol) then
c-------------we control the vertical stress rate, not deformation rate
              grad_max(rve) = 1.00d0*abs(grad_w_rve_sum(rve))
c
              grad_max2(rve) = max(max(abs(grad_u_rve_sum(rve,1)),
     x                                 abs(grad_u_rve_sum(rve,2))),
     x                                 abs(grad_u_rve_sum(rve,3)))
c
c-------------the time-step can be adjusted so that the RVEs do not
c             remain idle during this step.  We will adjust the time-step
c             based upon the RMS value of grad_max
              rms_grad_max = rms_grad_max + grad_max(rve)**2
            endif
c
c-----------the number of DEM time steps for this RVE
c
c-----------here, we have experimented with several models for determining
c           the number of DEM time steps per dempla time step.  The greater
c           the number of DEM time steps, the smaller the DEM strain 
c           increment.  Except for the first model, the strain increment
c           is reduced when the assembly approaches liquefaction, thus
c           counteracting the tendency for a larger inertial number, I.
c           The DEM strain increment will be between eps_grad and 
c           ddef_target, with no fewer than nsteps_min DEM time steps.
c           All three of these values are input with the G-file
            if(.false.) then
c-------------in the simplest model, the number of DEM time steps
c             is based upon the value of the target strain increment, 
c             ddef_target, that is given in the input G-file and on
c             the minimum number of steps, nsteps_min, also given in
c             the input G-file.  The number of DEM time steps
c             is the larger of the number of steps to produce 
c             a target strain rate and the minimum number of steps
              nDEMsteps(rve) = max(nsteps_min,
     x                             nint(grad_max2(rve) / ddef_target))
            elseif(.false.) then
c-------------in an alternative approach, we adjust the number of
c             DEM time steps to maintain a small value of the inertial
c             number.  We begin by finding the intertial number "I_ref"
c             that was found in a pre-testing trial DEM run, in which
c             the DEM strain increment ddef_target that is given in
c             the input G-file
              I_ref(rve) = ddef_target 
     x                      * sqrt(massdat(rve) 
     x                             / (2.d0*ravg(rve)) 
     x                             / pdat(rve))
c
c-------------we now compute a strain increment that will maintain
c             this same inertial number during shaking
              ddef_shake(rve) = I_ref(rve)
     x                           * sqrt(-(1.d0/3.d0)*(  stress(1,1,rve)
     x                                               + stress(2,2,rve)
     x                                               + stress(3,3,rve))
     x                                  * (2.d0*ravg(rve))
     x                                  / massav(rve))
c
c-------------do not use a strain increment greater than the one given
c             in the G-file
              ddef_shake(rve) = min(ddef_shake(rve), ddef_target)
c
c-------------use the maximum of this strain increment and the minimum
c             increment eps_grad that is given in the input G-file.
              ddef_shake(rve) = max(ddef_shake(rve), eps_grad)
c
c-------------use no fewer DEM time steps than the one given in
c             the G-file
              nDEMsteps(rve) = max(nsteps_min,
     x                              nint(grad_max2(rve) 
     x                                   / ddef_shake(rve)))
            elseif(.true.) then
c-------------in this approach, we use a strain rate that is consistent
c             with the contact stiffness, mean stress, and force imbalance.
c             We begin by computing a factor of propotionality between
c             the force imbalance and the ratio (strain rate)*k/p.
c             The factor is found from the trial DEM run during pre-test
              prop_chi_ref(rve) =   pdat(rve)
     x                             * chidat(rve)
     x                             / ddef_target
     x                             / kmdat(rve) 
c
c-------------a maximum force imbalance
              chi_target = 0.02d0
c
c-------------we now compute a strain increment that will not exceed
c             the maximum force imbalance with the current contact
c             stiffness and mean stress
              ddef_shake(rve) = -(1.d0/3.d0)*(  stress(1,1,rve)
     x                                         + stress(2,2,rve)
     x                                         + stress(3,3,rve))
     x                           * chi_target
     x                           / prop_chi_ref(rve)
     x                           / kmean(rve)

c-------------do not use a strain increment greater than the one given
c             in the G-file
              ddef_shake(rve) = min(ddef_shake(rve), ddef_target)
c
c-------------use the maximum of this strain increment and the minimum
c             increment eps_grad that is given in the input G-file.
              ddef_shake(rve) = max(ddef_shake(rve), eps_grad)
c
c-------------use no fewer DEM time steps than the one given in
c             the G-file
              nDEMsteps(rve) = max(nsteps_min,
     x                              nint(grad_max2(rve) 
     x                                   / ddef_shake(rve)))
            elseif(.false.) then
c-------------in this approach, we use a strain rate that is consistent
c             with the contact overlap, particle size, and force imbalance.
c             We begin by computing a factor of propotionality between
c             the force imbalance and the ratio (strain rate)*D/delta.
c             The factor is found from the trial DEM run during pre-test
              prop_chi_ref(rve) = ovrdat(rve)
     x                             * chidat(rve)
     x                             / ddef_target
     x                             / (2.d0*ravg(rve))
c
c-------------a maximum force imbalance
              chi_target = 0.05d0
c
c-------------we now compute a strain increment that will not exceed
c             the maximum force imbalance with the current contact
c             overlap
              ddef_shake(rve) = chi_target
     x                           * ovravg(rve)
     x                           / prop_chi_ref(rve)
     x                           / (2.d0*ravg(rve))
c
c-------------do not use a strain increment greater than the one given
c             in the G-file
              ddef_shake(rve) = min(ddef_shake(rve), ddef_target)
c
c-------------use the maximum of this strain increment and the minimum
c             increment eps_grad that is given in the input G-file.
              ddef_shake(rve) = max(ddef_shake(rve), eps_grad)
c
c-------------use no fewer DEM time steps than the one given in
c             the G-file
              nDEMsteps(rve) = max(nsteps_min,
     x                              nint(grad_max2(rve) 
     x                                   / ddef_shake(rve)))
            endif
c
c-----------in the "param" file, the parameter "lc1" gives the maximum
c           number (dimension) of control steps in various arrays.  
c           When the number of control steps exceeds the dimension of
c           the various control variable, we stop adding to control
c           step.  Instead, we begin overwriting the end of the control
c           variables
            if(iStage(rve).ge.lc1-2) then
              iStage_m1 = iStage(rve) - 1
              iStage_0 = iStage(rve)
c
              icontr(iStage_m1,rve) = icontr(iStage_0,rve)
              icontp(iStage_m1,rve) = icontp(iStage_0,rve)
              defrat(1,iStage_m1,rve) = defrat(1,iStage_0,rve)
              defrat(2,iStage_m1,rve) = defrat(2,iStage_0,rve)
              defrat(3,iStage_m1,rve) = defrat(3,iStage_0,rve)
              defrat(4,iStage_m1,rve) = defrat(4,iStage_0,rve)
              defrat(5,iStage_m1,rve) = defrat(5,iStage_0,rve)
              defrat(6,iStage_m1,rve) = defrat(6,iStage_0,rve)
              defrat(8,iStage_m1,rve) = defrat(8,iStage_0,rve)
              vrate(iStage_m1,rve) = vrate(iStage_0,rve)
              igoal(iStage_m1,rve) = igoal(iStage_0,rve)
              finalv(iStage_m1,rve) = finalv(iStage_0,rve)
              ipts(iStage_m1,rve) = ipts(iStage_0,rve)
              idump(iStage_m1,rve) = idump(iStage_0,rve)
              imicro(iStage_m1,rve) = imicro(iStage_0,rve)
              defdot(iStage_m1,rve) = defdot(iStage_0,rve)
              ipts2(iStage_m1,rve) = ipts2(iStage_0,rve)
              iplot(iStage_m1,rve) = iplot(iStage_0,rve)
c
              iStage(rve) = iStage(rve) - 1
            endif
c
c-----------the next step of the stress-strain control sequence
            iStage(rve) = iStage(rve) + 1
c
c-----------keep a second counting, in the event that lc1 is surpassed
            iStage2(rve) = iStage2(rve) + 1
c
c-----------check whether we will exceed array dimensions. "lc1" is the
c           dimension of the stress-strain control files.  In OVAL,
c           lc1 is the maximum number of control lines in the RunFile.
c           In DEMPLA, we create this RunFile and store it as an "I-file"
            if(iStage(rve).ge.lc1-1) then
              print *,
     x         '  Oops!! The number of dempla steps will exceed '//
     x         'the parameter lc1 in the param file.  '//
     x         'Increase lc1 and recompile.'
              print *,'  The number of dempla steps that were used:',i4
              print *,'  Value of lc1: ',lc1
              print *,'  Depla steps require for the shaking period: ',
     x                nRock*dtRock/dt_rve
              print *,'  Number of steps within the shaking period: ',
     x                iShake
              print *,
     x         '  Number of steps within the post-shaking period: ',
     x         iPostShake
              print *,
     x         '  Number of steps within the consolidation period: ',
     x         iConsol
              stop
            endif
c
c-----------initialize ldelay, whether to delay the running of DEM for this
c           RVE
            ldelay(rve) = .true.
  190     continue
c
c---------compute the rms value of the RVEs activity. This parameter is
c         tracked during post-shaking consolidation, so that the time
c         step can be adjusted to speed up the DEM calculations
          rms_grad_max = sqrt(rms_grad_max / nRVEs)
c
          if(lConsol) then
c-----------the target rms average rate of the RVE deformations
            rms_grad_target = 0.5d0*ddef_target
c
c-----------the ratio of the target and previous rate
            rms_grad_factor = rms_grad_target / rms_grad_max
c
            srms = frms(1)
c
c-----------successful with L45V_2_10_E_mu022_f040, case "n"
            rms_grad_factor = min(rms_grad_factor, 1.20d0)
c
            frms(1) = rms_grad_factor
c
            do 196 rve = botrve,nRVEs-topdif
c-------------scale the deformations, so that the new rms average rate will
c             equal the target rate
              grad_max(rve) = grad_max(rve) * rms_grad_factor
c
              grad_w_rve_sum(rve) = grad_w_rve_sum(rve) 
     x                              * rms_grad_factor
  196       continue
c
c-----------the scaled dempla time step
            dt_rve = dt_rve * rms_grad_factor
c
c-----------the accumulated time
            tBase(i4) = tBase(i4-1) + dt_rve
          endif
c
c---------for Jager contacts, shorten the loading histories if the lists
c         are getting too long
          do 198 rve = botrve,nRVEs-topdif
            if(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)
     x         .or. lJagr4(rve)) then
c-------------for Jager contacts, check whether the linked list is nearly
c             overflowing
              xfill = real(nfilled(rve)) / real(mlistJ)
              if(xfill .gt. 0.85d0) then
c---------------straighten the Jager equivalent load history
                call stratn(rve)
                ishrtn(rve) = 1
c---------------shorten the Jager equivalent load history
                nlistJ = mlistJ
                call consol(rve,nlistJ)
              endif
            endif
  198     continue
c
          do 192 rve = botrve,nRVEs-topdif
c
c-----------when the increment of deformation for this RVE is too small,
c           delay the running of the DEM algorithm for the RVE
            if(.true.) then
              ldelay(rve) = .false.
            endif
c
c           ldelay(rve) = grad_max(rve).le.eps_grad
c
c-----------control parameters for the Dempla algorithm step: control
c           the rates of strain in the 13, 23, and 33 directions, with the
c           three remaining strains zero.
c           In OVAL, these parameters would be within the input RunFile
            defrat(1,iStage(rve),rve) = 0.
            defrat(2,iStage(rve),rve) = 0.
            defrat(4,iStage(rve),rve) = 0.
c-----------the inflow "w" is the negative of (fluid - skeleton) displacement
            ipts(iStage(rve),rve) = nDEM_out
            idump(iStage(rve),rve) = 0
            imicro(iStage(rve),rve) = 0
            defdot(iStage(rve),rve) = 0.
            ipts2(iStage(rve),rve) = 0
            iplot(iStage(rve),rve) = 0
            vrate(iStage(rve),rve) = 0.
c
c-----------more control parameters: control all strain components
            if(lShake .or. lPostShake) then
c-------------for medium-speed Z&B or full-Biot algorithms ,
c             control all deformations
              icontr(iStage(rve),rve) = 000000
            elseif(lConsol) then
              if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
c---------------for consolidation, maintain control of the vertical 
c               total stress, but control deformations of 11, 22, and 12
c               components. With level ground, maintain constant shearin strain
c               of 13 and 23 components
                icontr(iStage(rve),rve) = 006000
              else
c               with sloping ground, maintain constant stress 
c               of 13 and 23 components
                icontr(iStage(rve),rve) = 006011
              endif
            endif
c
c-----------control the inflow of fluid (measure the response pressure)
            icontp(iStage(rve),rve) = 0
c
c-----------run DEM for a given number of time steps
            igoal(iStage(rve),rve) = 70
  192     continue
c
          do 193 rve = botrve,nRVEs-topdif
            if(ldelay(rve)) then
c-------------the deformation did not reach the threshold.  Delay the running
c             of DEM until enough deformation has accumulated
c
              defrat(3,iStage(rve),rve) = 0.
              defrat(5,iStage(rve),rve) = 0.
              defrat(6,iStage(rve),rve) = 0.
              defrat(8,iStage(rve),rve) = 0.
              finalv(iStage(rve),rve) = 0
            else
              if(lShake .or. lPostShake) then
c---------------vertical normal deformation rate
                defrat(3,iStage(rve),rve) = grad_u_rve_sum(rve,3)
     x                                      / nDEMsteps(rve)
c
c---------------horizontal shearing deformation rates
                defrat(5,iStage(rve),rve) = grad_u_rve_sum(rve,1)
     x                                      / nDEMsteps(rve)
                defrat(6,iStage(rve),rve) = grad_u_rve_sum(rve,2)
     x                                      / nDEMsteps(rve)
              elseif(lConsol) then
c---------------for consolidation, maintain constant vertical total stress
c               defrat(3,iStage(rve),rve) =
c    x            (TotStressRVE(rve) - TotStressRVEsav(rve))
c    x            / nDEMsteps(rve)
c
c               defrat(3,iStage(rve),rve) =
c    x            -grav*(Integ_rho_s_sav(rve) - Integ_rho_s(rve))
c    x            / nDEMsteps(rve)
c
                defrat(3,iStage(rve),rve) = 0.
c
c---------------maintain constant horizontal shear stresses
                defrat(5,iStage(rve),rve) = 0.
                defrat(6,iStage(rve),rve) = 0.
              endif
c
c-------------the inflow "w" is the negative of (fluid - skeleton)
c             displacement
              defrat(8,iStage(rve),rve) = -grad_w_rve_sum(rve)
     x                                    / nDEMsteps(rve)
c
              finalv(iStage(rve),rve) = nDEMsteps(rve)
            endif
c
c-----------reset the current control step
            istep(rve) = iStage(rve) - 1
c
c-----------reset the control step that is used in screen output
            istep2(rve) = iStage2(rve) - 1
c
c-----------the last control step of this DEM runstage
            istepm(rve) = iStage(rve)
c
            call WriteInput2(rve,iStage(rve),
     x                       OutputDir,OutputRunFile(rve))
  193     continue
c
c---------whether to continue from a previous run (as when a restart 
c         "C" file is used to start a run)
          lcont = .true.
c
c---------do not print output of the initial conditions
          lfirst = .false.
c
c---------a threshold strain.  The value is given in the input G-file.
c         If the increment of strain is less than this threshold, then 
c         do not use the DEM algorithm, but assume the strain is zero 
c         for this Dempla increment and skip the DEM algorithm
c         eps_grad = 1.d-7
c
          write(*,902) i4,nSteps_rve
  902     format('  Running DEM simulations for Dempla step',
     x           i10, '  of ', i10)
c
c---------run the DEM simulations of the RVEs with parallelization
c
!$OMP     PARALLEL DO SCHEDULE(STATIC)
!$OMP+             PRIVATE(rve, lcont)
          do 200 rve = botrve,nRVEs-topdif
            if(ldelay(rve)) then
c-------------create the first few lines of output in the B* file
              istep(rve) = istepm(rve)
              istep2(rve) = iStage2(rve)
              call output(rve)
c
c-------------the inertial number and other performance parameters for this run
              I_now(rve) = 0.
              kn_now(rve) = 0.
              chi_now(rve) = 0.
              mass_now(rve) = 0.
            else
c-------------sufficient deformation is required.  Run DEM for this RVE
c
c-------------save the deformation from the previous DEM run.  This will be
c             needed during the post-shaking consolidation (lConsol = .true.)
c             to compute the movements of the nodes.  We only reset the
c             value of defsav here, so that the increment will not reset
c             in the event that the DEM is not run
              defsav(1,3,rve) = def(1,3,rve)
              defsav(2,3,rve) = def(2,3,rve)
              defsav(3,3,rve) = def(3,3,rve)
c
c-------------save the previous effective stress
              stress_old(1,3,rve) = stress(1,3,rve)
              stress_old(2,3,rve) = stress(2,3,rve)
              stress_old(3,3,rve) = stress(3,3,rve)
c
c-------------save the previous strain
              def_old(3,3,rve) = def(3,3,rve)
c
c-------------save the integrated soil density
c             TotStressRVEsav(rve) = TotStressRVE(rve)
              Integ_rho_s_sav(rve) = Integ_rho_s(rve)
c
c-------------save the total vertical stress at the rve
c             TotStressRVE_sav(rve) = TotStressRVE(rve)
c
c-------------save the previous pore liquid pressure
              p_old(rve) = pfluid(rve)
c
c-------------the DEM algorithm. zzz
              lcont = .true.
              lfirst = .false.
              call dem(rve,lcont,OutputDir,OutputRunFile(rve),lfirst)
c
c-------------reset the accumulated deformation for DEM runs
              grad_u_rve_sum(rve,1) = 0.
              grad_u_rve_sum(rve,2) = 0.
              grad_u_rve_sum(rve,3) = 0.
              grad_w_rve_sum(rve) = 0.
c
c-------------reset the accumulated fluid pressure
              p_next(rve) = pfluid(rve)
c
c-------------the inertial number and other performance parameters for this run
              I_now(rve) = grad_max2(rve) / nDEMsteps(rve)
     x                     * sqrt(massav(rve) 
     x                            / (2.d0*ravg(rve)) 
     x                            / ((-1.d0/3.d0)*(  stress(1,1,rve)
     x                                             + stress(2,2,rve)
     x                                             + stress(3,3,rve))))
              kn_now(rve) = kmean(rve)
              chi_now(rve) = chi1(rve)
              mass_now(rve) = massav(rve)
            endif
  200     continue
!$OMP     END PARALLEL DO
c
          do 220 rve = botrve,nRVEs
c-----------total stresses at the RVEs, based upon the reference stresses.
c           These stresses are based on the intergranular stress that
c           was found with the DEM run and on the pore water pressure found
c           in the DEM run
            if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
              Total_stress_rve(rve,1) =  stress(1,3,rve)
     x                                 - stressRVEo(rve,1,3)
              Total_stress_rve(rve,2) =  stress(2,3,rve)
     x                                 - stressRVEo(rve,2,3)
              Total_stress_rve(rve,3) = -grav*Integ_rho_s(rve)
     x                                 + stress(3,3,rve)
     x                                 - stressRVEo(rve,3,3)
     x                                 - (pfluid(rve)
     x                                    - pfluidRVEo(rve))
c
c-------------pore water pressure, based on the reference pressure
              p_ref_rve(rve) =  grav*Integ_rho_f(rve)
     x                        + pfluid(rve)
     x                        - pfluidRVEo(rve)
            else
c-------------sloping ground or water. Total stresses in directions 1, 2, 3 
c             (stresses 13, 23, and 33).  Note that we have integrated
c              downward, so a change in sign.  With the shearing stresses, 
c              we add the stress due to seepage forces.  We add the 
c              change in stress.
              Total_stress_rve(rve,1) = 
     x           -grav*(  cosin_s(1)*Integ_rho_s(rve)
     x                  - cosin_w(1)*Integ_rho_f(rve))
     x          + stress(1,3,rve) 
     x          - stressRVEo(rve,1,3)
              Total_stress_rve(rve,2) = 
     x           -grav*(  cosin_s(2)*Integ_rho_s(rve)
     x                  - cosin_w(2)*Integ_rho_f(rve))
     x          + stress(2,3,rve) 
     x          - stressRVEo(rve,2,3)
              Total_stress_rve(rve,3) = 
     x           -grav*cosin_s(3)*Integ_rho_s(rve)
     x          + stress(3,3,rve) 
     x          - stressRVEo(rve,3,3)
     x          - (pfluid(rve) 
     x             - pfluidRVEo(rve))
c
c-------------fluid pressure
              p_ref_rve(rve) = grav*cosin_s(3)*Integ_rho_f(rve)
     x                         + pfluid(rve)
     x                         - pfluidRVEo(rve)
            endif
c
c-----------stress and water pressure at the ground surface
            if(WaterDepth.ge.0.) then
c-------------the water table is below the ground surface
              Total_stress_surface(1) = 0.
              Total_stress_surface(2) = 0.
              Total_stress_surface(3) = 0.
              p_ref_surface = 0.
            else
c-------------water is above the ground surface.  Note that the slope of
c             the water surface will be zero
              Total_stress_surface(1) =
     x           grav*cosin_s(1)*rho_w*WaterDepth
              Total_stress_surface(2) =
     x           grav*cosin_s(2)*rho_w*WaterDepth
              Total_stress_surface(3) =
     x           grav*cosin_s(3)*rho_w*WaterDepth
              p_ref_surface = -grav*cosin_s(3)*rho_w*WaterDepth
            endif
c
c-----------flush output buffers
            if(rve.le.nRVES-topdif) then
              flush(ScrUnit(rve))
c             flush(ErrUnit(rve))
              if(lABfile) then
                flush(AUnit(rve))
                flush(BUnit(rve))
              endif
            endif
  220     continue
c
c---------the gradient of stress and fluid pressure at the bottom node
          grad_sigma_old(0,1) = grad_sigma(0,1);
          grad_sigma_old(0,2) = grad_sigma(0,2);
          grad_sigma_old(0,3) = grad_sigma(0,3);
          grad_p_old(0) = grad_p(0)
c
          grad_sigma(0,1) = 0.;
          grad_sigma(0,2) = 0.;
          grad_sigma(0,3) = 0.;
          grad_p(0) = 0.
c
          do 222 node = 2,nRVEs-1
c-----------find the gradients of stress and fluid pressure at the
c           nodal points.  We use the total stress, and the total
c           stress at a particular RVE equals the geostatic total stress
c           -grav*Integ_rho_s plus the change in total stress "stress" minus
c           "stressRVEo"
c
            rve = node
c
c-----------save the previous gradients
            grad_sigma_old(node,1) = grad_sigma(node,1);
            grad_sigma_old(node,2) = grad_sigma(node,2);
            grad_sigma_old(node,3) = grad_sigma(node,3);
            grad_p_old(node) = grad_p(node)
c
c-----------use central difference of the nearest RVE stresses
            grad_sigma(node,1) = ( Total_stress_rve(rve+1,1)
     x                           - Total_stress_rve(rve,1)) 
     x                          / ((xNode(rve+1,3) - xNode(rve-1,3)) 
     x                             / 2.d0)
            grad_sigma(node,2) = ( Total_stress_rve(rve+1,2)
     x                           - Total_stress_rve(rve,2)) 
     x                          / ((xNode(rve+1,3) - xNode(rve-1,3)) 
     x                             / 2.d0)
            grad_sigma(node,3) = ( Total_stress_rve(rve+1,3)
     x                           - Total_stress_rve(rve,3)) 
     x                          / ((xNode(rve+1,3) - xNode(rve-1,3)) 
     x                             / 2.d0)
c
            grad_p(node) = (p_ref_rve(rve+1) - p_ref_rve(rve)) 
     x                    / ((xNode(rve+1,3) - xNode(rve-1,3)) 
     x                       / 2.d0)
  222     continue
c
c---------gradient of stress and fluid pressure at Node=1 and at the 
c         ground surface.
c
c---------the gradient at Nod=1 as a weighted average of the nearest
c         RVEs.  Note that we must use forward differences.  For Node=1
          node = 1
          rve = node
c
c---------save the previous gradients
          grad_sigma_old(node,1) = grad_sigma(node,1);
          grad_sigma_old(node,2) = grad_sigma(node,2);
          grad_sigma_old(node,3) = grad_sigma(node,3);
          grad_p_old(node) = grad_p(node)
c
          grad_sigma(node,1) = ( Total_stress_rve(rve+1,1)
     x                         - Total_stress_rve(rve,1))
     x                         / ((xNode(rve+1,3) - xNode(rve-1,3))
     x                           / 2.d0)
          grad_sigma(node,2) = ( Total_stress_rve(rve+1,2)
     x                         - Total_stress_rve(rve,2))
     x                         / ((xNode(rve+1,3) - xNode(rve-1,3))
     x                           / 2.d0)
          grad_sigma(node,3) = ( Total_stress_rve(rve+1,3)
     x                         - Total_stress_rve(rve,3))
     x                         / ((xNode(rve+1,3) - xNode(rve-1,3))
     x                           / 2.d0)
c
          grad_p(node) = (p_ref_rve(rve+1) - p_ref_rve(rve))
     x                   / ((xNode(rve+1,3) - xNode(rve-1,3))
     x                   / 2.d0)
c
c---------gradients at the ground surface
c
c---------save the previous gradients
          grad_sigma_old(nRVEs,1) = grad_sigma(nRVEs,1);
          grad_sigma_old(nRVEs,2) = grad_sigma(nRVEs,2);
          grad_sigma_old(nRVEs,3) = grad_sigma(nRVEs,3);
          grad_p_old(nRVEs) = grad_p(nRVEs)
c
          if(WaterDepth.ge.0.) then
c-----------the gradient is computed by assuming that the stress and
c           pressure are zero at the surface
            if(iGrad.eq.1 .or. xWater.gt.xNode(nRVEs-1,3)) then
c-------------use the 1st-order backward difference for the stress gradient
              grad_sigma(nRVEs,1) = 
     x          -Total_stress_rve(nRVEs,1) 
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
              grad_sigma(nRVEs,2) = 
     x          -Total_stress_rve(nRVEs,2) 
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
              grad_sigma(nRVEs,3) = 
     x          -Total_stress_rve(nRVEs,3) 
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
c
c-------------gradient of fluid pressure at the ground surface
              grad_p(nRVEs) = 
     x          -p_ref_rve(nRVEs) 
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
            else
c-------------use the 2nd-order backward difference for the stress gradient.
c             This means using Lagrange interpolation, using the surface
c             stress and the stresses at nodes nRVEs and nRVEs-1
c
c-------------use quadratic interpolation, using the node and the nodes
c             above and below
              xin(1) = xRVE(nRVEs-1)
              xin(2) = xRVE(nRVEs)
              xin(3) = xNode(nRVEs, 3)
c
c-------------interpolate at the top point (third point, at ground surface)
              iat = 3
c
c-------------a dummy value for "x".  It will be ignored, since iat.neq.0
              xat = 0.
c
              errmsg = 'Error in InterpLagrange 19'
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,1)
              yin(2) = Total_stress_rve(nRVEs  ,1)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,1) = ydiff
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,2)
              yin(2) = Total_stress_rve(nRVEs  ,2)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,2) = ydiff
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,3)
              yin(2) = Total_stress_rve(nRVEs  ,3)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,3) = ydiff
c
c-------------use quadratic interpolation to find the pore pressure gradient
              yin(1) = p_ref_rve(nRVEs-1)
              yin(2) = p_ref_rve(nRVEs  )
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the pressure gradient
              grad_p(nRVEs) = ydiff
            endif
          else
c-----------the gradient is computed by assuming that the stress and
c           pressure are zero at the surface (minus the hydrostatic
c           pressure of the water column)
c
            if(iGrad.eq.1) then
c-------------use the 1st-order backward difference for the stress gradient
              grad_sigma(nRVEs,1) = 
     x          -(Total_stress_rve(nRVEs,1) - Total_stress_surface(1))
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
              grad_sigma(nRVEs,2) = 
     x          -(Total_stress_rve(nRVEs,2) - Total_stress_surface(2))
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
              grad_sigma(nRVEs,3) = 
     x          -(Total_stress_rve(nRVEs,3) - Total_stress_surface(3))
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
c
c-------------gradient of fluid pressure at the ground surface
              grad_p(nRVEs) = 
     x          -(p_ref_rve(nRVEs) - p_ref_surface)
     x           * 2.d0 
     x           / (xNode(nRVEs,3) - xNode(nRVEs-1,3))
            else
c-------------use the 2nd-order backward difference for the stress gradient.
c             This means using Lagrange interpolation, using the surface
c             stress and the stresses at nodes nRVEs and nRVEs-1
c
c-------------use quadratic interpolation, using the node and the nodes
c             above and below
              xin(1) = xRVE(nRVEs-1)
              xin(2) = xRVE(nRVEs)
              xin(3) = xNode(nRVEs, 3)
c
c-------------interpolate at the top point (third point, at ground surface)
              iat = 3
c
c-------------a dummy value for "x".  It will be ignored, since iat.neq.0
              xat = 0.
c
              errmsg = 'Error in InterpLagrange 19'
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,1)
     x                 - Total_stress_surface(1)
              yin(2) = Total_stress_rve(nRVEs  ,1)
     x                 - Total_stress_surface(1)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,1) = ydiff
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,2)
     x                 - Total_stress_surface(2)
              yin(2) = Total_stress_rve(nRVEs  ,2)
     x                 - Total_stress_surface(2)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,2) = ydiff
c
c-------------use quadratic interpolation to find the stress gradient
              yin(1) = Total_stress_rve(nRVEs-1,3)
     x                 - Total_stress_surface(3)
              yin(2) = Total_stress_rve(nRVEs  ,3)
     x                 - Total_stress_surface(3)
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the stress gradient
              grad_sigma(nRVEs,3) = ydiff
c
c-------------use quadratic interpolation to find the pore pressure gradient
              yin(1) = p_ref_rve(nRVEs-1) - p_ref_surface
              yin(2) = p_ref_rve(nRVEs  ) - p_ref_surface
              yin(3) = 0.
c
              call InterpLagrange(iat, xin, yin, xat, yat, ydiff,
     x                            nRVEs, errmsg)
c
c-------------the pressure gradient
              grad_p(nRVEs) = ydiff
            endif
          endif
c
c---------gradients at the rock
c
c---------weight the gradients of stress and pressure at t and t-dt, using
c         the weighting factor xGrad
          do 128 node = 0,nRVEs
            grad_sigma(node,1) = 
     x        xGrad*grad_sigma(node,1) 
     x        + (1.d0 - xGrad)*grad_sigma_old(node,1)
            grad_sigma(node,2) = 
     x        xGrad*grad_sigma(node,2) 
     x        + (1.d0 - xGrad)*grad_sigma_old(node,2)
            grad_sigma(node,3) = 
     x        xGrad*grad_sigma(node,3) 
     x        + (1.d0 - xGrad)*grad_sigma_old(node,3)
            grad_p(node) = 
     x        xGrad*grad_p(node) + (1.d0 - xGrad)*grad_p_old(node)
  128     continue
c
c---------soil and pore fluid densities at the nodes, which are approximated
c         from the integrated densities.  This will give an average
c         density that is consistent with the the stress and pressure gradients
          do 230 node = 1,nRVEs-1
c-----------use a central difference of the total stress and fluid pressure
c           of the RVEs above and below
            rho_soil_avg(node) = 
     x        -(Integ_rho_s(node+1) - Integ_rho_s(node)) 
     x        / (xNode(node+1,3) - xNode(node,3))
            rho_fluid_avg(node) = 
     x        -(Integ_rho_f(node+1) - Integ_rho_f(node)) 
     x        / (xNode(node+1,3) - xNode(node,3)) 
c
c-----------the porosity, permeability,and saturation at the node is the
c           average of the RVEs above and below the node
            Porosity_avg(node) = 
     x        0.5d0*(Porosity(node+1) + Porosity(node))
            kperm_avg(node) = 
     x        0.5d0*(kperm(node+1) + kperm(node))
            S_avg(node) = 
     x        0.5d0*(S_now(node+1) + S_now(node))
  230     continue
c
c---------the soil and fluid densisties of soil at the ground surface
          rho_soil_avg(nRVEs) = 
     x                        (Integ_rho_s(nRVEs) - Integ_rho_s_surface)
     x                        / ((xNode(nRVEs,3) - xNode(nRVEs-1,3))
     x                           / 2.d0) 
          rho_fluid_avg(nRVEs) = 
     x                        (Integ_rho_f(nRVEs) - Integ_rho_f_surface)
     x                        / ((xNode(nRVEs,3) -xNode(nRVEs-1,3))
     x                           / 2.d0) 
c
          Porosity_avg(nRVEs) = Porosity(nRVEs)
          kperm_avg(nRVEs) = kperm(nRVEs)
          S_avg(nRVEs) = S_now(nRVEs)
c
c---------values at the base
          kperm_avg(0) = kperm_avg(1)
          rho_fluid_avg(0) = rho_fluid_avg(1)
          rho_soil_avg(0) = rho_soil_avg(1)
c
c---------use the full Biot equations (Zienkiewicz & Bettess)
c         Otherwise, we will use the consolidation algorithm
          if(lShake .or. lPostShake) then
c
c-----------at each node point
            do 240 node = 1,nRVEs
c-------------note that with lateral accelerations, we include a factor
c             "centrifuge" that accounts for the mass of the laminar rings
              C_1(1,1) = centrifuge*rho_soil_avg(node)
              C_1(2,2) = centrifuge*rho_soil_avg(node)
              C_1(3,3) = rho_soil_avg(node)
              C_1(3,4) = Porosity_avg(node)*rho_fluid_avg(node)
              C_1(4,3) = rho_fluid_avg(node)
              C_1(4,4) = rho_fluid_avg(node)
c
              C_2(1,1) = C_1(1,1)
              C_2(2,2) = C_1(2,2)
              C_2(3,3) = C_1(3,3)
              C_2(3,4) = C_1(3,4)
              C_2(4,3) = C_1(4,3)
              C_2(4,4) = C_1(4,4) 
     x                  + dt_rve * Porosity_avg(node)
     x                    / (2.d0*kperm_avg(node))
c
c-------------inverse of matrix C_2
              n2 = 4
              irve = 0
              imrve = 0
              call matinv(C_2,C_2inv,n2,ier,irve,imrve)
c
c-------------the right side of the matrix equation for solving the
c             node velocities
              if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
                RightSide(1) = dt_rve * grad_sigma(node,1)
                RightSide(2) = dt_rve * grad_sigma(node,2)
                RightSide(3) = dt_rve
     x                         * (  grad_sigma(node,3)
     x                            - grav*rho_soil_avg(node))
              else
                RightSide(1) = dt_rve
     x                         * (  grad_sigma(node,1)
     x                            - grav*cosin_s(1)*rho_soil_avg(node)
     x                            + grav*cosin_w(1)*rho_fluid_avg(node))
                RightSide(2) = dt_rve
     x                         * (  grad_sigma(node,2)
     x                            - grav*cosin_s(2)*rho_soil_avg(node)
     x                            + grav*cosin_w(2)*rho_fluid_avg(node))
                RightSide(3) = dt_rve
     x                         * (  grad_sigma(node,3)
     x                            - grav*cosin_s(3)*rho_soil_avg(node))
              endif
c
              if(node.eq.nRVEs) then
                if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
                  RightSide(4) = dt_rve
     x                          * ( -grav*rho_fluid_avg(node)
     x                              - grad_p(node)
     x                              - 0.5d0
     x                                *(  ainteg(-1) 
     x                                    * Porosity_avg(node-1)
     x                                    / kperm_avg(node-1)
     x                                    * w_dot(node-1)
     x                                  + (ainteg(0) + ainteg(1))
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot(node)
     x                                  + ainteg(2)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot_old(node)))
                else
                  RightSide(4) = dt_rve
     x                          * ( -grav*cosin_s(3)*rho_fluid_avg(node)
     x                             - grad_p(node)
     x                              - 0.5d0
     x                                *(  ainteg(-1) 
     x                                    * Porosity_avg(node-1)
     x                                    / kperm_avg(node-1)
     x                                    * w_dot(node-1)
     x                                  + (ainteg(0) + ainteg(1))
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot(node)
     x                                  + ainteg(2)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot_old(node)))
                endif
              else
                if(Dip_soil.eq.0. .and. Dip_water.eq.0.) then
                  RightSide(4) = dt_rve
     x                          * ( -grav*rho_fluid_avg(node)
     x                              - grad_p(node)
     x                              - 0.5d0
     x                                *(  ainteg(-1)
     x                                    * Porosity_avg(node-1)
     x                                    / kperm_avg(node-1)
     x                                    * w_dot(node-1)
     x                                  + ainteg(0)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot(node)
     x                                  + ainteg(1)
     x                                    * Porosity_avg(node+1)
     x                                    / kperm_avg(node+1)
     x                                    * w_dot(node+1)
     x                                  + ainteg(2)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot_old(node)))
                else
                  RightSide(4) = dt_rve
     x                          * ( -grav*cosin_s(3)*rho_fluid_avg(node)
     x                             - grad_p(node)
     x                             - 0.5d0
     x                                *(  ainteg(-1)
     x                                    * Porosity_avg(node-1)
     x                                    / kperm_avg(node-1)
     x                                    * w_dot(node-1)
     x                                  + ainteg(0)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot(node)
     x                                  + ainteg(1)
     x                                    * Porosity_avg(node+1)
     x                                    / kperm_avg(node+1)
     x                                    * w_dot(node+1)
     x                                  + ainteg(2)
     x                                    * Porosity_avg(node)
     x                                    / kperm_avg(node)
     x                                    * w_dot_old(node)))
                endif
              endif
c
              if(node.eq.nRVEs) then
c---------------for the top node, use only the information at this node
                RightSide(1) = RightSide(1)
     x                        + C_1(1,1)
     x                          * (   ainteg(-1)*u_dot(1,node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * u_dot(1,node  )
     x                             + ainteg( 2)*u_dot_old(1,node))
                RightSide(2) = RightSide(2)
     x                        + C_1(2,2)
     x                          * (   ainteg(-1)*u_dot(2,node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * u_dot(2,node  )
     x                             + ainteg( 2)*u_dot_old(2,node))
                RightSide(3) = RightSide(3)
     x                        + C_1(3,3)
     x                          * (   ainteg(-1)*u_dot(3,node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * u_dot(3,node  )
     x                             + ainteg( 2)*u_dot_old(3,node))
     x                        + C_1(3,4)
     x                          * (   ainteg(-1)*w_dot(node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * w_dot(node)
     x                             + ainteg( 2)*w_dot_old(node))
                RightSide(4) = RightSide(4)
     x                        + C_1(4,3)
     x                          * (   ainteg(-1)*u_dot(3,node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * u_dot(3,node  )
     x                             + ainteg( 2)*u_dot_old(3,node))
     x                        + C_1(4,4)
     x                          * (   ainteg(-1)*w_dot(node-1)
     x                             + (ainteg( 0) + ainteg(1))
     x                               * w_dot(node)
     x                             + ainteg( 2)*w_dot_old(node))
              else
c---------------for the remaining nodes, use previous velocities at
c               neighboring nodes
                RightSide(1) = RightSide(1)
     x                        + C_1(1,1)*(  ainteg(-1)*u_dot(1,node-1)
     x                                    + ainteg( 0)*u_dot(1,node  )
     x                                    + ainteg( 1)*u_dot(1,node+1)
     x                                  + ainteg( 2)*u_dot_old(1,node))
                RightSide(2) = RightSide(2)
     x                        + C_1(2,2)*(  ainteg(-1)*u_dot(2,node-1)
     x                                    + ainteg( 0)*u_dot(2,node  )
     x                                    + ainteg( 1)*u_dot(2,node+1)
     x                                  + ainteg( 2)*u_dot_old(2,node))
                RightSide(3) = RightSide(3)
     x                        + C_1(3,3)*(  ainteg(-1)*u_dot(3,node-1)
     x                                    + ainteg( 0)*u_dot(3,node  )
     x                                    + ainteg( 1)*u_dot(3,node+1)
     x                                  + ainteg( 2)*u_dot_old(3,node))
     x                        + C_1(3,4)*(  ainteg(-1)*w_dot(node-1)
     x                                    + ainteg( 0)*w_dot(node  )
     x                                    + ainteg( 1)*w_dot(node+1)
     x                                  + ainteg( 2)*w_dot_old(node))
                RightSide(4) = RightSide(4)
     x                        + C_1(4,3)*(  ainteg(-1)*u_dot(3,node-1)
     x                                    + ainteg( 0)*u_dot(3,node  )
     x                                    + ainteg( 1)*u_dot(3,node+1)
     x                                  + ainteg( 2)*u_dot_old(3,node))
     x                        + C_1(4,4)*(  ainteg(-1)*w_dot(node-1)
     x                                    + ainteg( 0)*w_dot(node  )
     x                                    + ainteg( 1)*w_dot(node+1)
     x                                  + ainteg( 2)*w_dot_old(node))
              endif
c
c-------------next vertical velocity of soil skeleton
              u_dot_next(3,node) = 0.
c
c-------------next horizontal velocities of soil skeleton
              u_dot_next(1,node) = 0.
              u_dot_next(2,node) = 0.
c
c-------------next vertical velocity of pore fluid (relative to the 
c             soil skeleton)
              w_dot_next(node) = 0.
c
c-------------node velocities of soil skeleton
              do 242 i = 1,3
                do 244 j = 1,4
                  u_dot_next(i,node) = u_dot_next(i,node) 
     x                                + C_2inv(i,j)*RightSide(j)
  244           continue
  242         continue
c
c-------------node velocities of pore fluid
              do 246 j = 1,4
                w_dot_next(node) = w_dot_next(node)
     x                            + C_2inv(4,j)*RightSide(j)
  246         continue
  240       continue
          elseif(lConsol) then
c-----------we use the "very slow phenomena" consolidation algorithm
c
c-----------at each node point, the velocity of water and the relative 
c           velocity of water
            do 332 node = 1,nRVEs
c-------------velocity of soil skeleton at the nodes.  Compute from the
c             deformations of the RVEs.  The displacements are accumulated
c             from the rock, upward
              u_dot_next(1,node) = u_dot(1,node-1)
     x                             + (def(1,3,rve) - defsav(1,3,rve))
     x                               / defsav(3,3,rve)
     x                               * (xNode(node,3) - xNode(node-1,3))
     x                               / dt_rve
              u_dot_next(2,node) = u_dot(2,node-1)
     x                             + (def(2,3,rve) - defsav(2,3,rve))
     x                               / defsav(3,3,rve)
     x                               * (xNode(node,3) - xNode(node-1,3))
     x                               / dt_rve
c
c-------------during consolidation, we maintain constant vertical
c             total stresses.  The DEM algorithm computes the resulting
c             vertical deformations of the RVEs
              u_dot_next(3,node) = 
     x                           u_dot(3,node-1)
     x                           + (def(3,3,rve) - defsav(3,3,rve))
     x                             / defsav(3,3,rve)
     x                             * (xNode(node,3) - xNode(node-1,3))
     x                             / dt_rve
c
c-------------relative velocity of water
              w_dot_next(node) = 
     x         - (kperm_avg(node)/Porosity_avg(node))
     x          *(-grav*(rho_soil_avg(node) - rho_fluid_avg(node))
     x            + (grad_sigma(node,3) + grad_p(node))
     x           )
  332       continue
          endif
c
          do 330 node = 1,nRVEs
c-----------displacement increment. During rock movement, this movement
c           results from the soil accelerations.  During consolidation, 
c           this movement is being computed from the deforamtions of the RVEs
            duNode(node,1) = dt_rve*u_dot_next(1,node)
            duNode(node,2) = dt_rve*u_dot_next(2,node)
            duNode(node,3) = dt_rve*u_dot_next(3,node)
            dwNode(node) = dt_rve*w_dot_next(node)
c
c-----------update the node displacements
            uNode(node,1) = uNode(node,1) + duNode(node,1)
            uNode(node,2) = uNode(node,2) + duNode(node,2)
            uNode(node,3) = uNode(node,3) + duNode(node,3)
            wNode(node) = wNode(node) + dwNode(node)
c
c-----------update the node locations
            xNode(node,1) = xNode(node,1) + duNode(node,1)
            xNode(node,2) = xNode(node,2) + duNode(node,2)
            xNode(node,3) = xNode(node,3) + duNode(node,3)
c
c-----------update the positions of the RVEs.  The RVEs are roughly midway
c           between nodes, so we move the RVE the average of the 
c           node movements
            xRVE(node) = xRVE(node) 
     x                   + 0.5d0*(duNode(node,3) + duNode(node-1,3))
c
c-----------accelerations
            ddu(1,node) = (u_dot_next(1,node) - u_dot(1,node)) /dt_rve
            ddu(2,node) = (u_dot_next(2,node) - u_dot(2,node)) /dt_rve
            ddu(3,node) = (u_dot_next(3,node) - u_dot(3,node)) /dt_rve
            ddw(node) =   (w_dot_next(node) - w_dot(node)) / dt_rve
c
c-----------this will be the previous velocities in the next step
            u_dot_old(1,node) = u_dot(1,node)
            u_dot_old(2,node) = u_dot(2,node)
            u_dot_old(3,node) = u_dot(3,node)
            w_dot_old(node) =   w_dot(node)
c
c-----------update the node velocities
            u_dot(1,node) = u_dot_next(1,node)
            u_dot(2,node) = u_dot_next(2,node)
            u_dot(3,node) = u_dot_next(3,node)
            w_dot(node) =   w_dot_next(node)
  330     continue
c
          do 334 node = 1,nRVEs
c-----------update the depths of the interfaces between stratigraphic
c           layers.  Note that the layers are ordered downward, with
c           layer 1 at the surface.  Note that xLayerBottom() is the
c           height of the layer bottom above the base
c
c-----------check all layers to see whether the layer bottom is between
c           two nodes
            do 248 jLayer = 1,nLayers-1
c-------------check whether the layer bottom lies between two nodes
              if(xLayerBottom(jLayer).lt.xNode(node,3)
     x           .and. xLayerBottom(jLayer).ge.xNode(node-1,3)) then
c---------------interpolate the displacement of the layer bottom from
c               the displacements of the two nodes
                xLayerBottom(jLayer) = 
     x            xLayerBottom(jLayer) 
     x            + duNode(node-1,3)
     x            + (duNode(node,3) - duNode(node-1,3))
     x              *(xLayerBottom(jLayer) - xNode(node-1,3))
     x              /(xNode(node,3) - xNode(node-1,3))
              endif
  248       continue
c
c-----------update the location of the water table.  Note that if the 
c           ground surface is submerged, then the following test is false.
c           and xWater remains unchanged
            if(xWater.lt.xNode(node,3) 
     x         .and. xWater.ge.xNode(node-1,3)) then
c-------------movement of the soil skeleton
              xWater = xWater
     x                 + duNode(node-1,3)
     x                 + (duNode(node,3) - duNode(node-1,3))
     x                   *(xWater - xNode(node-1,3))
     x                   /(xNode(node,3) - xNode(node-1,3))
c
c-------------include the movement of water relative to the soil skeleton
              xWater = xWater
     x                 + dwNode(node-1)
     x                 + (dwNode(node) - dwNode(node-1))
     x                   *(xWater - xNode(node-1,3))
     x                   /(xNode(node,3) - xNode(node-1,3))
            endif
c
  334     continue
c
c---------water depth
          WaterDepth = xNode(nRVEs,3) - xWater
c
c---------check all for a rigid-body lifting of entire column
c
c---------update the depths of the RVEs and nodes
          do 250 rve = botrve,nRVEs
c-----------update the RVE depths
            DepthRVE(rve) = xNode(nRVEs,3) - xRVE(rve)
c
c-----------update the node depths. Depths are downward from the surface
            DepthNode(rve) = xNode(nRVEs,3) - xNode(rve,3)
  250     continue
c
c---------update the depths of the bottoms of stratigraphic layers
          do 252 jLayer = 1,nLayers-1
            LayerBottom(jLayer) = xNode(nRVEs,3) - xLayerBottom(jLayer)
  252     continue
c---------depth of base (rock)
          LayerBottom(nLayers) = xNode(nRVEs,3)
c
c---------solve the void ratio, saturation, water density, and soil density 
c         and the initial total stress and water pressure at each rve.  
c         An iterative approach is needed
          do 340 itrate=1,3
c
            do 350 rve = botrve,nRVEs-topdif
c
c-------------the stratigraphic layer in which the rve lies
              iLayer = LayerRVE(rve)
c
c-------------First, the void ratio of the rve's.  This void ratio is based 
c             upon the reference Porosity in the L-file (when this input value 
c             is < 0, then we use the porosity of the dem assembly).  This
c             reference porosity is assumed as the state of the soil after 
c             the initial dem run of the L-files, but before the rve's were
c             consolidated at their various depths.  Note that this reference
c             porosity changes when the rve's are consolidated at the various
c             depths within the layer.
c
c-------------the assumed initial void ratio of the assembly
              voidno(rve) = VoidRatio(iLayer)
c
c-------------the actual initial void ratio of the assembly
c             voidna(rve) = (vcello(rve) - vso(rve))/vso(rve)
c
c-------------the void ratio of the RVE, based upon the assumed and
c             actual initial void ratios (voidno and voidna) and the 
c             current void ratio
c             voidnb(rve) = voidno(rve)
c    x                      - (voidna(rve) - voidn(rve))
c    x                        * (1.d0 + voidno(rve))
c    x                        / (1.d0 + voidna(rve))
              voidnb(rve) = voidno(rve)
     x                      - (lvoidno(iLayer) - voidn(rve))
     x                        * (1.d0 + voidno(rve))
     x                        / (1.d0 + lvoidno(iLayer))
c
c-------------revise the Porosity
              Porosity(rve) = voidnb(rve) / (1.d0 + voidnb(rve))
c
c-------------dry bulk density of soil, kg/m^3.  Note that we ignore two
c             minor effects when using rho_dry: (1) we ignore changes in 
c             G_s due to compression of the grains, and (2) we ignore the
c             mass of the air in the voids
              rho_d(rve) = (G_s(iLayer)*rho_w + voidnb(rve)*rho_a)
     x                     / (1.d0 + voidnb(rve))
c
c-------------saturated density of soil, kg/m^3
              rho_s(rve) = (G_s(iLayer) + voidnb(rve))
     x                     * rho_w / (1.d0 + voidnb(rve))
c
c-------------second, the saturation of the pore fluid
c
              if(.true.) then
c---------------bulk density
                if(iporo(rve).eq.1) then
c-----------------the assembly is assumed to be saturated
c                 rho_soil(rve) = rho_s(rve)
c
c-----------------density of pore fluid, if the fluid is water/air
                  rho_f(rve) = rho_w
                elseif(iporo(rve).eq.3) then
c-----------------the assemply can contain bubbles or bubbles might form.  We
c                 must find the current saturation
c
c-----------------a model of pore fluid compressibility that includes 
c                 dissolution of pore gas and includes surface tension 
c                 of gas bubbles.  Besides the parameters listed above, 
c                 these other parameters are involved in computing the 
c                 water pressure.  Note that "pfluid" is the liquid-phase 
c                 pore pressure, measured relative to atmospheric pressure
c
c                 * gamm is the bubble surface tension
c                 * p_atm is the reference atmospheric pressure
c                 * Hcc is the dimensionless Henrys coefficient
c                 * S_o is the initial saturation of the pore fluid with liquid
c                 * D_o is the initial bubble size
c                 * N_o is the initial number/density of bubbles
c
c-----------------Jacobian of the bulk deformation gradient
                  J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c-----------------compressibility of pore liquid
                  C_w = 1.d0 / K_f(rve)
c
c-----------------change in mean effective stress from the original (reference)
c                 condition
                  dm_stress = 
     x              ( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x               -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve)))
     x              /3.d0
c
c-----------------whether to compute (1) water pressure for a given strain, or
c                 (2) fluid strain for a given water pressure
                  itask = 1
c
c-----------------small number that is used to find the threshold
c                 volumetric strain (or water pressure) of the pore
                  epsv = 1d-10
c
c-----------------temporary values when calling bubble
                  pfluid_tmp = pfluid(rve)
                  S_tmp = S_now(rve)
                  defw_tmp = defw(rve)
c
c-----------------subroutin for finding water pressure and bubble size
c                 of quasi-saturated soil
                  call bubble(gamm(rve), p_atm(rve), p_o(rve), 
     x                      Hcc(rve), C_w, S_o(rve), D_o(rve), N_o(rve),
     x                      J_f, pfluid_tmp, p_vap(rve), p_wcav(rve), 
     x                      Dcurnt, S_tmp,
     x                      K_s(rve), poros0(rve), defw_tmp, dm_stress,
     x                      Dlast(rve), itask)
c
c-----------------save current bubble diameter, to expedite the next time step
                  Dlast(rve) = Dcurnt
c
c-----------------now, the bulk density, including the effect of partial
c                 saturation, if the soil was saturated
                  rho_s(rve) = (1.d0 - S_tmp)*rho_d(rve)
     x                          + S_tmp*rho_s(iLayer)
c
c-----------------density of pore fluid for air-water mixture, if the soil
c                 was water/air (not air only)
                  rho_f(rve) = (1.d0 - S_tmp)*rho_a
     x                         + S_tmp*rho_w
c
                elseif(iporo(rve).eq.4) then
c-----------------air-filled voids
c
c-----------------now, the bulk density, including the effect of partial
c                 saturation, if the soil was saturated
                  rho_s(rve) = (1.d0 - S_o(rve))*rho_d(rve)
     x                          + S_o(rve)*rho_s(iLayer)
c
c-----------------density of pore fluid for air-water mixture, if the soil
c                 was water/air (not air only)
                  rho_f(rve) = (1.d0 - S_o(rve))*rho_a
     x                         + S_o(rve)*rho_w
                endif
              endif
c
              if(DepthRVE(rve).lt.WaterDepth) then
c---------------the assembly is above the water table
c
c---------------effective permeability to air
                kperm(rve) = k_a(LayerRVE(rve))
c
c---------------bulk density of soil
                rho_soil(rve) = rho_d(rve)
c
c---------------density of pore fluid
                rho_fluid(rve) = rho_a
c
c---------------the soil is above the water table
                lAbove(rve) = .true.
              else
c---------------the assembly is below the water table
c
c---------------effective permeability to water
                kperm(rve) = k_w(LayerRVE(rve))
c
c---------------the assembly is assumed to be saturated
                rho_soil(rve) = rho_s(rve)
c
c---------------density of pore fluid
                rho_fluid(rve) = rho_f(rve)
c
c---------------the soil is below the water table
                lAbove(rve) = .false.
              endif
  350       continue
c
c-----------now, using the adjusted densities, compute the integrated 
c           densities of the soil and pore fluid at the RVEs.
c
c-----------the integrated density at the ground surface
            if(WaterDepth.ge.0.) then
              Integ_rho_s_surface = 0.
              Integ_rho_f_surface = 0.
            else
              Integ_rho_s_surface = -WaterDepth * rho_w
              Integ_rho_f_surface = -WaterDepth * rho_w
            endif
c
c-----------begin by finding the integrated density at the top RVE.
c           The top RVE is midway between the surface and the node below it
            if(WaterDepth.lt.0.) then
c-------------the ground surface is submerged
c
c-------------integrated soil density
              Integ_rho_s(nRVEs) = 
     x          - rho_w*WaterDepth
     x          + rho_soil(nRVEs)*DepthRVE(nRVEs)
c
c-------------integrated fluid density
              Integ_rho_f(nRVEs) = 
     x          - rho_w*WaterDepth 
     x          + rho_fluid(nRVEs)*DepthRVE(nRVEs)
c
            elseif(.not.lAbove(nRVEs)) then
c-------------the water table is between the ground surface and the top RVE
c
c-------------integrated soil density
              Integ_rho_s(nRVEs) = 
     x            rho_d(nRVEs)*WaterDepth
     x          + rho_soil(nRVEs)*(DepthRVE(nRVEs)-WaterDepth)
c
c-------------integrated fluid density
              Integ_rho_f(nRVEs) = 
     x            rho_a*WaterDepth 
     x          + rho_fluid(nRVEs)*(DepthRVE(nRVEs)-WaterDepth)
            else
c-------------the water table is below the top RVE. Geostatic total stress...
              Integ_rho_s(nRVEs) = 
     x          rho_soil(nRVEs)*DepthRVE(nRVEs)
c
c-------------hydrostatic pressure
              Integ_rho_f(nRVEs) = rho_fluid(nRVEs)*DepthRVE(nRVEs)
            endif
c
c-----------accumulate the integrated densities 
c           from the next-to-top RVE to the bottom RVE
            do 360 rve = nRVEs-1,botrve,-1
              if(     (      lAbove(rve) 
     x                 .and. lAbove(rve+1))
     x           .or. (      .not.lAbove(rve)
     x                 .and. .not.lAbove(rve+1))) then
c---------------water table is not between the current RVE and the RVE above it
                if(LayerRVE(rve+1).eq.LayerRVE(rve)) then
c-----------------both RVEs are in the same layer. Use the average of the
c                 RVE's densities.
                  Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x              + 0.5d0*(rho_soil(rve) + rho_soil(rve+1))
     x                     *(DepthRVE(rve) - DepthRVE(rve+1))
c
c-----------------integrated fluid density
                  Integ_rho_f(rve) = Integ_rho_f(rve+1) 
     x                         + rho_fluid(rve)
     x                           *(DepthRVE(rve) - DepthRVE(rve+1))
                else
c-----------------the RVEs are in different layers. Use the densities of the
c                 respective layers.
                  Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x              + rho_soil(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                                      - DepthRVE(rve+1))
     x              + rho_soil(rve)*(DepthRVE(rve)
     x                                   - LayerBottom(LayerRVE(rve+1)))
c
c-----------------integrated fluid density
                  Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x              + rho_fluid(rve+1)
     x                *(LayerBottom(LayerRVE(rve+1))
     x                  - DepthRVE(rve+1))
     x              + rho_fluid(rve)
     x                *(DepthRVE(rve)
     x                  - LayerBottom(LayerRVE(rve+1)))
                endif
              else
c---------------the water table is between the current RVE and the RVE above it
                if(LayerRVE(rve+1).eq.LayerRVE(rve)) then
c-----------------the two RVEs are in the same layer.  This means that the
c                 upper RVE is dry (with the density that is dry):
c                   rve+1 / WT / rve
                  Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x              + rho_soil(rve+1)*(WaterDepth -DepthRVE(rve+1))
     x              + rho_soil(rve)  *(DepthRVE(rve) - WaterDepth)
c
c-----------------the integrated fluid density
                  Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x              + rho_fluid(rve+1)*(WaterDepth-DepthRVE(rve+1))
     x              + rho_fluid(rve)  *(DepthRVE(rve) - WaterDepth)
                elseif(WaterDepth.lt.LayerBottom(LayerRVE(rve+1))) then
c-----------------the water table is above the layer interface:
c                    rve+1 / WT / Interface / rve
c                 The integrated soil density
                  Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x              + rho_d(rve+1)*(WaterDepth - DepthRVE(rve+1))
     x              + rho_s(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                              - WaterDepth)
     x              + rho_soil(rve)*(DepthRVE(rve) 
     x                               - LayerBottom(LayerRVE(rve+1)))
c
c-----------------integrated fluid density
                  Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x              + rho_a*(WaterDepth - DepthRVE(rve+1))
     x              + rho_f(rve+1)*(LayerBottom(LayerRVE(rve+1))
     x                              - WaterDepth)
     x              + rho_fluid(rve)*(DepthRVE(rve) 
     x                                - LayerBottom(LayerRVE(rve+1)))
                else
c-----------------the water table is below the layer interface:
c                    rve+1 / Interface / WT / rve
c                 The integrated soil density
                  Integ_rho_s(rve) = Integ_rho_s(rve+1)
     x              + rho_d(rve+1)*(LayerBottom(LayerRVE(rve+1)) 
     x                              - DepthRVE(rve+1))
     x              + rho_d(rve)*(WaterDepth
     x                            - LayerBottom(LayerRVE(rve+1)))
     x              + rho_soil(rve)*(DepthRVE(rve) - WaterDepth)
c
c-----------------The integrated fluid density
                  Integ_rho_f(rve) = Integ_rho_f(rve+1)
     x              + rho_a         *(LayerBottom(LayerRVE(rve+1)) 
     x                                - DepthRVE(rve+1))
     x              + rho_a         *(WaterDepth
     x                                - LayerBottom(LayerRVE(rve+1)))
     x              + rho_fluid(rve)*(DepthRVE(rve) - WaterDepth)
                endif
              endif
  360       continue
c
  340     continue
c
c---------use the integrated density to compute the hydrostatic pressure,
c         which is used to place a cap on the water pressure to prevent
c         pressure surges due to bubble collapse
          do 362 rve = botrve,nRVEs-topdif
            iLayer = LayerRVE(rve)
            if(iCap(iLayer).eq.1) then
              pCap(rve) = grav*Integ_rho_s(rve) + xCap(iLayer)
            else
              pCap(rve) = 0.
            endif
  362     continue
c
c---------increment counter for reporting Dempla results
          iDempla_out = iDempla_out + 1
c
c---------whether to report Dempla results to output files
          if(iDempla_out.ge.nDempla_out) then
c
c-----------reset counter
            iDempla_out = 0
c
c-----------write node displacement results. Use formating with a limit 
c           of 10,000 columns
            write(Unit_u_1,'(10000(1pe18.10))')
     x        (uNode(node,1),node=0,nRVEs)
            write(Unit_u_2,'(10000(1pe18.10))')
     x        (uNode(node,2),node=0,nRVEs)
            write(Unit_u_3,'(10000(1pe18.10))')
     x        (uNode(node,3),node=0,nRVEs)
c
c-----------write node accelerations
c           write(Unit_ddu3,'(10000(1pe14.6))')
c    x           (ddu(3,node),node=0,nRVEs)
c           write(Unit_ddw,'(10000(1pe14.6))')
c    x           (ddw(node),node=0,nRVEs)
c
c-----------write performance parameter
c           write(Unit_grad_max,'(10000(1pe14.6))')
c    x           (grad_max(node),node=botrve,nRVEs)
c           write(Unit_rms,'(10000(1pe14.6))')
c    x           (rms_grad_factor)
c
            write(Unit_s_11,'(10000(1pe14.6))')
     x           (stress(1,1,rve),rve=botrve,nRVEs)
            write(Unit_s_12,'(10000(1pe14.6))')
     x           (stress(1,2,rve),rve=botrve,nRVEs)
            write(Unit_s_13,'(10000(1pe14.6))')
     x           (Total_stress_rve(rve,1),rve=botrve,nRVEs)
            write(Unit_s_22,'(10000(1pe14.6))')
     x           (stress(2,2,rve),rve=botrve,nRVEs)
            write(Unit_s_23,'(10000(1pe14.6))')
     x           (Total_stress_rve(rve,2),rve=botrve,nRVEs)
            write(Unit_s_33,'(10000(1pe14.6))')
     x           (Total_stress_rve(rve,3),rve=botrve,nRVEs)
c
c-----------pore fluid pressure
            write(Unit_p,'(10000(1pe14.6))')
     x           (p_ref_rve(rve),rve=botrve,nRVEs)
c
c-----------write pore fluid displacement results
            write(Unit_w,'(10000(1pe18.10))')(wNode(node),node=0,nRVEs)
c
c-----------write soil properties
            write(Unit_rho_soil,'(10000(1pe14.6))')
     x        (rho_soil_avg(node),node=0,nRVEs)
            write(Unit_rho_fluid,'(10000(1pe14.6))')
     x        (rho_fluid_avg(node),node=0,nRVEs)
            write(Unit_Porosity,'(10000(1pe14.6))')
     x        (Porosity_avg(node),node=0,nRVEs)
            write(Unit_kperm,'(10000(1pe14.6))')
     x        (kperm_avg(node),node=0,nRVEs)
            write(Unit_sat,'(10000(1pe17.9))')
     x        (S_avg(node),node=0,nRVEs)
c
c-----------write performance parameters
            write(Unit_I,'(10000(1pe14.6))')
     x        (I_now(rve),rve=botrve,nRVEs)
            write(Unit_kn,'(10000(1pe14.6))')
     x        (kn_now(rve),rve=botrve,nRVEs)
            write(Unit_chi,'(10000(1pe14.6))')
     x        (chi_now(rve),rve=botrve,nRVEs)
            write(Unit_mass,'(10000(1pe14.6))')
     x        (mass_now(rve),rve=botrve,nRVEs)
            write(Unit_steps,'(10000(1pe14.6))')
     x        (dble(nDEMsteps(rve)),rve=botrve,nRVEs)
c
            write(Unit_water,901) WaterDepth, xWater
            write(Unit_time,901) tBase(i4)
c
c
c-----------flush the file buffers. The "flush" was not part of the original
c           fortran77 standard, but became part of the fortran 2003 standard.
c           By using flush, we can monitor the file output during a dempla run.
c           The flush command is not needed with the Intel ifort compiler,
c           but it is need with the Gnu gfortran compiler
            flush(Unit_u_1)
            flush(Unit_u_2)
            flush(Unit_u_3)
            flush(Unit_s_11)
            flush(Unit_s_12)
            flush(Unit_s_13)
            flush(Unit_s_22)
            flush(Unit_s_23)
            flush(Unit_s_33)
            flush(Unit_p)
            flush(Unit_w)
            flush(Unit_rho_soil)
            flush(Unit_rho_fluid)
            flush(Unit_Porosity)
            flush(Unit_kperm)
            flush(Unit_sat)
            flush(Unit_water)
            flush(Unit_time)
c           flush(Unit_ddu3)
c           flush(Unit_ddw)
c           flush(Unit_grad_max)
c           flush(Unit_rms)
            flush(Unit_I)
            flush(Unit_kn)
            flush(Unit_chi)
            flush(Unit_mass)
            flush(Unit_steps)
          endif
c
  180   continue
c
c-------close the output files
        close(unit=Unit_u_1)
        close(unit=Unit_u_2)
        close(unit=Unit_u_3)
        close(unit=Unit_s_11)
        close(unit=Unit_s_12)
        close(unit=Unit_s_13)
        close(unit=Unit_s_22)
        close(unit=Unit_s_23)
        close(unit=Unit_s_33)
        close(unit=Unit_w)
        close(unit=Unit_p)
        close(unit=Unit_rho_soil)
        close(unit=Unit_rho_fluid)
        close(unit=Unit_Porosity)
        close(unit=Unit_kperm)
        close(unit=Unit_sat)
        close(unit=Unit_water)
        close(unit=Unit_time)
c       close(unit=Unit_ddu3)
c       close(unit=Unit_ddw)
c       close(unit=Unit_grad_max)
c       close(unit=Unit_rms)
        close(unit=Unit_I)
        close(unit=Unit_kn)
        close(unit=Unit_chi)
        close(unit=Unit_mass)
        close(unit=Unit_steps)
c
c       close(unit=150)
c
        return
      end
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine InterpLagrange(iat, x, y, xat, yat, ydiff,
     x                          rve, errmsg)
c
        character*4 strRVE
        character*32 errmsg
        integer*2 iat,ipt,rve
        double precision A, B, C, x(3), xat, y(3), yat, ydiff
c
        A = (x(1) - x(2)) * (x(1) - x(3))
        B = (x(2) - x(1)) * (x(2) - x(3))
        C = (x(3) - x(1)) * (x(3) - x(2))
c
        if(iat.eq.1) then
          xat = x(1)
        elseif(iat.eq.2) then
          xat = x(2)
        elseif(iat.eq.3) then
          xat = x(3)
        endif
c
        if(A.ne.0. .and. B.ne.0. .and. B.ne.0.) then
c---------value of y at x=xat
          yat =   y(1) * (xat - x(2)) * (xat - x(3)) / A
     x          + y(2) * (xat - x(1)) * (xat - x(3)) / B
     x          + y(3) * (xat - x(1)) * (xat - x(2)) / C
c
c---------value of y' at x=xat
          ydiff =   y(1) * (2.d0*xat - x(2) - x(3)) / A
     x            + y(2) * (2.d0*xat - x(1) - x(3)) / B
     x            + y(3) * (2.d0*xat - x(1) - x(2)) / C
        else
          call int2str4(rve,strRVE)
c---------oops, print an error message and stop
          print *, ' '
          print *, '**** Error ****'
          print *, errmsg
          print *, 'RVE or node '//
     x             strRVE
          stop
        endif
c
        return
      end
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ReadMfile
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*4 i,j
        double precision z8
c
c-------read the file with the input rock displacements.  The first line
c       contains the time increment of the displacement record.  The record
c       is given in three columns separated with spaces: vertical (x1)
c       displacement, horizontal (x2) displacement, horizontal (x3)
c       displacement.  Each of these rows are the displacement at a time, 
c       equally spaced times.
c
c-------note, the first motion line should be three zeros.
c
c-------open the input file with the rock motion. The motion file is located
c       in the folder 'MotionInput'
c       file=MainDir(1:LEN_TRIM(MainDir))//
        open(unit=1,
     x       file='.'//
     x            '/MotionInput/'//
     x            RockMotionFile(1:LEN_TRIM(RockMotionFile)),
     x       status='old')
c
c-------the time increment between rock displacement values
        read(1,*) dtRock
c
c-------now, read each row of the rock displacements
        i = 0
   10   read(1,*,end=100) xRock(1,i), xRock(2,i), xRock(3,i)
          i = i + 1
          if(i.ge.mRock) then
            print *,'  Too many entries in the rock-motion file. Try'//
     x              ' increasing mRock in param-dempla-0.2.2.f'
            stop
          endif
        go to 10
c
c-------the number of rock displacement lines
  100   nRock = i - 1
c
        if(     abs(xRock(1,0)).gt.1.d-15 
     x     .or. abs(xRock(2,0)).gt.1.d-15 
     x     .or. abs(xRock(3,0)).gt.1.d-15) then
          print *,'  The initial rock displacement in the motion file'//
     x            ' must be zero.'
          print *,'  Your values:',xRock(1,1),xRock(2,1),xRock(3,1)
          print *,'  Fix the motion file and rerun.'
          stop
        endif
c
        close(unit=1)
c
c-------check the time increment
        if(dtRock.le.0.) then
          print *,'  dtRock must be greater than zero'
          stop
        endif
c
c-------check the number of displacemenbt lines
        if(nRock.lt.1) then
          print *,'  Rock motion file must contain at least two lines'
          stop
        endif
c
c-------the displacement in the first lines must all be zero
        if (.not.(      xRock(1,0).eq.0. 
     x            .and. xRock(2,0).eq.0. 
     x            .and. xRock(3,0).eq.0.)) then
          print *,
     x      '  The initial displacement in the rock motion file'//
     x      ' must be non-zero'
          stop
        endif
c
c-------compute the spline interpolation 2nd derivates
c       We must pass a vector (not an array) to the spline function.
c       The vector must be indexed, starting from 1, not 0
        do 112 j = 0,nRock
          tRockalt(j+1) = j*dtRock
          x1Rockalt(j+1) = xRock(1,j)
          x2Rockalt(j+1) = xRock(2,j)
          x3Rockalt(j+1) = xRock(3,j)
  112   continue
c
c-------number of motion points.  Note that nRock starts with 0, not 1
        nRockalt = nRock + 1
c
c-------must pass a double precision zero
        z8 = 0.
c
c-------call the function that computes the spline 2nd derivatives.
c       We assume that the initial and final rock velocities are zero
        call spline(tRockalt, x1Rockalt, nRockalt, z8, z8, y2_1Rock)
        call spline(tRockalt, x2Rockalt, nRockalt, z8, z8, y2_2Rock)
        call spline(tRockalt, x3Rockalt, nRockalt, z8, z8, y2_3Rock)
c
  900   format(f16.7)
  901   format(f16.7, f16.7, f16.7)
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine spline(x,y,n,yp1,ypn,y2)
        include 'param-dempla-0.2.2.f'
c
        integer i,k,n
        double precision p,qn,sig,un,u(mRock+1),
     x                   yp1,ypn,x(mRock+1),y(mRock+1),y2(mRock+1)
c
        if (yp1.gt.0.99d30) then
          y2(1) = 0.
          u(1) = 0.
        else
          y2(1) = -0.5d0
          u(1) = (3.d0 / (x(2) - x(1)))
     x         * ((y(2) - y(1)) / (x(2) - x(1)) - yp1)
        endif
c
        do 11 i = 2,n-1
          sig = (x(i) - x(i-1)) / (x(i+1) - x(i-1))
          p = sig*y2(i-1) + 2.d0
          y2(i) = (sig - 1.d0) / p
          u(i) = (6.d0*(  (y(i+1)-y(i)) / (x(i+1)-x(i))
     x                  - (y(i)-y(i-1)) / (x(i)-x(i-1)))
     x            / (x(i+1)-x(i-1)) - sig*u(i-1))
     x           /p
   11   continue
c
        if (ypn.gt.0.99d30) then
          qn = 0.
          un = 0.
        else
          qn = 0.5d0
          un = (3.d0/(x(n)-x(n-1)))
     x         *(ypn-(y(n)-y(n-1))/(x(n)-x(n-1)))
        endif
c
        y2(n) = (un - qn*u(n-1)) / (qn*y2(n-1) + 1.d0)
c
        do 12 k = n-1,1,-1 
          y2(k) = y2(k)*y2(k+1) + u(k)
   12   continue
c
        return
      end
c     
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine splint(xa,ya,y2a,n,x,y)
        include 'param-dempla-0.2.2.f'
c
        integer n,k,khi,klo
        double precision a,b,h,x,y,
     x                   xa(mRock+1),y2a(mRock+1),ya(mRock+1)
c
        klo = 1
        khi = n
c
    1   if(khi-klo.gt.1) then
          k = (khi + klo) / 2
          if(xa(k).gt.x)then
            khi = k
          else
            klo = k
          endif
c
          goto 1
        endif
c
        h = xa(khi) - xa(klo)
c
        if(h.eq.0.) then
          print *, "bad xa input in splint"
          stop
        endif
c
        a = (xa(khi) - x) / h
        b = (x - xa(klo)) / h
c
        y = a*ya(klo)+b*ya(khi)
     x      + ((a**3 - a)*y2a(klo) + (b**3 - b)*y2a(khi))
     x        *(h**2) / 6.d0
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ReadGfile
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 gvers, iLayer
        logical lError1, lError2
        character*4 strLayer
c
c-------open the input file with general information about the simulation.
c       This file is located in the MainDir (the name of the simulation),
c       and the file name is "G" + the MainDir name
        open(unit=1,
     x       file=MainDir(1:LEN_TRIM(MainDir))//
     x            '/G'//
     x            MainDir(1:LEN_TRIM(MainDir))//
     x            cVar(1:LEN_TRIM(cVar)),
     x       status='old')
c
c-------the version number of the file
        read(1,201) gvers
c
c-------the number of RVEs to be used for the soil column
        read(1,202) nRVEs
c
c-------the number of RVEs to be used for the soil column
        read(1,202) nLayers
c
        if(gvers.ge.0) then
c---------whether to create A and B files during the dempla run.  These files
c         will be created during the creation of the layer and RVE initial
c         conditions and during measurement of the stiffness moduli.
c         With a value of 0, the files are not created during the
c         dempla run.  With any other integer, the files will be created.
          read(1,202) iABfile
c
c---------whether preprocessing is required prior to the dempla run.  This
c         preprocessing includes the following:
c           1) create the initial C-files for the layers. The StartFiles for
c              the layers is likely a D-file, and a C-file must be created,
c              unless this has already been done
c           2) create all of the initial C-files (with the proper effective
c              stresses and water pressures) for the RVE assemblies within 
c              all of the layers
c           3) run DEM simulations to determine the stiffness moduli of the 
c              RVE assemblies.  These moduli are needed so that we can find 
c              the proper Dempla time step
c
c           0 = no, the preprocessing has already been done
c           1 = yes, do the preprocessing, even if it has already be done before
          read(1,202) iPreProcess
        else
          iABfile = 1
          iPreProcess = 1
        endif
c
c-------depth of rock below ground surface, m
        read(1,205) BaseDepth
c
c-------depth of water below ground surface, m
        read(1,205) WaterDepth
c
c       if(gvers.le.101) then
c---------bulk stiffness, liquid phase of pore fluid, Pa
c         read(1,205) Kw
c       endif
c
c-------viscocity of water, Pa*s
        read(1,205) visc_w
c
c-------viscocity of air, Pa*s
        read(1,205) visc_a
c
c-------water density, kg/m^3
        read(1,205) rho_w
c
c-------air density, kg/m^3 (the free air above ground)
        read(1,205) rho_a
c
c-------acceleration of gravity, m/s^2
        read(1,205) grav
c
c-------factor "centrifuge" to account for the mass of the rings in laminar
c       centrifuge tests (see the Taboada, 1995, PhD thesis). The factor
c       must be greater than 1.  If an input value of 0 is given, then
c       "centrifuge" is set equal to 1
        read(1,205) centrifuge
c
        if(centrifuge.eq.0.) then
          centrifuge = 1.d0
          print *,'A centrifuge factor of 1.0 is being used'
        elseif(centrifuge.lt.1.d0) then
          print *,'Your centrifuge factor in the G-file is .lt. 1'
          stop
        endif
c
c-------target strain increment per DEM time step
        read(1,205) ddef_target
c
c-------minimum number of time steps in a DEM simulation per Dempla step
c       read(1,202) nsteps_min
        nsteps_min = 1
c
c-------nsteps_min must be 1 or greater
        if(nsteps_min.lt.1) then
          print *,'nsteps_min in the G-file must be 1 or larger'
          print *,'Your value = ',nsteps_min
          print *,'nsteps_min must be an integer'
          stop
        endif
c
c-------a threshold strain.  If the increment of strain is less than
c       this threshold, then do not use the DEM algorithm, but assume
c       the strain is zero for this Dempla increment and skip the
c       DEM algorithm
c       read(1,205) eps_grad
        eps_grad = ddef_target
c
        if(eps_grad .lt. 0. 
     x     .or. eps_grad.gt.nsteps_min*ddef_target) then
          print *,
     x      'eps_grad must be .gt. 0 and .lt. nsteps_min*ddef_target'
          print *,'Your value = ',eps_grad
          stop
        endif
c
c-------the interval of Dempla steps between reporting results to output files
        read(1,202) nDempla_out
c
c-------the interval off DEM time steps between reporting off results
c       in the A-files and B-files during Dempla run (will be used in
c       lieu of "ipts" in the layer RunFiles)
        read(1,202) nDEM_out
c
c-------an adjustment to the Courant number used with the dempla
c       algorithm for solving the wave equation.  The default Courant
c       number is 0.75, but the factor "C_factor" can reduce the
c       Courant.  Values of C_factor greater than 1.0 are not recommended
        read(1,205) C_factor
c
        if(nDempla_out .lt. 0) then
          print *,'nDempla_out must be .ge. 0 in the G-file'
          print *,'Your value = ',nDempla_out
          stop
        elseif(nDempla_out .eq.0) then
          nDempla_out = 1
        endif
c
        if(nDEM_out .lt. 0) then
          print *,'nDEM_out must be .ge. 0 in the G-file'
          print *,'Your value = ', nDEM_out
          stop
        elseif(nDEM_out .eq.0) then
          nDEM_out = 1
        endif
c
        if(C_factor .le. 0) then
          print *,'C_factor must be .gt. 0 in the G-file'
          print *,'Your value = ', C_factor
          stop
        elseif(C_factor .gt. 1.d0) then
          print *,'Warning!! C_factor should be .lt. 1 in the G-file'
          print *,'Your value = ', C_factor
        endif
c
c-------the direction (in degrees) of the (downward) slope of the soil
c       surface and the rock base, measured CCW from the x1 direction.
        read(1,205) Direct_soil
c
c-------the dip (in degrees) of the soil surface and the rock base
        read(1,205) Dip_soil
c
c-------the direction (in degrees) of the (downward) sloping water table,
c       measured CCW from the x1 direction.
        read(1,205) Direct_water
c
c-------the dip (in degrees) of the water table
        read(1,205) Dip_water
c
c-------when the ground surface is submerged, the water surface can not slope
        if(WaterDepth.lt.0. .and. Dip_water.ne.0.) then
          print *,'  Oops! If the water level is above the ground '
          print *,'  surface, the water surface must have zero dip.'
          print *,'  Check the G-file.'
          print *,'  Your value of WaterDepth: ', WaterDepth
          print *,'  Your value of Dip_water: ', Dip_water
          print *,'  Dip_water must be 0.'
          stop
        endif
c
c-------to create the ground slope, the DEM RVEs are first created with a 
c       level ground surface. Then, the DEM RVEs are "tilted" by applying
c       slowly applying shear stress along horizontal and (complementary)
c       vertical boundaries. "nTiltSteps" is the number of DEM time steps
c       that will be used for the tilting process
        read(1,202) nTiltSteps
c
c-------after tilting the ground surface by applying shear stresses,
c       we allow the DEM RVEs to equilibrate.  Tne number of DEM time
c       steps for equilibration
        read(1,202) nTiltEquil
c
c-------after the rock motion stops, we can hold the rock displacement
c       constant (zero rock velocity) for a period "t_PostShake".
c       t_PostShake is the amount of (real) time for a motionless
c       rock.  The same algorithm that was used for the shaking is
c       continued during the period t_PostShake
        read(1,205) t_PostShake
c
c-------after the rock motion stops and after a the period t_PostShake, 
c       we can continue to allow for the migration of water and the
c       settlement of the soil column.  "t_Setl" is the amount of 
c       (real) time that is allowed for settlement.  The units are 
c       not the same time units the DEM steps.  Rather the time units 
c       are the same as those of the rock motion file.  A different
c       algorithm is used during this period
        read(1,205) t_Setl
c
c
c-------check for errors in the slope parameters
        if(abs(Slope_1).gt.0. .or. abs(Slope_2).gt.0.) then
c---------the ground is sloping, so check value for DEM time steps
          if(nTiltSteps.lt.1) then
            print *,'Warning!! nTiltSteps should be .gt. 1 in G-file'
            print *,'Your value = ', nTiltSteps
          endif
c
          if(nTiltEquil.lt.1) then
            print *,'Warning!! nTiltEquil should be .gt. 1 in G-file'
            print *,'Your value = ', nTiltEquil
          endif
        endif
c
c-------check t_Setl
        if(t_Setl.lt.0) then
          print *,'Warning!! t_Setl should be .ge. 0. in G-file'
          print *,'Your value = ', t_Setl
        endif
c
c-------initialize an error condition
        lError1 = .true.
c
c-------read miscallaneous information about the layers.  Other information
c       about each layer is given in its L-file and in its RunFile (the
c       former is constained within the main folder, the latter is contained
c       within the folder "RunFiles/").  Information in the L-files and
c       RunFiles is used to create the assemblies at each rve location.
c       These assemblies take much time to create, and the assemblies can
c       not be changed for the various dempla simulations that are conducted
c       with these assemblies.  The additional layer information that is
c       contained within the G-file can be changed for a dempla simulation.
c       For example, the permeability of the soil in a layer can be changed
c       after the assemblies have been created
c
c-------skip past some lines of comments
        read(1,210,end=100)
c
c-------it got this far, no error
        lError1 = .false.
c
c-------lSat: whether to use a special saturation condition for this layer
c         0 = no special treatment.  When iporo=3, Use the values of S_o,
c             p_o, and p_wcav in the RunFile of this layer in the RunFiles/
c             folder
c         1 = when iporo=3 and S_o=1.0, then p_o will be reset to the
c             water pressure at the end of consolidation, and p_wcav
c             will be reset to this water pressure minus the value of xSat
c             (u_wcav), which should be > 0.  When iporo=3 but S_o<1.0, 
c             then use the values of S_o, p_o, and p_wcav in the RunFile 
c             of this layer in the RunFiles/ folder
c         2 = when iporo=3 and S_o=1.0, then p_o will be reset to the
c             water pressure at the end of consolidation, and p_wcav (u_wcav)
c             will be reset to this water pressure times the value of xSat,
c             which should be <= 1.  When iporo=3 but S_o<1.0, then use 
c             the values of S_o, p_o, and p_wcav in the RunFile of this 
c             layer in the RunFiles/ folder
c         Note that cavitation is disallowed unless the following aspects
c         are included in the layer RunFile:  iporo=3, S_o=1.0,
c         N_o is non-zero, and Hcc is non-zero
c
c
c-------xSat:  when lSat = 1 or 2 and S_o = 1, this value is used for 
c              adjusting the p_wcav (u_wcav) value of the water pressure, 
c              below which cavitation occurs.
c         lSat = 0, no special treatment. xSat is ignored
c         lSat = 1, when iporo=3 and S_o=1.0, then p_o will be reset to the
c               water pressure at the end of consolidation, and p_wcav
c               will be reset to this water pressure minus the value of xSat
c               (u_wcav), which should be > 0.  When iporo=3 but S_o<1.0, 
c               then use the values of S_o, p_o, and p_wcav in the RunFile 
c               of this layer in the RunFiles/ folder.  For example, when
c               xSat = 10, then the pore water is under-saturated with air,
c               and cavitation will occur when the water pressure in the
c               RVE assembly is reduced to 10Pa below the hydrostatic pressure.
c         lSat = 2, when iporo=3 and S_o=1.0, then p_o will be reset to the
c               water pressure at the end of consolidation, and p_wcav (u_wcav)
c               will be reset to this water pressure times the value of xSat,
c               which should be <= 1.  When iporo=3 but S_o<1.0, then use 
c               the values of S_o, p_o, and p_wcav in the RunFile of this 
c               layer in the RunFiles/ folder.  For example, when
c               xSat = 10, then the pore water is under-saturated with air,
c               and cavitation will occur when the water pressure in the
c               RVE assembly is reduced to less than xSat times the 
c               hydrostatic pressure.
c         Note that cavitation is disallowed unless the following aspects
c         are included in the layer RunFile:  iporo=3, S_o=1.0,
c         N_o is non-zero, and Hcc is non-zero
c
c-------k_geot:  hydraulic conductivity, m/s (Q = k*i*A)
c
c-------iCap: whether to cap the pore water pressure (relative to the
c             hydrostatic pressure)  to prevent pressure surges 
c             due to bubble collapse
c         iCap = 0, no cap on the pore water pressure
c         iCap = 1, cap the pore water pressure to a pressure of xCap
c                   above the hydrostatic pressure
c
c-------xCap: when iCap = 1, the maximum pore water pressure above
c             the hydrostatic pressure
c
c-------initialize an error condition
        lError2 = .true.
c
        do 10 iLayer=1,nLayers
c---------express the integer Layer as a character string
          call int2str4(iLayer, strLayer)
c
          if(gvers.ge.0) then
            read(1,212,end=101) 
     x        lSat(iLayer), xSat(iLayer), k_geot(iLayer),
     x        iCap(iLayer), xCap(iLayer)
          else
            read(1,211,end=101) 
     x        lSat(iLayer), xSat(iLayer), k_geot(iLayer)
          endif
c
c---------check for a valid value of lSat
          if(.not.(lSat(iLayer).ge.0 .and. lSat(iLayer).le.2)) then
            print *,'lSat value in stratigraphic layer '//
     x              strLayer//
     x              ' should be 0, 1, or 2'
            print *,'Your value = ', lSat(iLayer)
            stop
          endif
c
c---------check for a valid value of xSat
          if(lSat(iLayer).eq.1 .and. xSat(iLayer).lt.0.) then
            print *,'Value of xSat in layer '//
     x              strLayer//
     x              'should be greater than zero'
            print *,'Your value: ',xSat(iLayer)
            stop
          elseif(lSat(iLayer).eq.2 .and. 
     x           (xSat(iLayer).gt.1. .or. xSat(iLayer).lt.0.)) then
            print *,'Value of xSat in layer '//
     x              strLayer//
     x              'should be between 0 and 1'
            print *,'Your value: ',xSat(iLayer)
            stop
          endif
c
c---------check for a valid hydraulic conductivity
          if(.not.(k_geot(iLayer).gt.0.)) then
            print *,'Value of permeability in layer '//
     x              strLayer//
     x              'should be greater than 0'
            print *,'Your value: ',k_geot(iLayer)
            stop
          endif
   10   continue
c
c-------it got this far, so no error
        lError2 = .false.
c
        close(unit=1)
c
  100   if(lError1) then
          print *,'  The G-file did not include the requisite lines'//
     x            ' of layer data at the bottom of the file'
          stop
        endif
c
  101   if(lError2) then
          print *,'  The G-file did not indlude information on each'//
     x            ' of the layers at the bottom of the file'
          stop
        endif
c
        return
c
  201   format(/,i16)
  202   format(i16)
  205   format(f16.7)
  210   format(///////)
  211   format(i4,2(1x,f9.6))
  212   format(i4,2(1x,f9.6),1x,i4,1x,f9.6)
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ReadLfile(iLayer)
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 iLayer
        character*4 strLayer
c
c-------express the integer Layer as a character string
        call int2str4(iLayer, strLayer)
c
c-------open the input file with general information about the simulation.
c       This file is located in the MainDir (the name of the simulation),
c       and the file name is "G" + the MainDir name
        open(unit=1,
     x       file=MainDir(1:LEN_TRIM(MainDir))//
     x            '/L'//
     x            strLayer//
     x            '_'//
     x            MainDir(1:LEN_TRIM(MainDir)),
     x       status='old')
c
c-------skip reading the header line of the input file
        read(1,201) strLayer
c
c-------the version number of the file
        read(1,202) lvers(iLayer)
c
        iRunLayer_DEM(iLayer) = iPreProcess
        iRunRVE_DEM(iLayer) = iPreProcess
        iRunRVEModuli(iLayer) = iPreProcess
c
c-------consolidation method for this layer: 
c         0,1 = isotropic consolidation
c         2   = anisotropic consolidation with zero lateral strain
        read(1,202) Isotropic(iLayer)
c
c-------thickness of this single layer, m
        read(1,205) LayerThickness(iLayer)
c
c-------void ratio of the soil layer
        read(1,205) VoidRatio(iLayer)
c
c-------specific gravity of soil solids in the soil layer
        read(1,205) G_s(iLayer)
c
c-------G_s must be greater than 0
        if(G_s(iLayer).le.0.) then
          print *,'  The value of G_s in the L-file must be greater'//
     x            ' than zero.'
          print *,'  Your value of G_s:  ', G_s(iLayer)
          stop
        endif
c
c-------the RunFile that will be used to create the initial assembly
c       for this layer.  This assembly will later be consolidated or
c       to create the effective stress and water pressure conditions
c       at each of the RVE locations within the layer
        read(1,210) RunFileLayer(iLayer)
c
c-------the StartFile that will be used to create the initial assembly
c       for this layer.  This assembly will later be consolidated or
c       to create the effective stress and water pressure conditions
c       at each of the RVE locations within the layer
        read(1,210) StartFileLayer(iLayer)
c
        close(unit=1)
c
        return
c
c 201   format(/,i16)
  201   format(a4)
  202   format(i16)
  205   format(f16.7)
  210   format(a400)
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine int2str4(i,s)
c
c-------this subroutin takes integer input "i" and creates a string "s"
c       with four characters
c
        integer*2 i
        character*4 s
c
        write(s, 10) i
  10    format (I4.4)
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine dem(rve,lcont,OutputFolderName,OutputRunFile,lfirst)
c
c-------this subroutin implements the DEM algorithm with a single rve:
c       calculates contact forces, advances the particle positions, changes
c       the boundary displacements, etc.  Repeat.  Repeat.
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
        integer*4 switch
c
        integer*4 listk, listJ, nboxs(0:mrve),
     x            nlist(0:mrve), nlist2(0:mrve), nlist3(0:mrve)
        integer*2 iremov,islip2,nnnear(0:mrve)
c
        double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s,
     x                   p_s, p_s0, p_s1,
     x                   RJag, zeta_o, zeta_s0, zeta_s1, zeta_s
        logical lcont,lfirst
        character*400 OutputFolderName,OutputRunFile
c
c-------a common block for sharing information with the subroutins 
c       Jager3D and Jagr3D2, which are used with Jager's generalization 
c       of the Hertz-Mindlin contact
        common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x                 Fn_s(Zero:mlistJ,0:mrve),
     x                 p_s(Zero:mlistJ,2,0:mrve),
     x                 zeta_s0(0:mlist2,0:mrve), 
     x                 zeta_s1(0:mlist2,0:mrve),
     x                 Fn_s0(0:mlist2,0:mrve), 
     x                 Fn_s1(0:mlist2,0:mrve),
     x                 p_s0(0:mlist2,2,0:mrve), 
     x                 p_s1(0:mlist2,2,0:mrve),
     x                 RJag(0:mlist2,0:mrve),
     x                 Fn_o(0:mlist2,0:mrve),
     x                 Ft_s(0:mlist2,2,2,0:mrve),
     x                 zeta_o(0:mlist2,0:mrve),
     x                 listJ(Zero:mlistJ,0:mrve), 
     x                 listk(Zero:mlist2,0:mrve),
     x                 iremov(0:mlist2,0:mrve), 
     x                 islip2(0:mlist2,0:mrve)
c
c-------when a simulation is being started from a (binary) resart file,
c       then write the initial conditions and then enter into the middle 
c       of DEM loop.  That is, skip past certain preliminaries and jump 
c       into the DEM loop at the same point where the restart file was 
c       created from the previous simulation.
        if(lcont) then
c---------create the first few lines of output in the B* file
          if(lfirst) then
            call output(rve)
          endif
c
c---------increment the boundary conditions (boundary movements or internal
c         stresses
          call contrl(rve,OutputFolderName,OutputRunFile)
c
c---------now, jump into the middle of the DEM loop
          goto 25
        else
c---------this is the first time step in a fresh run (no restart file is being
c           used in this run)
          linit(rve) = .true.
        endif
c
c-------------------------------------------------------------------------
c
c-------the DEM loop.  The cycle will be stopped when the last stress-strain
c       control period has been completed (as specified in the RunFile).  
c       See documentation.
c
 20   continue
c
c
c-------The type of algorithm being used to advance the particle positions
c       is read from the input file:
c           algori = 0 or 1  double time-integration algorithm, viscous damping
c           algori = 2       double time-integration algorithm, except that
c                            contact slips are only periodically updated.
c                            I have experimented with this algorithm and
c                            believe that it gives better and more accurate
c                            performance.  It only works, however, when the
c                            packing is dense.
c
c-------compute forces on the particles, average stress within the assembly, etc
        call forces(rve)
c
        if(algori.eq.1) then
c---------double integration of particle accelerations using the standard
c         DEM algorithm
c
c---------integrate the accelerations and velocities to find the new particle
c         positions.
          call integ1(rve)
c
c---------calculate whether to update the near-neighbor list
          call near(rve)
c
c---------revise the linked list of near-neighbors, if necessary, with
c         the subroutin lister. The period between updates depends on 
c         the amount of particle movement since the last update and on 
c         the maximum number of time steps between updates (input parameter 
c         iupdtm).  The logical variable lupdat is initialized in subroutin 
c         'init' and computed in subroutin 'diag'
          if(lupdat(rve)) then
!$OMP     CRITICAL
            nnnear(rve) = mnear
            nlist(rve) = mlist
            nlist2(rve) = mlist2
            nlist3(rve) = mlist3
            nboxs(rve) = mboxes
            call lister(rve,nnnear(rve),
     x                  nlist(rve),nlist2(rve),nlist3(rve),
     x                  nboxs(rve))
!$OMP     END CRITICAL
          endif
        endif
c
c-------compute measures of the quasi-static nature of the DEM.  We might
c       use this data to adjust the deformation increment in subroutin pla
        if(ldat(rve)) then
          ndat(rve) = ndat(rve) + 1
          ovrdat(rve) = ovrdat(rve) + ovravg(rve)
          chidat(rve) = chidat(rve) + chi1(rve)
          kmdat(rve) = kmdat(rve) + kmean(rve)
          pdat(rve) = pdat(rve) 
     x                - (1.d0/3.d0)*(  stress(1,1,rve) 
     x                               + stress(2,2,rve) 
     x                               + stress(3,3,rve))
          massdat(rve) = massdat(rve) + massav(rve)
        endif
c
c-------if a new stress-strain control period has been entered, establish the
c       new control parameters (strain rates, etc.).  The function 'switch' is 
c       a logical function.  The input parameters 'igoal' and 'finalv' 
c       determine the longevity of a stress-strain conrol period and are
c       described in subroutin 'check'.
c
        if(switch(timer(rve),dt(rve),tclock(rve),tclokm(rve),
     x   dbegin(rve),
     x   defv(igoala(rve),rve),
     x   streff(igoala(rve),rve),strtot(igoala(rve),rve),
     x   finalv(istep(rve),rve),
     x   igoala(rve),igoalb(rve)).eq.1) 
     x  call contrl(rve,OutputFolderName,OutputRunFile)
c
c-------when the last stress-stran control period is finished, exit the 
c       integration cycle.  
   25   if((istep(rve).gt.istepm(rve))
     x   .or. (tmax(rve).gt.0. .and. timer(rve).gt.tmax(rve))) then
c---------the final deformation-stress segment is finished.  Time to print
c           some final output and then quit by jumping out of the loop
c
c---------print output
          call output(rve)
c
c---------now, jump out of the main DEM loop and quit
          goto 30
        endif
c
c-------compute the new time step
        call newdt(rve)
c
c-------print the results to the B* file
        if(ipoint(rve).ge.ipts(istep(rve),rve).or.lreprt(rve))
     x  call output(rve)
c
c-------output of a "G-file" for use in the graphics post-processor OvalPlot.
        if(lplotd(rve) .and. ndim1.eq.2) then
c---------the subroutin that creates the G-file
          call plotd(rve)
          lplotd(rve) = .false.
        endif
c
c-------results of the last increment of void cell deformation
        call deldf1(rve)
c
c-------a new increment of deformation of the cell
        call deldf2(rve)
c
c-------increment the total elapsed time and the time within this stress-strain
c       control period
c
c-------increment the time step
        itime(rve) = itime(rve) + 1
c
c-------increment the time since the start of the run
        timer(rve) = timer(rve) + dt(rve)
c
c-------this timer is used the determine the end of a deformation-stress segment
c       for which igoal=70
        tclock(rve) = tclock(rve) + dt(rve)
c
c-------a separate timer for creep studies (when dt is an integration time
c       step, but dtreal is the modeled time step). An error here dtact
c       or dtfctr(rve)
c       treal(rve) = treal(rve) + dt(rve)*dtact
c
        goto 20
c
   30   continue
c
c-------'iend' is given in the input RunFile to specify whether and how the
c       final particle arrangement will be written to a file
c-------create a file containing information about the final particle
c       positions, etc.:
c
        if(iend(rve).eq.3) then
c---------for binary restart files, remove the '.txt' extension if it exists.
c         'apend' is the name of the C-type output file
          apend(rve) = 
     x      OutputFolderName(1:LEN_TRIM(OutputFolderName))//
     x      'C'//
     x      OutputRunFile
c
c---------create a (binary) restart file with the path 'apend(rve)'
          call dumpot(rve)
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine initFilesRS(rve,OutputDir,RunFile,StartFile,ErrUnit,
     x                       mdim1,mp,mpiece,version,ScrUnit,lScreen)
c
        implicit double precision(a-h,o-z)
c
        integer*2 ErrUnit, mdim1, rve, ScrUnit
        integer*4 mp,mpiece
        character*24 version
        character*400 OutputDir,RunFile,StartFile
        character*800 PathName
c
        logical lScreen
c
c-------this subroutin opens two files: an "R" file of error and warning
c       messages, and an "S" file that contains screen messages
c
c-------file for error messages, so that error (or warning) messages that 
c       are printed to the screen before halting program execution will 
c       be printed to the file
c
c-------the file's unit-number
        ErrUnit = 10 + 5*rve + 4
c
c-------the file's name
        PathName = OutputDir(1:LEN_TRIM(OutputDir))//
     x            'R'//
     x            RunFile(1:LEN_TRIM(RunFile))//
     x            '.txt'
c
        open(unit=ErrUnit, file=PathName)
c
c-------write the names of the input files to the 'error' file
        write(ErrUnit,610) RunFile(1:LEN_TRIM(RunFile)),
     x                     StartFile(1:LEN_TRIM(StartFile))
c
  610   format(a,/,a)
c
        if(lScreen) then
c---------print certain output to the screen
          ScrUnit = 6
        else
c---------print that output to an "S" file instead
c
c---------explanation of file numbers.  For each rve, we reserve 5 file
c         numbers:
c            unit = 10 + rve*5 + 0  temporary files for input and output
c            unit = 10 + rve*5 + 1  "A"-file, output
c            unit = 10 + rve*5 + 2  "B"-file, output
c            unit = 10 + rve*5 + 3  "S"-file, screen output
c            unit = 10 + rve*5 + 4  "R"-file, error output
c
c---------the file's unit-number
          ScrUnit = 10 + 5*rve + 3
c
          PathName = OutputDir(1:LEN_TRIM(OutputDir))//
     x               'S'//
     x               RunFile(1:LEN_TRIM(RunFile))//
     x               '.txt'
c
          open(unit=ScrUnit, file=PathName)
c
c    x         file=OutputDir(1:LEN_TRIM(OutputDir))//
c    x              'S'//
c    x              RunFile(1:LEN_TRIM(RunFile))//
c    x              '.txt')
        endif
c
c-------some informational messages printed to the screen
        call mssage(mdim1,mp,mpiece,version, ScrUnit)
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine readrun(rve,extent,filename)
c
c-----this subroutin reads the input files for the simulation
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      double precision rfree
      integer*2 extent,i,ibodyf,ifree,
     x          rve,nplatn,TempUnit
      integer*4 i4
c
c-----these integers will be too large for integer*2 with large assemblies
      logical lnewread
c
      character*800 filename
c
      dimension ibodyf(0:lc1),ifree(100),rfree(100)
c
c-----this subroutin gets necessary input data from two files.  The first
c     file (the RunFile) gives general particle characterists, stress-strain 
c     control parameters, input and output formats, etc.  
c     The second file gives (the StartFile) the starting configuration 
c     of the assembly, with initial particle sizes, orientations, and 
c     positions.
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      TempUnit = 10 + 5*rve + 0
c
c-----new RunFile format for DEMPLA.  Set .false. for OVAL RunFiles
      lnewread = .true.
c
c-----open the first input file (the RunFile) . . . .
      open(unit=TempUnit,file=filename,status='old')
c
c-----read the first line of the RunFile
      read(TempUnit,201) title(rve)
c
      if(lnewread) then
c-------read program parameters from the RunFile, using the Dempla
c       format
        read(TempUnit,1203)
     1              ivers(rve)
     2             ,algori
     3             ,istart(rve)
     4             ,iend(rve)
     5             ,idef(rve)
     6             ,iupdtm(rve)
     7             ,imodel(rve)
     8             ,nloop1
     9             ,iexact
     x             ,idamp(rve)
     1             ,iheat(rve)
     2             ,icoef
     3             ,ifree(13)
     4             ,ifree(14)
     5             ,ifree(15)
     6             ,ifree(16)
     7             ,ifree(17)
      else
c-------read program parameters in the RunFile, using the Oval format
        read(TempUnit,203) algori,ivers(rve),ncownt,iout(2),iout(3)
     x             ,istart(rve),iend(rve),idef(rve),iupdtm(rve)
     x             ,icirct
     x             ,imodel(rve),nplatn,nloop1
c
c-------if ivers=3 or ivers=4 (on the 3rd line of the RunFile), then the 
c       RunFile must contain an additional five lines (or more) of integer
c       input.  These are place holders for future options.  I have already 
c       found a use for ifree1, ifree2, and ifree3 (now imodel, nplatn, and
c       nloop1), so I am kluging with "ivers" to add more options
c       in the future.  When ivers=4, then the RunFile must also contain
c       an additional eight lines of floating point input (later ....)
        if(ivers(rve).eq.3 .or. ivers(rve).eq.4) then
c---------read this additional data from the RunFile
          read(TempUnit,204) iexact,isub,idamp(rve),iheat(rve),icoef
        elseif(ivers(rve).eq.0 .or. ivers(rve).eq.1) then
          iexact = 0
          isub = 0
          idamp = 1
          iheat(rve) = 0
          icoef = 0
        else
c---------oops, print an error message and stop
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of ivers must be 0, 1, 3, or 4'
          write(ScrUnit(rve),*) '* Your value:',ivers(rve)
          stop
        endif
      endif
c
c-----now read Double Precision input from the RunFile, using the Dempla
c     format
      if(lnewread) then
        read(TempUnit,1205) 
     1             kn(rve)
     2            ,kratio(rve)
     3            ,frict(rve)
     4            ,rho(rve)
     5            ,sep(rve)
     6            ,pcrit(1,rve)
     7            ,pcrit(2,rve)
     8            ,pcrit(3,rve)
     9            ,xseed(rve)
     x            ,rmsvel(rve)
     1            ,pdif(rve)
     2            ,tmax(rve)
     3            ,A_1(rve)
     4            ,dt(rve)
     5            ,palpha(rve)
     6            ,dtfctr(rve)
     7            ,rfree(17)
     8            ,rfree(18)
     9            ,rfree(19)
     x            ,rfree(20)
     1            ,rfree(21)
      else
c-------now read Double Precision input from the RunFile, using the Oval format
        read(TempUnit,205) 
     x             kn(rve),kratio(rve),frict(rve),frictw(rve)
     x             ,rho(rve),sep(rve)
     x             ,pcrit(1,rve),pcrit(2,rve),pcrit(3,rve)
     x             ,xseed(rve),rmsvel(rve)
     x             ,pdif(rve),tmax(rve),A_1(rve),dt(rve)
c
c-----if ivers=4, then read an additional eight lines of floating point input.
c     See the explanation given above.
        if(ivers(rve).eq.4) then
c-------read this additional data from the RunFile
          read(TempUnit,206) gravty(1), gravty(2), gravty(3), 
     x                rfree(4), rfree(5), rfree(6), rfree(7), rfree(8)
        else
c---------otherwise, give default (zero) values to these variables
          gravty(1) = 0.
          gravty(2) = 0.
          gravty(3) = 0.
          rfree(4) = 0.
          rfree(5) = 0.
          rfree(6) = 0.
          rfree(7) = 0.
          rfree(8) = 0.
        endif
c
c-----when Jager's generalized contact profile is being used (when imodel = 9,
c       designating a solid of revolution of form z = A_alpha * r ^ alpha),
c       we must read the power alpha = palpha
c       if(imodel(rve).eq.9) then
          read(TempUnit,207) palpha(rve)
c       elseif(imodel(rve).eq.10) then
c         read(TempUnit,207) dtfctr(rve)
c       endif
      endif
c
      i4 = 1
c
      if(extent.eq.1) then
        goto 200
      endif
c
c-----read the stress-strain path, as contained in a series of lines at 
c     the end of the RunFile that describes the manner in which the 
c     deformations and stresses are to be controlled.
      read(TempUnit,210,end=12)
c
c-----read a single step of the deformation-stress control data.  Repeat
c     until the end of the file is encountered
      if(lnewread) then
c-------using the Dempla format
  110     read(TempUnit,1211,end=12) icontr(i4,rve)
     x      ,(defrat(j,i4,rve),j=1,6)
     x      ,igoal(i4,rve)
     x      ,finalv(i4,rve),ipts(i4,rve),idump(i4,rve)
     x      ,imicro(i4,rve)
     x      ,defdot(i4,rve),ipts2(i4,rve),iplot(i4,rve)
c
c-------advance the segment counter
          i4 = i4 + 1
        goto 110
      else
c-------using the Oval format
   10   read(TempUnit,211,end=12) icontr(i4,rve)
     x    ,(defrat(j,i4,rve),j=1,6)
     x    ,igoal(i4,rve),krotat(i4,rve)
     x    ,finalv(i4,rve),ipts(i4,rve),idump(i4,rve)
     x    ,iflexc(i4),imicro(i4,rve)
     x    ,ibodyf(i4),defdot(i4,rve),ipts2(i4,rve),iplot(i4,rve)
c
c-------advance the segment counter
        i4 = i4 + 1
        goto 10
      endif
c
  200 continue
c
c-----In general, the file unit=TempUnit is for temporary input or output
c     (within a single subroutin), and it is closed immediately after its use
   12 close(unit=TempUnit)
c
c-----the number of input deformation-stress control periods, istepm
      istepm(rve) = i4 - 1
c
c-----check for errors within the input values of the RunFile
      call check1(rve,extent)
c
c-----check whether the parameter lc1 is exceeded (see the 
c     "param-dempla-0.2.2.f" file).  lc1 is the maximum number 
c     of deformation-stress control steps.  This parameter is 
c     used for dimensioning various arrays.
      if(istepm(rve).gt.lc1) then
        write(ScrUnit(rve),*) ' istepm exceeds lc1 in subroutin readit'
        write(ScrUnit(rve),*) 
     x   ' Too many stress-strain control periods in the input file'
        write(ScrUnit(rve),*)  'Try changing lc1 and recompiling?'
        stop
      endif
c
  201 format(a72)
  203 format(12(i16,/),i16)
 1203 format(16(i16,/),i16)
  204 format(4(i16,/),i16)
  205 format(14(f16.7,/),f16.7)
 1205 format(20(f16.7,/),f16.7)
  206 format( 7(f16.7,/),f16.7)
  207 format(f16.7)
  210 format(////)
  211 format(i6,6(1x,f9.6),1x,i2,1x,i1,1x,f9.6,1x,i4,1x,i1,1x,i2,1x,i1,
     x       1x,i2,1x,f6.5,1x,i4,1x,i2)
 1211 format(i6,6(1x,f9.6),1x,i2,1x,f9.6,1x,i4,1x,i1,1x,i1,
     x       1x,f6.5,1x,i4,1x,i2)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine check1(rve,extent)
c
c-------check the input RunFile and issue errors/warnings
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 extent,rve
        integer*4 i4a
c
c-------check the input value of 'algori'
        if(algori.eq.0) then
          algori = 1
        elseif(.not.(     algori.eq.1 
     x               .or. algori.eq.3)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of algori must be 1 or 3'
          write(ScrUnit(rve),*) '* Your value:',algori
          stop
        endif
c
c-------check the input value of 'istart'
        if(.not.(     istart(rve).eq.1
     x           .or. istart(rve).eq.2
     x           .or. istart(rve).eq.3)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of istart must be 1, 2, or 3'
          write(ScrUnit(rve),*) '* Your value:',istart(rve)
          stop
        endif
c
c-------check the input value of 'iend' and 'istart'
        if(.not.(     iend(rve).eq.0
     x           .or. iend(rve).eq.1
     x           .or. iend(rve).eq.3
     x           .or. iend(rve).eq.4)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of iend must be 0, 1, 3, or 4'
          write(ScrUnit(rve),*) '* Your value:',iend(rve)
          stop
        endif
c
c-------check the input value of 'idef'
        if(.not.(idef(rve).ge.0 .and. idef(rve).le.1)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Warning ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of idef should be 0 or 1'
          write(ScrUnit(rve),*) '* Your value:',idef(rve)
          stop
        endif
c
c-------check the input value of 'iupdtm'
        if(.not.(iupdtm(rve).gt.0)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of iupdtm must be greater than 0'
          write(ScrUnit(rve),*) '* Your value:',iupdtm(rve)
          stop
        endif
c
c-------check the input value of 'idamp' for conical contact profiles
        if(.not.(idamp(rve).eq.0 .or. idamp(rve).eq.1
     x           .or. idamp(rve).eq.2
     x           .or. idamp(rve).eq.3)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of idamp must be 0, 1, 2, or 3'
          write(ScrUnit(rve),*) '* Your value:',idamp(rve)
          stop
        endif
c
        if(idamp(rve).eq.0) then
          idamp(rve) = 1
        elseif(idamp(rve).eq.3 .and. iexact.eq.1) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* idamp=3 is incompatible with iexact=1'
          write(ScrUnit(rve),*) '* Your values:', idamp(rve), iexact
          stop
        endif
c
c-------check the input value of 'iupdtm'
        if(.not.(imodel(rve).ge.0 .and. imodel(rve).le.10)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of imodel must be between 0 and 8'
          write(ScrUnit(rve),*) '* Your value:',imodel(rve)
          stop
        endif
c
c-------check the input value of 'A_1' for conical contact profiles
        if(imodel(rve).eq.7) then
          if(.not.(A_1(rve).gt.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x      '* The input value of A_1 must be greater than 0'
            write(ScrUnit(rve),*) '* Your value:',A_1(rve)
            stop
          endif
        endif
c
c-------check the input values of 'A_1' and 'palpha' for general 
c       contact profiles
        if(imodel(rve).eq.9) then
          if(.not.(A_1(rve).gt.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x      '* The input value of A_1 must be greater than 0'
            write(ScrUnit(rve),*) '* Your value:',A_1(rve)
            stop
          endif
c
          if(.not.(palpha(rve).gt.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The input value of palpha must be greater than 0'
            write(ScrUnit(rve),*) '* Your value:',palpha(rve)
            stop
          endif
        endif
c
c-------check the input value of 'dtfctr' for conical contact profiles
        if(imodel(rve).eq.10) then
          if(.not.(dtfctr(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The input value of dtfctr must be greater than 0'
            write(ScrUnit(rve),*) '* Your value:',dtfctr(rve)
            stop
          endif
        endif
c
c-------check the 'iporo' value, which specifies the poroelastic model
        if(.not.(     iporo(rve).eq.0 .or. iporo(rve).eq.1 
     x           .or. iporo(rve).eq.2 .or. iporo(rve).eq.3
     x           .or. iporo(rve).eq.4)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error in RunFile ****.'
          write(ScrUnit(rve),*) 
     x      '* The input value of iporo must be between 0 and 3'
          write(ScrUnit(rve),*) '* Your value:',iporo(rve)
          stop
        endif
c
c-------check the input value of 'kn'
        if(.not.(kn(rve).gt.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of kn must be greater than 0.'
          write(ScrUnit(rve),*) '* Your value:',kn(rve)
          stop
        endif
c
c-------check the input value of 'kratio'
        if(.not.(kratio(rve).ge.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of kratio must be >= 0.'
          write(ScrUnit(rve),*) '* Your value:',kratio(rve)
          stop
        elseif(kratio(rve).eq.0.) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Warning ****'
          write(ScrUnit(rve),*)
     x      '* You have specified frictionless contacts(kratio=0)'
        endif
c
c-------check the input value of 'frict' and 'kratio'
        if(.not.(frict(rve).ge.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of frict must be >= 0.'
          write(ScrUnit(rve),*) '* Your value:',frict(rve)
          stop
        elseif(kratio(rve).eq.0.) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Warning ****'
          write(ScrUnit(rve),*)
     x      '* You have specified frictionless contacts(frict=0)'
        endif
c
c-------check the input value of 'rho'
        if(rho(rve).le.0. .and. ScrUnit(rve).ne.0) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) ' Warning: Input value of rho was 0.',
     x            ' A mass will be automatically assigned.'
        endif
c
c-------check the input value of 'sep'
        if(.not.(sep(rve).gt.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of sep must be greater than 0.'
          write(ScrUnit(rve),*) '* Your value:',sep(rve)
          stop
        endif
c
c-------check the input value of 'xseed'
        if(.not.(xseed(rve).ge.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of xseed must be >= 0.'
          write(ScrUnit(rve),*) '* Your value:',xseed(rve)
          stop
        endif
c
c-------check the input value of 'rmsvel'
        if(.not.(rmsvel(rve).ge.0.)) then
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*)
     x      '* The input value of rmsvel must be >= 0.'
          write(ScrUnit(rve),*) '* Your value:',rmsvel(rve)
          stop
        elseif(rmsvel(rve).gt.0.) then
c         write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*)
     x      ' Warning: Particles will be assigned initial',
     x            ' velocities, since'
          write(ScrUnit(rve),*)
     x      '          input value of rmsvel was > 0.'
        endif
c
        if(dt(rve).le.0. .and. ScrUnit(rve).ne.0) then
c         write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) ' Warning: Input value of dt .le. 0.',
     x            ' A time step will be automatically assigned.'
        endif
c
c-------check poroelastic parameters
        if(iporo(rve).eq.1 
     x     .or. iporo(rve).eq.2 .or. iporo(rve).eq.3
     x     .or. iporo(rve).eq.4) then
c---------the bulk modulus of grains
          if(.not.(K_s(rve).gt.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of K_s must be > 0.'
            write(ScrUnit(rve),*) '* Your value:',K_s(rve)
            stop
          endif
        endif
c
c-------check poroelastic parameters
        if(iporo(rve).eq.1
     x     .or. iporo(rve).eq.2 .or. iporo(rve).eq.3) then
c---------the bulk modulus of the pore fluid (when iporo(rve)=1 or 2,
c         of the liquid phase)
          if(.not.(K_f(rve).gt.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of K_f must be > 0.'
            write(ScrUnit(rve),*) '* Your value:',K_f(rve)
            stop
          endif
        endif
c
c-------check poroelastic parameters
        if(iporo(rve).eq.4) then
c---------the saturation (volume fraction of liquid phase relative
c         to the pore volume)
          if(.not.(S_o(rve).eq.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* Warning.  The input value of S_o must be ==0'
            write(ScrUnit(rve),*) '* Your value:',S_o(rve)
            write(ScrUnit(rve),*)
     x          '* Value of S_o will be changed to 0'
            S_o(rve) = 0.
          endif
c
c---------the reference atmospheric pressure.  Pore fluid pressures
c         are relative to this atmospheric pressure.
          if(.not.(p_atm(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of p_atm must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',p_atm(rve)
            stop
          endif
        endif
c
c-------check poroelastic parameters
        if(     iporo(rve).eq.2 .or. iporo(rve).eq.3
     x     .or. iporo(rve).eq.4) then
c---------the saturation (volume fraction of liquid phase relative
c         to the pore volume)
          if(.not.(S_o(rve).ge.0. .and. S_o(rve).le.1.d0+1.d-16)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of S_o must be >=0 and <=1'
            write(ScrUnit(rve),*) '* Your value:',S_o(rve)
            stop
          endif
c
c---------the reference atmospheric pressure.  Pore fluid pressures
c         are relative to this atmospheric pressure.
          if(.not.(p_atm(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of p_atm must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',p_atm(rve)
            stop
          endif
        endif
c
c-------check poroelastic parameters
        if(iporo(rve).eq.2 .or. iporo(rve).eq.3) then
c---------the dimensionless Henrys coefficient
          if(.not.(Hcc(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of Hcc must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',Hcc(rve)
            stop
          endif
        endif
c
c-------check poroelastic parameters
        if(iporo(rve).eq.3) then
c---------the surface tension of pore bubbles
          if(.not.(gamm(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of gamm must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',gamm(rve)
            stop
          endif
c
c---------the (uniform) diameter of pore bubbles
          if(.not.(D_o(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of D_o must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',D_o(rve)
            stop
          endif
c
c---------the number/density of pore bubbles
          if(.not.(N_o(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The input value of N_o must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',N_o(rve)
            stop
          endif
c
c---------the vapor pressure of liquid phase
          if(.not.(p_vap(rve).ge.0.)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error in RunFile ****.'
            write(ScrUnit(rve),*) 
     x          '* The absolute vapor pressure p_vap  must be >=0.'
            write(ScrUnit(rve),*) '* Your value:',p_vap(rve)
            stop
          endif
c
c---------when unsaturated, must give either N_o or D_o
          if(S_o(rve).lt.1.d0) then
            if(D_o(rve).le.0. .and. N_o(rve).le.0.) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error in RunFile ****.'
              write(ScrUnit(rve),*) 
     x          '* When S_o<0, then either N_o or D_o must have'
              write(ScrUnit(rve),*) '* a non-zero value.'
              write(ScrUnit(rve),*) '* Your value, S_o:',S_o(rve)
              write(ScrUnit(rve),*) '* Your value, N_o:',N_o(rve)
              write(ScrUnit(rve),*) '* Your value, D_o:',D_o(rve)
              stop
            endif
          endif
c
c---------when saturated and cavitation is allowed, must give non-zero N_o
          if(S_o(rve).gt.(1.d0 - 1.0d-16) .and. u_wcav(rve).ne.0.) then
            if(N_o(rve).le.0.) then
              print *,' '
              print *,'**** Error in RunFile ****.'
              print *,'* When S_o=0 and u_wcav.ne.0, then N_o '
              print *,'* must have a non-zero value.'
              print *,'* Your value, S_o:',S_o(rve)
              print *,'* Your value, u_wcav:',u_wcav(rve)
              print *,'* Your value, N_o:',N_o(rve)
              stop
            endif
          endif
        endif
c
        if(extent.eq.1) then
c---------when reading the RunFile, we had only read the preface information,
c         but not the information on the loading steps.  Skip the checking
c         of this information
          goto 200
        endif
c
c-------Check all of the input lines of deformation control segments
        do 10 i4a = 1,istepm(rve)
c---------check the input value of 'icontr'. First, separate the 6 digits 
c         of the input "icontr" values
          i1 = icontr(i4a,rve)/100000
          i2 = mod(icontr(i4a,rve),100000)/10000
          i3 = mod(icontr(i4a,rve),10000)/1000
          i4 = mod(icontr(i4a,rve),1000)/100
          i5 = mod(icontr(i4a,rve),100)/10
          i6 = mod(icontr(i4a,rve),10)
c
c---------the values must be either 0's or 1's
          if(.not.(i1.eq.0 .or. i1.eq.1 .or. i1.eq.2 .or. i1.eq.3 .or.
     x             i1.eq.4 .or. i1.eq.5 .or. i1.eq.6 .or. i1.eq.7) .or.
     x       .not.(i2.eq.0 .or. i2.eq.1 .or. i2.eq.2 .or. i2.eq.3 .or. 
     x             i2.eq.4 .or. i2.eq.5 .or. i1.eq.6 .or. i1.eq.7) .or.
     x       .not.(i3.eq.0 .or. i3.eq.1 .or. i3.eq.2 .or. i3.eq.3 .or. 
     x             i3.eq.4 .or. i3.eq.5) .or.
     x       .not.(i4.eq.0 .or. i4.eq.1 .or. i4.eq.3 .or. i4.eq.5) .or.
     x       .not.(i5.eq.0 .or. i5.eq.1 .or. i5.eq.5) .or.
     x       .not.(i6.eq.0 .or. i6.eq.1 .or. i6.eq.5) ) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x      '* The input value of icontr must be composed'
            write(ScrUnit(rve),*) '*  of zeros and ones'
            write(ScrUnit(rve),*) '* Your value:',icontr(i4a,rve)
            stop
          endif
c
c---------check the input value of 'igoal'.  First, separate the 
c         two digits of the input "igoal" values
          i1 = igoal(i4a,rve)/10
          i2 = mod(igoal(i4a,rve),10)
          if(.not.(i1.ge.1 .and. i1.le.7)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The first of two digits of igoal must be 1 to 7'
            write(ScrUnit(rve),*)
     x        '* Your value of igoal:',igoal(i4a,rve)
            stop
          endif
c
          if(i1.ne.7 .and. .not.(i2.eq.0 .or. i2.eq.1)) then
            if(i1.ne.1 .and. i1.ne.2 .and. i1.ne.3) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error ****.'
              write(ScrUnit(rve),*) 
     x          '* The second of two digits of igoal must be 0 or 1'
              write(ScrUnit(rve),*) '* Your value:',igoal(i4a,rve)
              stop
            elseif(i2.ne.4) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error ****.'
              write(ScrUnit(rve),*) 
     x          '* The second of two digits of igoal must be 0, 1, or 4'
              write(ScrUnit(rve),*) '* Your value:',igoal(i4a,rve)
              stop
            endif
          endif
c
c---------check the input value of 'finalv'
          if(i1.eq.7 .and. finalv(i4a,rve).le.0.) then
            if(finalv(i4a,rve).le.0.) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error ****.'
              write(ScrUnit(rve),*)
     x          '* When igoal = 70, 71, etc. finalv must be > 0'
              write(ScrUnit(rve),*) '* Your value:',finalv(i4a,rve)
              stop
            elseif(finalv(i4a,rve).lt.0.999*dt(rve)) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Warning ****.'
              write(ScrUnit(rve),*)
     x          '* When igoal=70, 71, etc. finalv should be >=dt'
              write(ScrUnit(rve),*)
     x          '* Your value of finalv:',finalv(i4a,rve)
              write(ScrUnit(rve),*) '* Your value of dt:',dt(rve)
            endif
          endif
c
c---------check the input value of 'ipts'
          if(.not.(ipts(i4a,rve).ge.1)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The input value of ipts must be  > 0'
            write(ScrUnit(rve),*) '* Your value:',ipts(i4a,rve)
            stop
          endif
c
c---------check the input value of 'idump'
          if(.not.(idump(i4a,rve).ge.0 .and. idump(i4a,rve).le.6)) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The input value of idump must be between 0 or 6'
            write(ScrUnit(rve),*) '* Your value:',idump(i4a,rve)
            stop
          endif
   10   continue
c
  200   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine check2(rve)
c-------check the input StartFile for errors/warnings
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
        integer*4 i4a
        double precision lim1,lim2,small
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain
c
        small = 1.d-15
c
c-------check the input value of 'iplot'
        do 10 i4a = 1,istepm(rve)
          if(iplot(i4a,rve).eq.1 .and. ndim1.ne.2) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Warning ****.'
            write(ScrUnit(rve),*)
     x        '* Cannot create G-files for 3D assemblies'
            write(ScrUnit(rve),*)
     x        '* Your value of iplot:',iplot(i4a,rve)
          endif
   10   continue
c
        if(loval(rve) .or. lovoid(rve)) then
c---------check input values of the 'beta' angle and the aspect ratio of ovoids
          if(beta(rve).le.0.d0 .or. beta(rve).ge.90.) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error ****.'
            write(ScrUnit(rve),*)
     x        '* The input value of beta (ovoid geometry) ',
     x        'must be >0 and <90'
            write(ScrUnit(rve),*) '* Your value:',beta(rve)
            stop
          endif
c
c---------convert degrees to radians
          betar(rve) = beta(rve) * pi / 180.d0
c
c---------these are the lower and upper limits of an oval's (or ovoid's)
c         aspect ratio
          lim1 = (1.d0 - cos(betar(rve))) / sin(betar(rve))
          lim2 = cos(betar(rve)) / (1.d0 - sin(betar(rve)))
c
c---------check the 'aspect' ratio of each particle
          do 20 igrain=1,np(rve)
            if(aspect(igrain,rve).le.0.) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error ****.'
              write(ScrUnit(rve),*)
     x          '* The input values of oval or ovoid aspect ',
     x          'ratios must be >0'
              write(ScrUnit(rve),*) '* Your value:',aspect(igrain,rve)
              stop
            elseif(aspect(igrain,rve).lt.lim1 .or. 
     x             aspect(igrain,rve).gt.lim2) then
              write(ScrUnit(rve),*) ' '
              write(ScrUnit(rve),*) '**** Error ****.'
              write(ScrUnit(rve),*)
     x          '* An input value of an oval or ovoid aspect',
     x          ' ratio'
              write(ScrUnit(rve),*)
     x          '* can not be attained with your value of beta.'
              write(ScrUnit(rve),*)
     x          '* Your value:',aspect(igrain,rve),
     x          '  for particle '
              write(ScrUnit(rve),*) 'number',igrain
              stop
            endif
   20     continue
c
        elseif(lnobby(rve)) then
c---------check input values of nobby particles.  The number of satellite
c         circles must be no less than zero
          if(nobs(rve).lt.0) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error *********.'
            write(ScrUnit(rve),*)
     x        '* The input value of nobs (nobby geometry) must be >=0'
            write(ScrUnit(rve),*) '* Your value:',nobs(rve)
            stop
          endif
c
c---------the radius of the middle circles 'cenrad' and satellite
c         circles must be greater than zero
          if(cenrad(rve).le.0. .or. satrad(rve).le.0.) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error *********.'
            write(ScrUnit(rve),*)
     x        '* The input values of cenrad and satrad must be >0'
            write(ScrUnit(rve),*)
     x        '* Your values:',cenrad(rve), satrad(rve)
            stop
          endif
c
        elseif(lbumpy(rve)) then
c---------check input values of bumpy particles.  Check the number of
c         satellite spheres
          if(nbumps(rve).lt.0) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error *********.'
            write(ScrUnit(rve),*)
     x        '* The input value of nbumps (bumpy geometry) must be >=0'
            write(ScrUnit(rve),*) '* Your value:',nbumps(rve)
            stop
          elseif(nbumps(rve).gt.mbumps) then
c-----------'mbumps' is a parameter within the 'common' file
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error *********.'
            write(ScrUnit(rve),*)
     x        '* The input value of nbumps (bumpy geometry) ',
     x        'must be <= mbumps (in the param-dempla-0.2.2.f file)'
            write(ScrUnit(rve),*) '* Your value nbumps:',nbumps(rve)
            write(ScrUnit(rve),*)
     x        '* Value mbumps in common file:',mbumps
            stop
          endif
c
c---------the radii of the middle sphere 'cenrad' and satellite
c         spheres 'satrad' must be greater than zero.  The radius of
c         the circumscribing sphere must be greater than zero.
          if(cenrad(rve).lt.0. .or. satrad(rve).lt.0.
     x       .or. cirrad(rve).lt.0.) then
            write(ScrUnit(rve),*) ' '
            write(ScrUnit(rve),*) '**** Error *********.'
            write(ScrUnit(rve),*)
     x        '* The input values of cenrad, satrad, and cirrad ',
     x              'must be >=0'
            write(ScrUnit(rve),*) '* Your values:',
     x              cenrad(rve), satrad(rve), cirrad(rve)
            stop
          endif
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine inheat(rve)
c
c-------read basic input parameters on temperature-dependence of
c       the friction and thermal characteristics of the particles
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 ihvers,rve,TempUnit
        integer*4 igrain
c
c-------explanation of file numbers.  For each rve, we reserve 5 file
c       numbers:
c          unit = 10 + rve*5 + 0  temporary files for input and output
c          unit = 10 + rve*5 + 1  "A"-file, output
c          unit = 10 + rve*5 + 2  "B"-file, output
c          unit = 10 + rve*5 + 3  "S"-file, screen output
c          unit = 10 + rve*5 + 4  "R"-file, error output
c
        TempUnit = 10 + 5*rve + 0
c
c-------name of the text-format file that contains information on
c       temperature-dependence of the friction characteristics
        print *,' '
        print *,' Name of input file for thermal characteristics:'
        read (*,600) file3(rve)
  600   format(a160)
c
c
c-------open the thermal input file . . . .
        open(unit=TempUnit,file=file3(rve),status='old')
c
c-------read the version number for the file (metadata)
        read(TempUnit,201) ihvers
c
c-------model for the thermal characteristics
        read(TempUnit,201) hmodel(rve)
c
        if(ihvers.eq.100 .and. hmodel(rve).eq.1) then
c---------ambient (initial) temparature
          read(TempUnit,210) ambtmp(rve)
c
c---------specific heat
          read(TempUnit,210) spheat(rve)
c
c---------linear dependence of temperature on the friction coefficient.
c         If the coefficient decreases with increasing temperature, the 
c         value should be negative.
          read(TempUnit,210) tdepf(rve)
c
c---------the density of the particle material (for use in applying
c         the specific heat)
          read(TempUnit,210) h_rho(rve)
c
c---------minimum friction coefficient
          read(TempUnit,210) frictm(rve)
        endif
c
        do 10 igrain=1,np(rve)
          tempr(igrain,rve) = ambtmp(rve)
   10   continue
c
        if(tdepf(rve).ne.0. .and. imodel(rve).ne.0) then
          write(ScrUnit(rve),*) 
     x      '  ERROR. Temperature dependence is only permitted'
          write(ScrUnit(rve),*) '  with a simple linear contact model.'
        endif
c
        close(unit=TempUnit)
c
  201   format(i72)
  210   format(f20.7)
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init(rve)
c
c-----This subroutin performs many initialization tasks before the
c     DEM algorithm can be entered
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 igrain,inorm,i4a,i4b
      integer*4 listk, listJ, nboxs, ngrid, nlist, nlist2, nlist3
      integer*2 iremov,islip2,nnnear,rve
c
      double precision area1,areao,areat,
     x                 c1,coef4,coef5,coef7,csbeta,
     x                 defb,degrad,delx,dtfact,dw,dWidth,g1,
     x                 inert1,inert2,inert,inertt,
     x                 Ix,Iy,Ixx,Ixxtot,Iyy,Izz,Ixy,Ixz,Iyz,
     x                 Izztot,
     x                 massi,masst,mentum,mnti,
     x                 p_1,p_2,pih,piq,Qp_new,Qp_old,
     x                 r_1,r_2,rad1,rad2,rdiff,rhofact,rmean,
     x                 rotfac,rr,rr2,rrcs,rrrr,rratio,
     x                 sumvth,third,t1,t2,tan_b,tol_i,
     x                 Vf,vmnt2p,voltot,Voxel,Width,
     x                 xImean
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
      real randof
c
      logical lcase1,lcase2,lcase3,lcase4,lInsid,lsymm
c
      dimension defb(3,3),dw(3),
     x          Ix(8),Iy(6),Qp_new(4),Qp_old(4),sumvth(3),Vf(4)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----initialize the time step, itime
      itime(rve) = 0
c
c-----intitialize time, t
      timer(rve) = 0.
c
c-----is this a 3D simulation?
      l3d = ndim1.eq.3
c
c-----logical flags directing output to different types of files
c
c-----the standard A* and B* output formats will be produced
      lout(1) = .true.
c
c-----additional points for stress servo-control
      npnts_xtra = 0
c
c-----whether to override the possiblity of proportional control
      lovrid = .false.
c
c-----other output formats (at present, these format options are not supported)
c     lout(2) = mod(iout(2),10).eq.1
      lout(2) = .false.
c     lout(3) = mod(iout(3),10).eq.1
      lout(3) = .false.
c     lout(4) = mod(iout(2),100)/10 .eq. 1
      lout(4) = .false.
c     lout(9) = mod(iout(2),100)/10 .eq. 3
      lout(9) = .false.
c-----give output showing higer-order stresses
c     lout(5) = mod(iout(2),1000)/100 .eq. 1
      lout(5) = .false.
c-----give output for number of contacts of non-convex particles
c     lout(6) = mod(iout(2),10).eq.2
      lout(6) = .false.
      lout(7) = mod(iout(2),100)/10 .eq. 2
      lout(7) = .false.
c-----Complete deformation/stress information for 2D assemblies
      lout(8) = mod(iout(2),1000)/100 .eq. 2
      lout(8) = .false.
c
      if(algori.eq.3) then
c-----the relaxation looping will end with the average force imbalance on
c     the particles is reduced to a value less than chimax
        algori = 2
        read *,chimax(rve)
      else
        chimax(rve) = 0.01d0
      endif
c
c-----whether to use a poroelastic analysis
      lporo(rve) = iporo(rve).eq.1
     x             .or. iporo(rve).eq.2
     x             .or. iporo(rve).eq.3
     x             .or. iporo(rve).eq.4
c
c-----use periodic boundaries throughout this program.  The program
c     does not support flexible or periodic boundaries
      nbound(1) = 0
      nbound(2) = 0
      nbound(3) = 0
c
c-----whether to collect initial variables of performance data that may be
c     used to adjust the DEM strain increment in subroutin pla
      ldat(rve) = .false.
c
c     ndat(rve) = 0
c     ovrdat(rve) = 0.
c     kmdat(rve) = 0.
c     chidat(rve) = 0.
c     pdat(rve) = 0.
c     massdat(rve) = 0.
c
c----------------------------------------------------------------------
c     initial cell configuration
c
c-----initialize deformations and related parameters.  If the run is being
c     started from a restart file, the deformations are passed with the file
c     and are not initialized here.
c
      if(istart(rve).le.2) then
c-------if the run does NOT begin with input from a (binary) "restart" file,
c       then the input files simply gives particle sizes, positions, and 
c       orientations.  Several variables must be initialized . . .
c
        if(ndim1.eq.2) then
c---------for 2D problems, set the 3rd assembly width = 1.0
          xcell(3,3,rve) = 1.d0
        endif
c
c-------cell (assembly) dimensions and related parameters
        do 10 i = 1,3
c---------initialize the type of boundaries as periodic boundaries
          do 12 j = 1,3
c
c-----------the incremental change in assembly width
            dxcell(i,j,rve) = 0.
c
c-----------the average (mean-field) deformation gradient
            def(i,j,rve) = 0.
c
c-----------note that, unlike the deformation gradient, defp() includes
c           storage of the mean translation of the entire assembly.  When
c           periodic boundaries are not being used, defp is computed as
c           a best-fit deformation gradient
            defp(i,j) = 0.
c
c-----------the average (Eulerian) velocity gradient * dt
            ddefme(i,j,rve) = 0.
   12     continue
c
c---------the mean-field rotations (about the x1, x2, and x3 axes)
          ddefh(i,rve) = 0.
c
c---------diagonal elements of the (mean field) deformation gradient
          def(i,i,rve) = 1.d0
          defp(i,i) = 1.d0
   10   continue
c
c-------"defw" is net inflow of pore fluid per unit of original volume:
c       the difference between the Jacobian of the bulk (skeleton) 
c       deformation gradient and the Jacobian of the deformation 
c       gradient of the pore fluid.  When multiplied by the original 
c       porosity, "defw" is the volumetric inflow of fluid per unit 
c       of original volume.  That is, it is a "discharge" inflow 
c       (instead of a "seepage" inflow), referenced to the original 
c       volume.  For undrained conditions, "defw" is zero.
        defw(rve) = 0.
c
c-------pore fluid pressure.  Note that with the iporo=3 bubble model, 
c       pfluid is the water pressure (liquid phase of the pore fluid), 
c       rather than the air pressure inside of bubbles
        if(lporo(rve)) then
          pfluid(rve) = p_o(rve)
        endif
c
c-------the previous bubble diameter
        if(iporo(rve).eq.1) then
          S_now(rve) = 1.d0
        elseif(iporo(rve).eq.3) then
          if(D_o(rve).gt.0.) then
            Dlast(rve) = D_o(rve)
          else
            Dlast(rve) = 
     x        ((1.d0 - S_o(rve))/(N_o(rve)*pi/6.d0))**(1.d0/3.d0)
          endif
        endif
c
c-------initialize these "shear" widths.  Note that, for example,
c       the width xcell(1,2) will not be zero when the the assembly is
c       being sheared in the 1-2 plane (i.e. when the deformation gradient
c       F_12 is not zero).  The corresponding shear width xcell(2,1) will,
c       however, ALWAYS be zero.
        xcell(2,1,rve) = 0.
        xcell(3,1,rve) = 0.
        xcell(3,2,rve) = 0.
c
c-------the total number of linked list updates (note: the 2-byte nupdat
c       was replaced by the 4-byte nupdat4 in March 2013)
        nupdat(rve) = 0
        nupdat4(rve) = 0
c
c-------will body forces be applied to deform cell into S-shape?
        lbodyf = .false.
c
c-------when body forces are applied, a parameter used to select particles 
c       that will be restrained from moving
c       ntag = 0
c
c-------no side platens in this version
        nsplin = 0
        ilpavg = 0
c
c-------the cumulative the energy expended in frictional sliding
        slidet(rve) = 0.
        slidet_alt(rve) = 0.
c
c-------the cumulative work done by internal stress
        work1t(rve) = 0.
c
c-------the cumulative work done by external body forces
        work2t = 0.
c
c-------the cumulative energy expended in viscous body and contact damping
        viscbt(rve) = 0.
        viscct(rve) = 0.
c
c-------the elastic(potential) energy stored in the normal and
c       tangential contact springs
        pnrgy1(rve) = 0.
        pnrgy2(rve) = 0.
c
c-------pointer to the top of the linked list for information on particle 
c       pairs that are known to be touching
        ipt4(rve) = 0
c
c-------number of vacant locations in the linked list for contact forces
        ihole(mrve) = 0
c
c-------set the initial velocities of all particle to zero.  Again, this
c       is only the case when istart = 1 or 2 (not for restart files).
        do 60 igrain = 1,np(rve)
          do 62 j = 1,ndim1
c-----------the velocity mid-way between two time steps
            vh(j,igrain,rve) = 0.
c-----------incremental change in the particle locations
            dx(j,igrain,rve) = 0.
   62     continue
c
          do 63 j = ndim2,3
c-----------the angular velocity mid-way between two time steps
            vhth(j,igrain,rve) = 0.
c-----------incremental change in the particle (angular) orientation
            dth(j,igrain,rve) = 0.
            ddth(j,igrain,rve) = 0.
   63     continue
   60   continue
c
c-------assume periodic boundaries
        lwalls = .false.
c
c-------a Hertz-Mindlin model for contact force (initialize now, reset later)
        lHertz(rve) = .false.
c
c-------a Jager generalization of Hertz-Mindlin contacts (initialize now, 
c       reset later). lJager (spherical) and lJagr2 (conical) surface profiles.
c       lJagr3 uses a spherical contact, but includes rolling effects
        lJager(rve) = .false.
        lJagr2(rve) = .false.
        lJagr3(rve) = .false.
        lJagr4(rve) = .false.
c
c-------for linear-frictional contacts, the old normal forces have
c       not yet been computed
        linitf(rve) = .true.
      endif
c
c-----for toggling in subroutin lister
      linitc(rve) = .false.
c
c-----the linear-frictional algorthim: (0) older model, (1) newer model
      ifrctnl(rve) = 0
c
c-----------------------------------------------------------------------
c
c-----determine the inverse of the matrix 'xcell' of periodic cell dimensions.
c     The inverse matrix, 'xcelli', will later be used to whether contacts
c     occur between image particles that straddle the pariodic boundaries.
      n = 3
      call definv(xcell,xcelli,n,rve,mrve)
c
c-----------------------------------------------------------------------
c
c-----subroutin 'deform' computes the average displacements, deformation
c     gradient and higher gradients for individual 'layers' within the
c     unit cell of particles.  It is used (ihat .ne. 0) when either 
c     such output is requested or with the body will be deformed into 
c     an S-shape
c
c-----will subroutin 'deform' be used?
      ldefrm = .false.
c   
c----------------------------------------------------------
c     This code is used when the assembly is sheared into an "S" shape. 
c     Otherwise, it is of no consequence.
c
c-----If we are NOT starting from "restart" file (a "C" file)...
      if(istart(rve).le.2) then
        ioutd = 0
      endif
c
c----------------------------------------------------------------------
c
c-----compute the volume within the periodic boundaries, simply the
c     product of the height, width and depth
      vcell(rve) = 1.d0
      do 119 i = 1,ndim1
        vcell(rve) = vcell(rve)*xcell(i,i,rve)*xcelle(i,rve)
  119 continue
c
c-----the inverse of the assembly's volume
      vcelli(rve) = 1.d0 / vcell(rve)
c
c-----when the simulation is NOT being started with a binary restart file ...
      if(istart(rve).le.2) then
        vcell0(rve) = vcell(rve)
c
c-------the initial assembly volume, for use as a reference volume when
c       calculating energy components per unit of assembly volume
        vcello(rve) = vcell(rve)
      endif
c
c-----NOTE: only values of idef=0 are currently supported!
c
c-----if starting from a restart file, you must specify whether to report
c     the deformations with respect to some initial configuration:
c       idef = 0 : deformations are relative to the "original" assembly.
c                  When starting from an "D-file", the original assembly
c                  is undeformed.  When starting from a "C-file", the
c                  original assembly is that of the previous run.  So if
c                  idef=0 for a series of runs, each starting from a
c                  "C-file", then the original assembly is the assembly
c                  in the original "D-file".  Exception, if some of the
c                  intervening files have idef=1, and the current run
c                  has idef=0, then the reference assembly is that
c                  at the start of the most recent idef=1 run
c       idef = 1 : initial deformations are assumed to be zero at the start of
c                  this run.  Note that the deformation increments are
c                  relative to this initial zero-deformation state.
c                  This should only be used when the initial deformation
c                  stage is a zero-deformation stage.
c                  Energy-audit quantities viscbt, slidet, work1t, and
c                  viscct are set to zero at the start of the simulation.
c       idef = 2 : initial deformations are assumed to be zero at the start of
c                  this run.  Deformation increments are relative to
c                  the past deformed state in the "C-file".  This is more
c                  stable when the stress control is applied at the very
c                  start of this run.
c       idef = 3 : initial deformations are specified in the array "defb"
c
      if(idef(rve).eq.3) then
c-------sample input in the event that you want to specify the deformation
c       state at the beginning of the run.  You might want to convert these
c       lines to allow input from the keyboard or from a file
        defb(1,1)= 1.d0
        defb(2,2)= 1.d0
        defb(3,3)= 1.d0
        defb(1,2)= 0.
        defb(1,3)= 0.
        defb(2,3)= 0.
      endif
c
c-----the original (reference) deformation that will used in computing the
c     output deformation
      do 20 i = 1,3
        do 21 j = i,3
          if(idef(rve).eq.3) then
            defo(i,j,rve) = defb(i,j)
          elseif(idef(rve).eq.2) then
            defo(i,j,rve) = def(i,j,rve)
          elseif(idef(rve).eq.1) then
            if(i.eq.j) then
              defo(i,j,rve) = 1.d0
              def(i,j,rve) =  1.d0
            else
              defo(i,j,rve) = 0.
              def(i,j,rve) =  0.
            endif
          elseif(idef(rve).eq.0) then
            if(i.eq.j) then
              defo(i,j,rve) = 1.d0
            else
              defo(i,j,rve) = 0.
            endif
          endif
   21   continue
        defup(i,rve) = def(i,i,rve)
   20 continue
c
c-----set energy-audit terms to zero at the start of this simulation
      if(idef(rve).eq.1) then
        work1t(rve) = 0.
        work2t = 0.
        viscbt(rve) = 0.
        viscct(rve) = 0.
        slidet(rve) = 0.
        slidet_alt(rve) = 0.
c-------energy terms are express per unit of original volume
        vcellt(rve) = vcell(rve)
        vcello(rve) = vcellt(rve)
      else
c-------energy terms are express per unit of original volume
        vcellt(rve) = vcello(rve)
      endif
c
c-----initialize the option of allowing/preventing particles to
c     rotate and move.  These options are changed within the stress-deformation
c     control steps using the input krotat()
      lrotat(rve) = .true.
      lmove(rve) = .true.
c
c----------------------------------------------------------------------
c     particle sizes and related properties
c
c-----assign mass and moment of intertia to each particle, establish the
c     minimum and maximum particle size and compute the voids ratio
c
c-----rho is the mass density of the particle material
c
c-----when iexact=0 (the default condition) we optimize the run time 
c     for pseudo-static problems by giving each particle 
c     the same mass and moment of inertia.
c     The moment of intertia is computed so that the product of the
c     mass, the normal contact stiffness, the radius squared,
c     and a factor (fac) is equal to the product of the moment of 
c     inertia and the tangential contact stiffness.  This gives about
c     the same particla vibration frequencies to both translation and 
c     rotation modes.
c
c-----when iexact=1 (lexact=.true.), we calculate the mass of each
c     particle based on its size.  We also include gyroscopic effects
c     with ovoid particles.
c
c-----we will be computing the minimum, maximum, and average particle
c     radii (rmin, rmax, and ravg).  For non-circular (or non-spherical
c     particles) particles, these radii have the following meaning:
c       rmin is the minimum dimension of all particles (taken from the
c            minor radius of each particle)
c       rmax is the maximum dimension of all particles (taken from the
c            major radius of each particle)
c       ravg is the average particle radius.  It is calculated as either
c            the square (or cube) root of the mean squared (or cubed)
c            particle radius.  Note that this definition differs from
c            the geotechnical definition r_50 or D_50.
c
c-----is the particles' shape convex or non-convex?
      if (lnobby(rve) .or. lbumpy(rve)) then
        lconvx(rve) = .false.
      else
        lconvx(rve) = .true.
      endif
c
c-----assign actual mass to each particle, instead of using the same
c     mass for every particle
      lexact = iexact .eq. 1
c
c-----initialize the minimum particle radius to a very large value.  Later,
c     the minimum radius will be found.
      rmin(rve) = 0.
      rpcmin(rve) = 0.
      do 29 i = 1,3
        rmin(rve) = rmin(rve) + xcell(i,i,rve)
        rpcmin(rve) = rpcmin(rve) + xcell(i,i,rve)
   29 continue
c
c-----initialize the maximum radius to a very small value.  rmax is used
c     for finding the threshold particle separation for a near-neighbor
c     search
      rmax(rve) = 0.
c-----the square of the maximum radius
      rmax2(rve) = 0.
c
c-----the average particle radius
      ravg(rve) = 0.
c
c-----the number of component pieces per particle
      if(lcircl(rve) .or. lspher(rve) .or. lelips(rve)) then
c-------these particle shapes are composed of a single piece
        njoin(rve) = 1
      elseif(loval(rve)) then
c-------four-arc ovals
        njoin(rve) = 4
      elseif(lovoid(rve)) then
c-------ovoids composed of spheres and tori
        njoin(rve) = 3
      elseif(lnobby(rve)) then
c-------nobby particles composed of circles arrange around a central circle
        njoin(rve) = nobs(rve) + 1
      elseif(lbumpy(rve)) then
c-------bumpy particles composed of spheres arrange around a central sphere
        njoin(rve) = nbumps(rve) + 1
      endif
c
c-----convert degrees to radians
      degrad = pi / 180.d0
c
c-----the total number of pieces in the assembly
      npiece(rve) = njoin(rve)*np(rve)
c
c-----minimum particle volume (or mass)
      volmin(rve) = 1.d20
c
c-----establish geometric characterics for each particle and particle shape
      if(lcircl(rve).or.lspher(rve)) then
c-------circular or spherical particles
c
c-------total volume of all particles
        voltot = 0.
c
c-------combined moment of inertia of the particles
        inertt = 0.
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .true.
c
c-------calculate the minimum, maximum, and (volume/area) average radii
        do 30 igrain=1,np(rve)
          rmin(rve) = min(rmin(rve),rad(igrain,rve))
          rmax(rve) = max(rmax(rve),rad(igrain,rve))
c
          rmax2(rve) = max(rmax2(rve),rad(igrain,rve))
c
c---------the average radius of the particles
          ravg(rve) = ravg(rve) + rad(igrain,rve)**ndim1
c
          if(ndim1.eq.3) then
c-----------volume of the spherical particle
            v_p(igrain,rve) = (4.d0/3.d0) * pi * rad(igrain,rve)**3
            mnt(igrain,rve) =0.4d0*v_p(igrain,rve)*rad(igrain,rve)**2
          elseif(ndim1.eq.2) then
c-----------area of the circular particle
            v_p(igrain,rve) = pi * rad(igrain,rve)**2
            mnt(igrain,rve) =0.5d0*v_p(igrain,rve)*rad(igrain,rve)**2
          endif
c
c---------particle mass.  Will later be multiplied by density
          mass(igrain,rve) = v_p(igrain,rve)
c---------smallest paraticle volume
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
c
c---------total volume and moment of intertias of the particles
          voltot = voltot + v_p(igrain,rve)
          inertt = inertt + mnt(igrain,rve)
   30   continue
c
        if(ndim1.eq.3) then
c---------text string for one of the output files
          partyp(rve) = 'Spherical (3D) particles'
        elseif(ndim1.eq.2) then
c---------text string for one of the output files
          partyp(rve) = 'Circular (2D) particles'
        endif
c
c-------the number of component parts in a circle or sphere
        npiecs(rve) = 1
c
c-------solids volume
        vso(rve) = voltot
        vs(rve) = vso(rve)
c
c-------average particle mass
        massav(rve) = rho(rve) * (voltot / np(rve))
c
c-------average particle volume and moment of intertia
        volavg(rve) = voltot / np(rve)
        Iavg(rve) = inertt / np(rve)
c
c-------volume averaged particle radius
        ravg(rve) = (ravg(rve)/np(rve))**(1.d0/ndim1)
c
c-------this is an angle that is only used with ovals and ovoids
        beta(rve) = 0.d0
c
        do 831 igrain = 1,np(rve)
          do 832 k = 1,ndim1
c---------set the absolute orientation angles "theta" to zero.  Note
c           that this angle is only of use in computing increments of
c           rotation, and it is not used to define the actual orientation
c           of the particle axis (this role is filled by "a_vect").
c           Initialize the angle, regardless of how the run is being
c           started.
            theta(k,igrain,rve) = 0.
  832     continue
  831   continue
C
      elseif(lelips(rve)) then
c-------elliptical particles
c
c-------text string for one of the output files
        partyp(rve) = 'Elliptical (2D) particles'
c
c-------the number of component parts in a ellipse
        npiecs(rve) = 1
c
c-------combined area of the particles
        areat = 0.
c-------combined moment of inertia of the particles
        inertt = 0.
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .false.
c
        piq = 0.25d0*pi
c
c-------for all of the (np) particles
        do 33 igrain = 1,np(rve)
c---------the ratio of the smaller radius / larger radius.  Given as input.
          rratio = aspect(igrain,rve)
c---------the larger radius, given as input
          rad1 = rad(igrain,rve)
c---------the smaller radius
          rad2 = rratio * rad1
c
c---------area of the particle
          areao = pi*rad1*rad2
c
c---------save the particle area for later use
          v_p(igrain,rve) = areao
c
c---------moment of inertia of the particle
          inert = piq*rad1*rad2*(rad1**2 + rad2**2)
c
c---------the minimum and maximum particle radii
          rmin(rve) = min(rmin(rve),rad1,rad2)
          rmax(rve) = max(rmax(rve),rad1,rad2)
c
          rmax2(rve) = max(rmax2(rve),rad1,rad2)
c
c---------the combined areas of all particles
          areat = areat + areao
c
c---------the combined moments of inertia
          inertt = inertt + inert
c
c---------the 0.5*0.5*(particle length + particle width) 
          rmean = 0.5d0*(rad1 + rad2)
c
c---------calculate the mean-square radius
          ravg(rve) = ravg(rve) + rmean**2
c
c---------assign mass and moment of inertia.  These will be changed later
c         if each particle is to be given the same value
          mass(igrain,rve) = areao
          mnt(igrain,rve) =  inert
c
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
c
          if(istart(rve).eq.1) then
c-----------convert degrees to radians
            theta(3,igrain,rve) = degrad*theta(3,igrain,rve)
          endif
   33   continue
c
c-------for use in computing void ratios
        vso(rve) = areat
        vs(rve) = vso(rve)
c
c-------average particle "radius", the average of the particle widths
c       and lengths
        ravg(rve) = (ravg(rve)/np(rve))**(1.d0/ndim1)
c
c-------the mass for use in integrating particle inertias.
        massav(rve) = rho(rve) * (areat / np(rve))
c
c-------average particle volume
        volavg(rve) = areat / np(rve)
c
c-------the average moment of inertia 
        Iavg(rve) = inertt / np(rve)
c
      elseif(loval(rve)) then
c-------oval particles consisting of four circular arcs
c
c-------text string for one of the output files
        partyp(rve) = 'Four-arc oval (2D) particles'
c
c-------the number of component parts in an oval
        npiecs(rve) = 4
c
c-------combined area of the particles
        areat = 0.
c
c-------combined moment of inertia of the particles
        inertt = 0.
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .true.
c
c-------geometric parameters shared by all ovals (these depend upon their
c       common 'beta' angle):
c
c-------tangent, cotangent, sine, and cosine of angle beta
        tan_b = tan(beta(rve) * pi / 180.d0)
        cbeta(1,rve) = cos(beta(rve) * pi / 180.d0)
        cbeta(2,rve) = sin(beta(rve) * pi / 180.d0)
c
c-------a denominator used in later calculations
        g1 = cbeta(1,rve)*cbeta(2,rve)
     x       - (1.d0 - cbeta(1,rve))*(1.d0 - cbeta(2,rve))
c
c-------the "beta" angle in radians
        betar(rve) = beta(rve) * degrad
        csbeta = cbeta(1,rve) * cbeta(2,rve)
        pih = 0.5d0 * pi
c
c-------for all of the (np) particles
        do 31 igrain = 1,np(rve)
c---------the ratio of the oval's minor radius / major radius
          rratio = aspect(igrain,rve)
c
c---------the transverse radius of the oval
          rad2 = rad(igrain,rve)
c
c---------the axial radius of the oval
          rad1 = rratio * rad2
c
c---------the radius of the top and bottom arcs
          r_1 = rad2*(cbeta(1,rve) - rratio + rratio*cbeta(2,rve))
     x          / g1
c
c---------the radius of the left and right arcs
          r_2 = rad2*(cbeta(1,rve) - 1.d0 + rratio*cbeta(2,rve)) / g1
c
c---------the offset of the top arc from the center of the oval
          p_1 = -(r_1 - r_2)*cbeta(1,rve)
c
c---------the offset of the right arc from the center of the oval
          p_2 =  (r_1 - r_2)*cbeta(2,rve)
c
c---------assign the two arc radii and offsets to an array
          r_piec(1,igrain,rve) = r_1
          r_piec(2,igrain,rve) = r_2
          r_piec(3,igrain,rve) = p_1
          r_piec(4,igrain,rve) = p_2
c
c---------other quantities required to compute the area and moment of inertia
          rdiff = r_1 - r_2
          rrcs = (rdiff**2) * csbeta
          rr = r_1**2
          rr2 = r_2**2
          rrrr = r_1**4
c
c---------area of the particle
          areao = 2.d0*(rr*betar(rve) - rrcs + rr2*(pih - betar(rve)))
c
c---------save the particle area for later use
          v_p(igrain,rve) = areao
c
c---------the following lines compute the moment of inertia (=inert)
c         of the oval, even though it is not really used in the algorithm
          area1 = 0.5d0 * (betar(rve)*rr - rrcs)
          c1 = (cbeta(2,rve)* (r_1**3)/3.d0 - p_2*(p_1**2)) / area1
     x         + p_1
          inert1 = 0.25d0 * rrrr * betar(rve) 
     x             + area1*(c1**2 - (c1 - p_1)**2)
          inert2 = pi * (r_2**4) / 8.d0
     x             - 0.25d0 * betar(rve) * r_2**4
     x             + 0.50d0 * betar(rve) * (r_2*p_2)**2
          inert = 4.d0*(inert1 + inert2)
c
c---------the minimum and maximum particle dimensions.  For later use in
c         determining when to perform a near-neighbor search.
          rmin(rve) = min(rmin(rve),rad1)
          rmin(rve) = min(rmin(rve),rad2)
c
          rmax(rve) = max(rmax(rve),rad1)
          rmax(rve) = max(rmax(rve),rad2)
c
          rmax2(rve) = max(rmax2(rve),rad1)
          rmax2(rve) = max(rmax2(rve),rad2)
c
c---------the minimum radius of the two pieces
          rpcmin(rve) = min(rpcmin(rve),r_1)
          rpcmin(rve) = min(rpcmin(rve),r_2)
c
c---------the total particle area (volume)
          areat = areat + areao
c
c---------the total of the particle moments of inertia
          inertt = inertt + inert
c
c---------the 0.5*0.5*(particle length + particle width) 
          rmean = 0.5d0*(  r_2 + (r_1 - r_2)*cbeta(2,rve)
     x                   + r_1 - (r_1 - r_2)*cbeta(1,rve))
c
c---------calculate the mean-square radius
          ravg(rve) = ravg(rve) + rmean**2
c
          if(istart(rve).eq.1) then
c-----------convert degrees to radians
            theta(3,igrain,rve) = degrad*theta(3,igrain,rve)
          endif
c
c---------compute the unit vector in the direction of the ovoid axis
          a_vect(1,igrain,rve) = -sin(theta(3,igrain,rve))
          a_vect(2,igrain,rve) =  cos(theta(3,igrain,rve))
c
          mass(igrain,rve) = areao
          mnt(igrain,rve) =  inert
c
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
   31   continue
c
c-------for use in computing void ratios
        vso(rve) = areat
        vs(rve) = vso(rve)
c
c-------average particle "radius", the average of the particle widths
c       and lengths
        ravg(rve) = sqrt(ravg(rve)/np(rve))
c
c-------the mass for use in integrating particle inertias.  The same mass
c       will be used with all particles
        massav(rve) = rho(rve) * (areat / np(rve))
c
c-------average particle volume
        volavg(rve) = areat / np(rve)
c
c-------the average moment of inertia
        Iavg(rve) = inertt / np(rve)
c
c
      elseif(lnobby(rve)) then
c-------nobby particles - a composite of circles
c
c       A nobby particle is a non-convex shape that is the union of a set
c       of circles.  The set includes a central circle and several
c       satellite circles.  The number of satellite circles is the input
c       variable "nobs", so that the total number of circles is nobs+1.
c       The satellite circles are evenly spaced, with the centers lying
c       on a circle.  This circle has input radius "rad".  The satellite
c       circles have radius satrad*rad.  The central circle has radius
c       cenrad*rad.
c
c-------text string for one of the output files
        partyp(rve) = 'Multi-circle nobby (2D) particles'
c
c-------the next line is a kluge.  npiecs is used to determine the size of
c       list3 in subroutins dumpin and dumpot
        npiecs(rve) = mlists
c
c-------combined area of the particles
        areat = 0.
c
c-------combined moment of inertia of the particles
        inertt = 0.
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .true.
c
c-------geometric parameters shared by all nobbies (these depend upon their
c       common "cenrad" and "satrad" properties):
c
c-------angle between nobs
        dangle = 2.d0*pi/nobs(rve)
c
c-------the central circle completely encompasses the satellite particles
        lcase1 = cenrad(rve) .gt. (satrad(rve) + 1.d0)
c
c-------the central circle is too small to touch the satellite particles
        lcase2 = (cenrad(rve) + satrad(rve)) .lt. 1.d0
c
c-------the satellite circles are too small to touch each other
        lcase3 = 2.d0*asin(satrad(rve)) .lt. 2.d0*pi/nobs(rve)
c
c-------the satellite circles touch each other, but the central particle is
c       so small that it is buried within the satellite circles
        lcase4 = .not.lcase3
     x           .and. cenrad(rve) .lt.
     x                  (cos(dangle/2.d0)
     x                   + sqrt(satrad(rve)**2 - sin(dangle/2.d0)**2))
c
c-------keep this condition in the common block and use it in subroutin nobby
c       for contact detection
        lhiddn(rve) = lcase4
c
        if(lcase1) then
c---------the central circle completely encompasses the satellite particles
c
c---------area of a particle with an input "rad" of 1.d0
          areao = pi*cenrad(rve)**2
c
c---------moment of inertia of a particle with an input "rad" of 1.d0
          inert = 0.5d0*pi*cenrad(rve)**4
c
c---------min and max radial distances from the center of the particle
          rin(rve) = cenrad(rve)
          rout(rve) = cenrad(rve)
        elseif(lcase2 .and. lcase3) then
c---------the central circle is too small to touch the satellite particles, and
c         the satellite circles are too small to touch each other
c
c---------area of a particle with an input "rad" of 1.d0
          areao = pi*cenrad(rve)**2 + nobs(rve)*pi*satrad(rve)**2
c
c---------moment of inertia of a particle with an input "rad" of 1.d0
          inert = 0.5d0*pi*cenrad(rve)**4
     x            + 0.5d0*nobs(rve)*pi*satrad(rve)**4
     x            + nobs(rve)*pi*satrad(rve)**2
c
c---------min and max radial distances from the center of the particle
          rin(rve) = cenrad(rve)
          rout(rve) = 1.d0 + satrad(rve)
        else
          if(lcase4) then
c-----------the satellite circles touch each other, but the central particle is
c           so small that it is buried within the satellite circles
c
c-----------the length "a" is the radial distance from the center of the
c           particle to the point where the central and satellite circles
c           intersect.  The angle "alpha" is half the included angle between
c           the two intersection points of a satellite circle
            alpha = dangle / 2.d0
            QQ = asin(sin(alpha)/satrad(rve))
            AA = pi - alpha - QQ
            a = sqrt(1.d0 + satrad(rve)**2 - 2.d0*satrad(rve)*cos(AA))
          else
c-----------the central circle passes through the satellite circles and is
c           part of particles outer boundary
            a = cenrad(rve)
            alpha = acos((1.d0 + cenrad(rve)**2 - satrad(rve)**2)
     x                   / (2.d0*cenrad(rve)))
          endif
c
c---------half the included angle of a satellite circle about its own center
          B = pi - asin(sin(alpha)*a/satrad(rve))
c
c---------moment of inertia of a particle with an input "rad" of 1.d0
          inert = 0.5d0 * pi * a**4
     x            + nobs(rve)
     x              * (  (0.5d0*satrad(rve)**4 *B
     x                    - (4.d0/9.d0*satrad(rve)**4 *sin(B)**2 /B)
     x                    + (satrad(rve)**2 *B
     x                       * (1.d0 + (2.d0/3.d0)*satrad(rve)*sin(B)
     x                          /B)**2
     x                      )
     x                    + 1.d0/6.d0*a**3 *sin(alpha)**3
     x                    + 1.d0/2.d0*a*sin(alpha)
     x                    - 1.d0/9.d0*satrad(rve)**4 *sin(B)*cos(B)**3
     x                    - satrad(rve)**2 *sin(B)*cos(B)
     x                      * (1.d0 + 2.d0/3.d0*satrad(rve)*cos(B))**2
     x                   )
     x                 - 0.5d0*a**4 *alpha
     x                )
c
c---------area of a particle with an input "rad" of 1.d0
          areao = pi * a**2
     x            + nobs(rve)
     x              * (  satrad(rve)**2 *(pi*B - cos(B)*sin(B)) 
     x                 - a**2 *(pi*alpha - cos(alpha)*sin(alpha)))
c
c---------min and max radial distances from the center of the particle
          rin(rve) = a
          rout(rve) = 1.d0 + satrad(rve)
        endif
c
c-------direction cosines of the satellite circles.  These circles are
c       arranged counterclockwise around the reference circle, starting
c       with the first satellite circle in the x_1 direction
        do 39 i = 1,nobs(rve)
          cosa(i,1,rve) = cos((i-1)*2.d0*pi/nobs(rve))
          cosa(i,2,rve) = sin((i-1)*2.d0*pi/nobs(rve))
          cosa(i,3,rve) = 0.
   39   continue
c
c-------for all of the (np) particles
        do 37 igrain = 1,np(rve)
c
c---------save the particle area for later use
          v_p(igrain,rve) = areao*rad(igrain,rve)**2
c
c---------the minimum and maximum particle dimensions.  For later use in
c         determining when to perform a near-neighbor search.
          rmin(rve) = min(rmin(rve),rin(rve)*rad(igrain,rve))
          rmax(rve) = max(rmax(rve),rout(rve)*rad(igrain,rve))
c
          rmax2(rve) = max(rmax2(rve),rout(rve))
c
c---------the total particle area (volume)
          areat = areat + areao*rad(igrain,rve)**2
c
c---------the total of the particle moments of inertia
          inertt = inertt + inert*rad(igrain,rve)**4
c
c---------the 0.5*0.5*(particle length + particle width) 
          rmean = 0.5d0*(rin(rve) + rout(rve))*rad(igrain,rve)
c
c---------calculate the mean-square radius
          ravg(rve) = ravg(rve) + rmean**2
c
          if(istart(rve).eq.1) then
c-----------convert degrees to radians
            theta(3,igrain,rve) = degrad*theta(3,igrain,rve)
          endif
c
c---------mass and moment of intertia of the particle. Note that we will later
c         multiply by the density
          mass(igrain,rve) = areao*rad(igrain,rve)**2
          mnt(igrain,rve) =  inert*rad(igrain,rve)**4
c
c---------smallest mass of all of the particles
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
   37   continue
c
c-------for use in computing void ratios
        vso(rve) = areat
        vs(rve) = vso(rve)
c
c-------average particle "radius", the average of the particle widths
c       and lengths
        ravg(rve) = sqrt(ravg(rve)/np(rve))
c
c-------the mass for use in integrating particle inertias.  The same mass
c       will be used with all particles
        massav(rve) = rho(rve) * (areat / np(rve))
c
c-------average particle volume
        volavg(rve) = areat / np(rve)
c
c-------the average moment of inertia
        Iavg(rve) = inertt / np(rve)
c
      elseif(lovoid(rve)) then
c-------composite ovoid particles consisting of two spherical caps and a torus
c
c-------text string for one of the output files
        partyp(rve) = 'Composite ovoid (3D) particles'
c
c-------the number of component parts in an ovoid
        npiecs(rve) = 3
c
c-------total volume of the particles
        voltot = 0.
c
c-------total moment of inertia of the particles
        Izztot = 0.
        Ixxtot = 0.
c
c-------the "beta" angle in radians
        betar(rve) = beta(rve) * pi / 180.d0
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .false.
c
c-------geometric parameters shared by all ovoids (these depend upon their
c       common 'beta' angle)
        cbeta(1,rve) = cos(betar(rve))
        cbeta(2,rve) = sin(betar(rve))
        g1 = cbeta(1,rve)*cbeta(2,rve)
     x       - (1.d0 - cbeta(1,rve))*(1.d0 - cbeta(2,rve))
c
c-------for converting degrees to radians, etc.
        third = 1.d0 / 3.d0
c
c-------various factors that are needed to calculate the particle volume
c       particle volumes and moments of inertia
        Vf(1) = 4.d0/3.d0 - 1.5d0*cos(betar(rve))
     x          + cos(3.d0*betar(rve)) / 6.d0
        Vf(2) = 2.d0*cos(betar(rve))
        Vf(3) = pi - 2.d0*betar(rve) + sin(2.d0*betar(rve))
        Vf(4) = 1.5d0*cos(betar(rve)) - cos(3.d0*betar(rve)) / 6.d0
c
c-------various factors that are needed to calculate the particle's
c       moments of inertia about their transverse axis
        Ix(1) = 8.d0/15.d0 - 0.5d0*cos(betar(rve))
     x          - cos(betar(rve))**3 / 3.d0
     x         + 0.3d0*cos(betar(rve))**5
        Ix(2) = 4.d0/3.d0 - 2.d0*cos(betar(rve))
     x          + 2.d0/3.d0*cos(betar(rve))**3
        Ix(3) = sin(betar(rve))**4
        Ix(4) = 0.5d0*cos(betar(rve))
        Ix(5) = pi/2.d0 - betar(rve)
     x          + cos(betar(rve))*sin(betar(rve))
        Ix(6) = 3.d0*cos(betar(rve)) - cos(betar(rve))**3 / 3.d0
        Ix(7) = 0.625d0*pi - 1.25*betar(rve)
     x          + 0.75d0*cos(betar(rve))*sin(betar(rve)) 
     x         + 0.5d0*sin(betar(rve))*cos(betar(rve))**3
        Ix(8) = 0.5d0*cos(betar(rve)) + cos(betar(rve))**3 / 3.d0 
     x         - 0.3d0*cos(betar(rve))**5
c
c-------various factors that are needed to calculate the particle's
c       moments of inertia about their central axis
        Iy(1) = 8.d0/15.d0 - 0.625*cos(betar(rve)) 
     x         + 5.d0/48.d0*cos(3.d0*betar(rve))
     x         - 1.d0/80.d0*cos(5.d0*betar(rve))
        Iy(2) = cos(betar(rve))
        Iy(3) = pi - 2.d0*betar(rve) + sin(2.d0*betar(rve))
        Iy(4) = 4.5d0*cos(betar(rve)) - 0.5d0*cos(3.d0*betar(rve))
        Iy(5) = 0.75*pi - 1.5d0*betar(rve) + sin(2.d0*betar(rve)) 
     x         - 0.125d0*sin(4.d0*betar(rve))
        Iy(6) = 0.625d0*cos(betar(rve))
     x          - 5.d0/48.d0*cos(3.d0*betar(rve))
     x         + 1.d0/80.d0*cos(5.d0*betar(rve))
c
        avasp(rve) = 0.
c
c-------for all of the (np) particles
        do 131 igrain = 1,np(rve)
c---------the ratio of the ovoid's axial radius / revolved radius
          rratio = aspect(igrain,rve)
c
c---------average aspect ratio of ovoids, for computing dt
          if(aspect(igrain,rve).lt.1.d0) then
            avasp(rve) = avasp(rve) + 1.d0 / aspect(igrain,rve)
          else
            avasp(rve) = avasp(rve) + aspect(igrain,rve)
          endif
c
c---------the revolved radius of the ovoid (the radius measured perpendicular
c         to the axis of revolution
          rad2 = rad(igrain,rve)
c
c---------the axial radius of the ovoid (the radius measured along its
c         axis of revolution
          rad1 = rratio * rad2
c
c---------the radius of the spherical caps
          r_1 = rad2*(cbeta(1,rve) - rratio + rratio*cbeta(2,rve))/g1
c
c---------the minor radius of the central torus
          r_2 = rad2*(cbeta(1,rve) - 1.d0 + rratio*cbeta(2,rve)) / g1
c
c---------the minimum radius of the two pieces
          rpcmin(rve) = min(rpcmin(rve),r_1)
          rpcmin(rve) = min(rpcmin(rve),r_2)
c
c---------the offset of the centers of the spherical caps from the
c         center of the particle
          p_1 = -(r_1 - r_2)*cbeta(1,rve)
c
c---------the major radius of the torus (the offset of the center of the
c         torus minor axis from the central axis of the particle)
          p_2 =  (r_1 - r_2)*cbeta(2,rve)
c
c---------place the radii and offsets into an array
          r_piec(1,igrain,rve) = r_1
          r_piec(2,igrain,rve) = r_2
          r_piec(3,igrain,rve) = p_1
          r_piec(4,igrain,rve) = p_2
c
          if(istart(rve).eq.1 .or. istart(rve) .eq.2) then
c-----------convert from degrees to radians.  We will use the gamma orientation 
c           angles of the ovoid axis to compute the components of the unit 
c           direction vector for the axis.
            gamma_(1,igrain,rve) = degrad * gamma_(1,igrain,rve)
            gamma_(2,igrain,rve) = degrad * gamma_(2,igrain,rve)
c
c-----------compute the unit vector in the direction of the ovoid axis
            a_vect(1,igrain,rve) 
     x        = sin(gamma_(1,igrain,rve))*cos(gamma_(2,igrain,rve))
            a_vect(2,igrain,rve)
     x        = sin(gamma_(1,igrain,rve))*sin(gamma_(2,igrain,rve))
            a_vect(3,igrain,rve) = cos(gamma_(1,igrain,rve))
          endif
c
c---------set the absolute orientation angles "theta" to zero.  Note
c         that with circles, spheres, and ovoids this angle is 
c         only of use in computing increments of
c         rotation, and it is not used to define the actual orientation
c         of the particle axis (this role is filled by "a_vect")
c         Initialize the angle, regardless of how the run is being
c         started.
          theta(1,igrain,rve) = 0.
          theta(2,igrain,rve) = 0.
          theta(3,igrain,rve) = 0.
c
c---------compute a nominal average radius for the ovoids
          rmean = third * (rad1 + 2.d0*rad2)
          ravg(rve) = ravg(rve) + rmean**3
c
c---------the minimum and maximum radii
          rmin(rve) = min(rmin(rve),rad1,rad2)
          rmax(rve) = max(rmax(rve),rad1,rad2)
c
          rmax2(rve) = max(rmax2(rve),rad1,rad2)
c
c---------the volume of the entire particle
          Volum  = pi*(r_1**3          * Vf(1) +
     x                 r_2    * p_2**2 * Vf(2) +
     x                 r_2**2 * p_2    * Vf(3) +
     x                 r_2**3          * Vf(4))
c
c---------the moment of inertia of the entire particle about its
c         transverse axis
          Izz = pi*(r_1**3 * (         p_1**2 * Ix(2) +
     x                        r_1    * p_1    * Ix(3) +
     x                        r_1**2          * Ix(1)) +
     x              r_2 *    (         p_2**4 * Ix(4) +
     x                        r_2    * p_2**3 * Ix(5) +
     x                        r_2**2 * p_2**2 * Ix(6) +
     x                        r_2**3 * p_2    * Ix(7) +
     x                        r_2**4          * Ix(8)))
c
c---------the moment of inertia of the entire particle about its axis
c         (of revolution)
          Ixx = pi*(r_1**5 * Iy(1) +
     x              r_2 * (         p_2**4 * Iy(2) +
     x                     r_2    * p_2**3 * Iy(3) +
     x                     r_2**2 * p_2**2 * Iy(4) +
     x                     r_2**3 * p_2    * Iy(5) +
     x                     r_2**4          * Iy(6)))
c
c---------save the particle volume for later use
          v_p(igrain,rve) = Volum
c
c---------the total assembly volume
          voltot = voltot + Volum
c
c---------the sums of the moments of inertia
          Izztot = Izztot + Izz
          Ixxtot = Ixxtot + Ixx
c
c---------mass and mass moment of inertia
          mass(igrain,rve) = Volum
          mnt(igrain,rve) =  Ixx
          mnt2(igrain,rve) = Izz
c
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
  131   continue
c
c-------average particle "radius", the average of the particle widths
c       and lengths
        ravg(rve) = (ravg(rve)/np(rve))**(1.d0/3.d0)
c
c-------average aspect ratio, for computing dt
        avasp(rve) = avasp(rve) / np(rve)
c
c-------a convergence test for the iterative algorithm for determining
c       whether two toruses are touching
        tolrnc(1,rve) = 1.d-22 * ravg(rve)
        tolrnc(2,rve) = 1.d-12 * ravg(rve)
c
c-------for use in computing void ratios
        vso(rve) = voltot
        vs(rve) = vso(rve)
c
c-------the mass for use in integrating particle inertias.  The same mass
c       will be used with all particles
        massav(rve) = rho(rve) * (voltot / np(rve))
c
c-------average particle volume
        volavg(rve) = voltot / np(rve)
c
c-------the average moment of inertia
        Iavg(rve) = (Izztot + 2.d0*Ixxtot) / 3.d0 / np(rve)
c
      elseif(lbumpy(rve)) then
c
c-------A bumpy particle is an composite of multiple component spheres.
c       These component spheres include a central sphere and several
c       satellite spheres, having the following characteristics
c         cenrad  =  The radius of the central sphere, for a particle of
c                    unit rad(igrain).  That is the radius of the
c                    central sphere is cenrad*rad(igrain)
c         satrad  =  The radius of the satellite spheres, for a particle of
c                    unit rad(igrain).  That is, the radius of the
c                    satellite spheres is satrad*rad(igrain)
c         cirrad  =  The radius of the sphere on which the satellite
c                    spheres are centered, for a particle of
c                    unit rad(igrain).  That is, cirrad*rad(igrain) is 
c                    the radius of the circumsphere of satellite centers.
c         nbumps  =  The number of satellite spheres, clustered around
c                    the central sphere
c
c       All dimensions in this section of code are for a particle
c       of unit input radius (that is, assuming that input "rad" 
c       values are 1 in the StartFile).  Other "rad" values will later
c       be scaled accordingly.
c
c       The component spheres will be numbered as follows: the central
c       sphere will have index "0", and the satellite spheres will be
c       numbered from "1" through "nbumps"
c
c       Create lists of the characteristics of the component spheres:
c         s_rad(0:nbumps) is the radius of each component sphere.
c                         = cenrad for the central partcles
c                         = cirrad for the satellite particles
c         b_rad(0:nbumps) is the distance (radius) from the center of the
c                            particle to the center of the component sphere.
c                         = 0 for the central particle
c                         = cirrad for the satellite spheres
c       Later, these values will be multiplied by the "rad" values obtained
c       from the input StartFile
c
c--------------------
c-------Check whether the number of satellite particles exceeds the value
c       of "mbumps" in the common file
c       if(nbumps.gt.mbumps) then
c         print *,'  The number of satellite particles, nbumps, exceeds'
c         print *,'  the value of mbumps in the common file.'
c         stop
c       endif
c--------------------
c
c-------The central sphere
        s_rad(Zero,rve) = cenrad(rve)
        b_rad(Zero,rve) = 0.
c
c-------The satellite spheres
        do 301 i = Zero+1,Zero+nbumps(rve)
          s_rad(i,rve) = satrad(rve)
          b_rad(i,rve) = cirrad(rve)
  301   continue
c
c-------whether the particle surfaces are spherical
        lsphr(rve) = .true.
c
c-------Assign positions to the component spheres within a local
c       coordinate system
c
c-------Assign a "zero" position for the central particle:
        xlocal(Zero,1,rve) = 0.
        xlocal(Zero,2,rve) = 0.
        xlocal(Zero,3,rve) = 0.
c
c-------Locate the vertices on a circumsphere of unit radius.  
c       These vertices will become the centers of the satellite spheres.
c
        if(nbumps(rve).eq.0) then
c---------A single (central) sphere with no satellite spheres.  We include
c         this case as a means of testing the bumpy code
        elseif(nbumps(rve).eq.2) then
c---------A single (central) sphere with two satellite spheres symmetrically
c         place on the x-x axis of the central sphere
c
c---------The first satellite sphere is centered on the x-axis.
          xlocal(Zero+1,1,rve) = 1.d0
          xlocal(Zero+1,2,rve) = 0.
          xlocal(Zero+1,3,rve) = 0.
c
c---------The second satellite sphere is centered on the x-axis.
          xlocal(Zero+2,1,rve) = -1.d0
          xlocal(Zero+2,2,rve) = 0.
          xlocal(Zero+2,3,rve) = 0.
        elseif(nbumps(rve).eq.3) then
c---------Three satellite spheres on the y-z plane, centered around 
c         the x-x axis.
c
c---------Locations of the vertices on a circumsphere of unit radius
          xlocal(Zero+1,1,rve) = 0.
          xlocal(Zero+1,2,rve) = 1.d0
          xlocal(Zero+1,3,rve) = 0.
c
          xlocal(Zero+2,1,rve) = 0.
          xlocal(Zero+2,2,rve) = -0.5d0
          xlocal(Zero+2,3,rve) = sqrt(3.d0)/2.d0
c
          xlocal(Zero+3,1,rve) = 0.
          xlocal(Zero+3,2,rve) = -0.5d0
          xlocal(Zero+3,3,rve) = -sqrt(3.d0)/2.d0
        elseif(nbumps(rve).eq.4) then
c---------Four satellite spheres centered on the vertices of a tetrahedron 
c
c---------Locations of the vertices on a circumsphere of unit radius
c
c---------The first satellite sphere is centered on the z-axis.  All others
c         are located below the x-y plane.
          xlocal(Zero+1,1,rve) = 0.
          xlocal(Zero+1,2,rve) = 0.
          xlocal(Zero+1,3,rve) = 1.d0
c
c---------The other three satellite spheres are centered on the z = -1/3 
c         plane
          xlocal(Zero+2,1,rve) = 0.
          xlocal(Zero+2,2,rve) = sqrt(8.d0 / 9.d0)
          xlocal(Zero+2,3,rve) = -1.d0 / 3.d0
c
          xlocal(Zero+3,1,rve) = -sqrt(2.d0 / 3.d0)
          xlocal(Zero+3,2,rve) = -sqrt(2.d0 / 9.d0)
          xlocal(Zero+3,3,rve) = -1.d0 / 3.d0
c
          xlocal(Zero+4,1,rve) =  sqrt(2.d0 / 3.d0)
          xlocal(Zero+4,2,rve) = -sqrt(2.d0 / 9.d0)
          xlocal(Zero+4,3,rve) = -1.d0 / 3.d0
c
        elseif(nbumps(rve).eq.6) then
c---------Six satellite spheres centered on the vertices of an octohedron 
c
c---------Locations of the vertices on a circumsphere of unit radius
c
c---------The first and second satellite spheres are centered on the z-axis.
c         All others are centered on the x-y plane.
          xlocal(Zero+1,1,rve) = 0.
          xlocal(Zero+1,2,rve) = 0.
          xlocal(Zero+1,3,rve) = 1.d0
c
          xlocal(Zero+2,1,rve) = 0.
          xlocal(Zero+2,2,rve) = 0.
          xlocal(Zero+2,3,rve) = -1.d0
c
c---------The other four satellite spheres are centered on the z = 0
c         plane, arranged counterclockwise around the z-axis
          xlocal(Zero+3,1,rve) = 1.d0
          xlocal(Zero+3,2,rve) = 0.
          xlocal(Zero+3,3,rve) = 0.
c
          xlocal(Zero+4,1,rve) = 0.
          xlocal(Zero+4,2,rve) = 1.d0
          xlocal(Zero+4,3,rve) = 0.
c
          xlocal(Zero+5,1,rve) = -1.d0
          xlocal(Zero+5,2,rve) = 0.
          xlocal(Zero+5,3,rve) = 0.
c
          xlocal(Zero+6,1,rve) = 0.
          xlocal(Zero+6,2,rve) = -1.d0
          xlocal(Zero+6,3,rve) = 0.
c
        elseif(nbumps(rve).eq.8) then
c
c---------Eight satellite spheres centered on the vertices of a cube 
c
c---------Locations of the vertices on a circumsphere of unit radius
c
c---------The first through fourth satellite spheres are centered 
c         centered above the x-y plane, arranged counterclockwise 
c         around the z-axis.  All others are centered below the x-y plane.
c
          sqrt13 = sqrt(1.d0 / 3.d0)
          xlocal(Zero+1,1,rve) = sqrt13
          xlocal(Zero+1,2,rve) = sqrt13
          xlocal(Zero+1,3,rve) = sqrt13
c
          xlocal(Zero+2,1,rve) = -sqrt13
          xlocal(Zero+2,2,rve) = sqrt13
          xlocal(Zero+2,3,rve) = sqrt13
c
          xlocal(Zero+3,1,rve) = -sqrt13
          xlocal(Zero+3,2,rve) = -sqrt13
          xlocal(Zero+3,3,rve) = sqrt13
c
          xlocal(Zero+4,1,rve) = sqrt13
          xlocal(Zero+4,2,rve) = -sqrt13
          xlocal(Zero+4,3,rve) = sqrt13
c
c---------The fifth through eighth satellite spheres are centered 
c         centered below the x-y plane, arranged counterclockwise 
c         around the z-axis.
c
          xlocal(Zero+5,1,rve) = sqrt13
          xlocal(Zero+5,2,rve) = sqrt13
          xlocal(Zero+5,3,rve) = -sqrt13
c
          xlocal(Zero+6,1,rve) = -sqrt13
          xlocal(Zero+6,2,rve) = sqrt13
          xlocal(Zero+6,3,rve) = -sqrt13
c
          xlocal(Zero+7,1,rve) = -sqrt13
          xlocal(Zero+7,2,rve) = -sqrt13
          xlocal(Zero+7,3,rve) = -sqrt13
c
          xlocal(Zero+8,1,rve) = sqrt13
          xlocal(Zero+8,2,rve) = -sqrt13
          xlocal(Zero+8,3,rve) = -sqrt13
        else
          write(ScrUnit(rve),*) ' '
          write(ScrUnit(rve),*) '**** Error ****.'
          write(ScrUnit(rve),*) 
     x      '* The input value of nbumps must be either ',
     x      '0, 2, 3, 4, 6, or 8'
          write(ScrUnit(rve),*) '* Your value:',nbumps(rve)
          stop
        endif
c
c-------Compute the volume and moment of ineritia of a bumpy particle
c       having a unit nominal radius (rad() = 1.d0
c
c-------Initialize the volume
        Volum = 0.
c
c-------Initialize the 2nd moments of volume.  These moments are with 
c       respect to the local coordinate frame of the particle
        Ixx = 0.
        Iyy = 0.
        Izz = 0.
        Ixy = 0.
        Ixz = 0.
        Iyz = 0.
c
c-------Estimate the volume of the bumpy particle having a unit nominal 
c       radius (rad() = 1.d0
c
        if(nbumps(rve).gt.0) then
c---------We will estimate the volume of bumpy particles
c         by creating a grid of points that encompass the particle 
c         and then counting the number of grid points that lie 
c         within the particle.
c
c---------The width of a grid that encompasses the particle
          Width = max(cenrad(rve), cirrad(rve)+satrad(rve))
c
c---------Half the number of grid increments
          ngrid = 100
c
c---------Width of each grid increment
          dWidth = Width / ngrid
c
c---------Volume of each grid element
          Voxel = dWidth**3
c
c---------Computing the volume and second moments...
c
c---------Here, i, j, and k are the integer x, y, and z coordinates within
c         the cube.  The origin is (0,0,0)
          do 303 i = -ngrid,ngrid
            do 304 j = -ngrid,ngrid
              do 305 k = -ngrid,ngrid
                l = Zero
c
c---------------Logical variable: whether the grid point lies within the
c               particle's boundaries
                lInsid = .false.
c
c---------------Loop through the component spheres
                do 306 while (l.le.Zero+nbumps(rve) .and. .not.lInsid)
c
c-----------------Distance from the center of the component sphere to 
c                 the particular grid point
                  d = sqrt(
     x                   (i*dWidth - b_rad(l,rve)*xlocal(l,1,rve))**2
     x                 + (j*dWidth - b_rad(l,rve)*xlocal(l,2,rve))**2
     x                 + (k*dWidth - b_rad(l,rve)*xlocal(l,3,rve))**2)
c
c-----------------Test whether the particle contains the particular 
c                 grid point
                  lInsid = d.lt.s_rad(l,rve)
c
                  l = l + 1
  306           continue
c
                if(lInsid) then
c-----------------The grid point lies within the particle.  Add to the
c                 volume and 2nd moments
                  Volum = Volum + 1.d0
                  Ixx = Ixx + (j**2 + k**2)
                  Iyy = Iyy + (i**2 + k**2)
                  Izz = Izz + (i**2 + j**2)
                  Ixy = Ixy + i*j
                  Ixz = Ixz + i*k
                  Iyz = Iyz + j*k
                endif
  305         continue
  304       continue
  303     continue
c
c---------Muliply by the volume per grid element, and by the squared
c         grid width
          Volum = Voxel * Volum
          Ixx =   Voxel * dWidth**2 * Ixx
          Iyy =   Voxel * dWidth**2 * Iyy
          Izz =   Voxel * dWidth**2 * Izz
          Ixy =   Voxel * dWidth**2 * Ixy
          Ixz =   Voxel * dWidth**2 * Ixz
          Iyz =   Voxel * dWidth**2 * Iyz
        elseif(nbumps(rve).eq.0) then
c---------The particle are merely single spheres: a central sphere
c         with no satellite spheres.  This case is included to help
c         check the code.
          Volum = (4.d0 / 3.d0)*pi*cenrad(rve)**3
          Ixx =   (2.d0 / 5.d0)*Volum*cenrad(rve)**2
          Iyy =   (2.d0 / 5.d0)*Volum*cenrad(rve)**2
          Izz =   (2.d0 / 5.d0)*Volum*cenrad(rve)**2
          Ixy =   0.
          Ixz =   0.
          Iyz =   0.
        endif
c
c-------the minimum difference between Ixx, Iyy, and Izz for the particle
c       to be considered asymmetric
        tol_i = 0.05d0
c
c-------(initialize) whether the particle shape is fully symmetric 
c       particles with equal Ixx, Iyy, and Izz
        lsymm = .false.
c
c-------(initialize) whether the particle shape is axisymmetric (solid of
c       revolution)
        laxsym(rve) = .false.
c
c-------Mean 2nd moment of volume
        Imean(rve) = (Ixx + Iyy + Izz) / 3.d0
c
c-------Check whether the approximate products of inertia (Ixy, Ixz, etc.) 
c       are significantly large.  If not, then set them equal to zero.
        if(      abs(Ixy).lt.tol_i*Imean(rve) 
     x     .and. abs(Ixz).lt.tol_i*Imean(rve) 
     x     .and. abs(Iyz).lt.tol_i*Imean(rve)) then
c---------Products of inertia are insignificant
          if(abs(Izz - Iyy).lt.tol_i*Imean(rve)) then
c-----------Iyy and Izz are roughly equal, so the particles are either
c           axisymmetric or fully symmetric
c
            if(abs(Ixx - Izz).lt.tol_i*Imean(rve)) then
c-------------Fully symmetric particles with equal Ixx, Iyy, and Izz
              lsymm = .true.
            else
c-------------Axisymmetric particles (e.g., solids of revolution)
c             Ixx = 0.5d0*(Ixx + Iyy)
              Ixx = Imean(rve)
              laxsym(rve) = .true.
            endif
          else
c-----------Oval can not yet handle particles with three different principal
c           2nd moments.
            write(ScrUnit(rve),910)
            write(ErrUnit(rve),910)
  910       format('****** Error ******', /,
     x             '  Oval can not yet handle particles with three ',
     x             'different principal moments')
            stop
          endif
        else
c---------Oval can not yet handle local frames that are not aligned with the
c         principal 2nd moment directions
          write(ScrUnit(rve),911)
          write(ErrUnit(rve),911)
  911     format('****** Error ******', /,
     x           '  Oval can not yet handle particles with local ',
     x           'frames that are not aligned with the principal ',
     x           '2nd moment directions')
          stop
        endif
c
c-------Find the inner and outer profile (radius) of the particles for use in
c       a near neighbor search
        rin(rve) = max(cenrad(rve), cirrad(rve)-satrad(rve))
        rout(rve) = max(cenrad(rve), cirrad(rve)+satrad(rve))
c
c-------total volume of all particles
        voltot = 0.
c
c-------combined moment of inertia of the particles
        inertt = 0.
c
c-------calculate the minimum, maximum, and (volume/area) average radii
        do 307 igrain=1,np(rve)
c
c---------the minimum and maximum particle dimensions.  For later use in
c         determining when to perform a near-neighbor search.
          rmin(rve) = min(rmin(rve),rin(rve)*rad(igrain,rve))
          rmax(rve) = max(rmax(rve),rout(rve)*rad(igrain,rve))
c
          rmax2(rve) = max(rmax2(rve),rout(rve)*rad(igrain,rve))
c
c---------for finding the  average radius of the particles, scaled radius**3
          ravg(rve) = ravg(rve) + rad(igrain,rve)**3
c
          if(ndim1.eq.3) then
c-----------volume of the bumpy particle, scaled by the input "rad"ius
            v_p(igrain,rve) = Volum * rad(igrain,rve)**3
            if(lsymm) then
c-------------fully symmetric particle with Ixx = Iyy = Izz
              mnt(igrain,rve) = Imean(rve) * rad(igrain,rve)**5
              inertt = inertt + mnt(igrain,rve)
            elseif(laxsym(rve)) then
c-------------axisymmetric particle with Ixx = Iyy
              mnt(igrain,rve) =  Izz * rad(igrain,rve)**5
              mnt2(igrain,rve) = Ixx * rad(igrain,rve)**5
              xImean = Imean(rve) * rad(igrain,rve)**5
              inertt = inertt + xImean
            endif
          endif
c
c---------for now, do not scale by the density rho
          mass(igrain,rve) = v_p(igrain,rve)
          volmin(rve) = min(volmin(rve),mass(igrain,rve))
c
c---------for a later calculation of the mean particle volume and intertia
          voltot = voltot + v_p(igrain,rve)
          inertt = inertt + mnt(igrain,rve)
  307   continue
c
c-------text string for one of the output files
        partyp(rve) = 'Multi-sphere (3D) bumpy particles'
c
c-------the next line is a kluge.  npiecs is used to determine the size of
c       list3 in subroutins dumpin and dumpot
        npiecs(rve) = mlists
c
c-------solids volume
        vso(rve) = voltot
        vs(rve) = vso(rve)
c
c-------average particle mass
        massav(rve) = rho(rve) * (voltot / np(rve))
c
c-------average particle volume
        volavg(rve) = voltot / np(rve)
        Iavg(rve) = inertt / np(rve)
c
c-------volume averaged particle radius
        ravg(rve) = (ravg(rve)/np(rve))**(1.d0/ndim1)
      endif
c
c-----initialize parameters that will be used to qualify particles as 
c     near-neighbors in the linked list.  "sep" is the maximum separation
c     for two particle to be considered as "near neighbors".  Note that
c     "sep" is an input value in the RunFile, but is modified below.
      if(sep(rve).eq.0.) then
        sep(rve) = rmax(rve)
      else
        sep(rve) = sep(rve)*ravg(rve)
      endif
c
c-----a hyperbolic sinh friction mechanism.  Make this option dormant
      lsinh(rve) =  .false.
c
      if(imodel(rve).eq.0) then
c-------a linear (spring) contact: fn = ovrlap*knh
        call init_model0(kn(rve), seprat0(rve), knmax(rve))
      elseif(imodel(rve).eq.1) then
c-------a piece-wise linear model with long-range forces
        call init_model1(kn(rve), pforce, psep, lc2, ldiams, nsepf, 
     x                   ravg(rve),
     x                   sep(rve), seprat0(rve), knmax(rve),
     x                   ScrUnit, rve, mrve)
      elseif(imodel(rve).eq.2) then
c-------a piece-wise linear model of long-range forces with different forces
c       for different particle diameters
        call init_model2(kn(rve), pforce, psep, lc2, ldiams, mp,
     x              ndiams(rve), np(rve), nsepf, 
     x              sep(rve), sepdia, seprat0(rve),
     x              knmax(rve), ravg(rve), rad, ScrUnit, rve, mrve)
      elseif(imodel(rve).eq.3 .or. imodel(rve).eq.4) then
c-------a model specified by S. Joseph Antony, with an inelastic and
c       incrementally non-linear long-range force
        call init_model34(kn(rve), knmax(rve),
     x                    knseph(rve), knsep2(rve),
     x                    psep2(rve),
     x                    ravg(rve), sep(rve), seprat0(rve),
     x                    ifn_togl, istart(rve), mlist2,
     x                    rve, mrve)
      elseif(imodel(rve).eq.5) then
c-------a Hertz-Mindlin contact model
        call init_model5(G(rve), nu(rve), frict(rve),
     x                   seprat0(rve),
     x                   knmax(rve), mvers, palpha(rve))
        lHertz(rve) = .true.
        lJager(rve) = .false.
        lJagr2(rve) = .false.
        lJagr4(rve) = .false.
      elseif(imodel(rve).eq.6) then
c-------Jager's generalization of the Hertz-Mindlin contact model (for
c       references, see subroutin Jager3D)
        call init_model6(G(rve), nu(rve), frict(rve), A_1(rve),
     x                   seprat0(rve), knmax(rve), mvers,
     x                   palpha(rve))
        lJager(rve) = .true.
        lJagr2(rve) = .false.
        lJagr3(rve) = .false.
        lJagr4(rve) = .false.
        lHertz(rve) = .false.
      elseif(imodel(rve).eq.7) then
c-------Jager's generalization of the Hertz-Mindlin contact model, but
c       with a conical (not spherical) contact profile (for
c       references, see subroutin Jager3D)
        call init_model7(G(rve), nu(rve), frict(rve), A_1(rve),
     x                   seprat0(rve), knmax(rve), mvers,
     x                   palpha(rve))
        lJager(rve) = .false.
        lJagr2(rve) = .true.
        lJagr3(rve) = .false.
        lJagr4(rve) = .false.
        lHertz(rve) = .false.
      elseif(imodel(rve).eq.8) then
c-------Jager's generalization of the Hertz-Mindlin contact model (for
c       references, see subroutin Jager3D)
        call init_model8(G(rve), nu(rve), frict(rve), A_1(rve),
     x                   seprat0(rve), knmax(rve), mvers,
     x                   palpha(rve))
        lJager(rve) = .false.
        lJagr2(rve) = .false.
        lJagr3(rve) = .true.
        lJagr4(rve) = .false.
        lHertz(rve) = .false.
      elseif(imodel(rve).eq.9) then
c-------Jager's generalization of the Hertz-Mindlin contact model (for
c       references, see subroutin Jager3D).  The variation accepts
c       contact profiles that are a general solid of revolution.
        call init_model9(G(rve), nu(rve), frict(rve), A_1(rve),
     x                   seprat0(rve), knmax(rve), mvers,
     x                   palpha(rve))
        lJager(rve) = .false.
        lJagr2(rve) = .false.
        lJagr3(rve) = .false.
        lJagr4(rve) = .true.
        lHertz(rve) = .false.
      elseif(imodel(rve).eq.10) then
c-------a sinh-dashpot rate-dependent friction model with linear spring
        call init_model0(kn(rve), seprat0(rve), knmax(rve))
        call init_model10(lsinh(rve), ptol(rve), dele(rve),
     x                    temprt(rve), n1(rve), lambda(rve),
     x                    etargt(rve))
c
c-------parameters for creep analysis
        boltzman = 1.38d-23
        planck = 6.62d-34
        rgas = 8.31d0
        coef4 = lambda(rve)/n1(rve)/2.d0/boltzman/temprt(rve)
        coef5 = lambda(rve)*(2.d0*boltzman*temprt(rve))/planck
     x          *exp(-(dele(rve)/rgas/temprt(rve)))
        coef7 = 0.5d0*coef5*kratio(rve)*kn(rve)/2.d0
      endif
c
c-----save the friction coefficient, in the even that it is later
c     changed with defdot
      frict_sav(rve) = frict(rve)
c
c----------------------------------------------------------------------
c
c-----the maximum number of relaxation loops within subroutin forces !!!!!!!!
      nloops = 100
c
c-----the minimum number of relaxation loops (algori=2) within subroutin forces
c     while assembly is equilibrating.  This value is given as input in the
c     RunFile.  If the input value is 0, then it is reassigned to 2 (note
c     that this will actually produce 3 relaxation cycles.  Weird.)
      if(nloop1.eq.0) then
        nloop1 = 3 - 1
      else
c-------give nloop1 a value one less than the input value (weird!)
        nloop1 = nloop1 - 1
      endif
c
c-----the minimum number of relaxation loops (algori=2) within subroutin forces
c     while assembly is equilibrating in response to body forces
      nloop2 = 8
c
c-----the minimum number of relaxation loops
      nlpmin = 1
c
c-----we will want to compute the sines and cosines of the particle orientation
c     angle theta().  ltheta is passed to subroutin locate
      ltheta(rve) = .true.
c
c-----compute the locations of the component pieces of ovals and ovoids.
c     Also recompute the sines and cosines of the particle orientation
c     angles theta()
      if(istart(rve).eq.1 .or. istart(rve).eq.2) then
        call locate(rve)
      endif
c
c--------------------------------------------------------
c
c     particle elastic, frictional and viscous properties
c
      if(.not.(lHertz(rve) .or. lJager(rve) .or. lJagr2(rve)
     x         .or. lJagr3(rve)
     x         .or. lJagr4(rve))) then
c-------linear (non-Hertz) contacts
c
c-------one-half of the (normal) spring stiffness.  Note that the input value
c       'kn' is applied to the indentations of each of the two contacting
c       particles,  whereas 'knh' is applied to the overlap of the two
c       particles. 'kn' is specified as input in the RunFile
        knh(rve) = kn(rve)*0.5d0
c
c-------the (tangential) contact stiffness.  'kratio' is specified as input
c       in the RunFile
        kt(rve) = kratio(rve)*kn(rve)
c
c-------one-half of the (tangential) spring stiffness.
        kth(rve) = kt(rve)/2.d0
c
c-------one-fourth of the (tangential) spring stiffness.
        kthh(rve) = kth(rve)/2.d0
c
c-------are the contacts frictional?
        lfrict(rve) = frict(rve).ne.0.
     x           .and. kth(rve).ne.0. .and. .not.lsinh(rve)
      else
c-------a Hertz-Mindlin contacts, possibly using the Jager method
c
c-------stiffness coeficients used in computing the contact force
c       Note that:  Ebar = (8/3)*(Thornton's E*)
        Ebar(rve) = (8.d0/3.d0) * (G(rve)/(1.d0-nu(rve)))
        Gbar(rve) = 4.d0*G(rve)/(2.d0-nu(rve))
c
c-------tangential-normal stiffness ratio
        kappa(rve) = (2.d0 - nu(rve)) / (2.d0*(1.d0 - nu(rve)))
c
c-------squared friction coefficient
        frict2(rve) = frict(rve)**2
        fk2(rve) =(frict(rve) * kappa(rve))**2
c
c-------coefficients that are used in computing elastic energy in contacts.
c       The first factor 2.d0 is for the two particle that share the same
c       contact.
        Ebar23n(rve) = 2.d0 * 2.d0 / 5.d0 / Ebar(rve)**(2.d0/3.d0)
c
c-------coefficients for use with conical contacts
        Ebar43n(rve) = 2.d0 * sqrt(6.d0*pi)
     x                  * sqrt(A_1(rve) / Ebar(rve))
c
c-------Jager's Cn factor for computing contact force for a general
c       surface of revolution
        if(lJagr4(rve)) then
          Cn(rve) = (3.d0/2.d0) * Ebar(rve)
     x         * (palpha(rve))/(palpha(rve) +1.d0) 
     x         * (gamma((palpha(rve) + 1.d0)/2.d0) 
     x            / (sqrt(pi) * A_1(rve) 
     x               * gamma((palpha(rve)
     x                        + 2.d0)/2.d0)))**(1.d0/palpha(rve))
c
          Cn_1(rve) = 2.d0 * (palpha(rve)/(2.d0*palpha(rve)+1.d0)) 
     x           * (1.d0 / Cn(rve))**(palpha(rve)/(palpha(rve)+1.d0))
        else
          Cn(rve) = 0.
          Cn_1(rve) = 0.
        endif
      endif
c
c-----when the input values of both rho and dt are less than zero, then
c     we will set dt=0 and compute a new density with every time step
      lnewdt(rve) = rho(rve).lt.0. .and. dt(rve).lt.0.
c
c-----when the values of damping constants are less than zero, then
      lnewc(rve) = pcrit(1,rve).lt.0.
      chia1(rve) = 0.
c
c-----with Hertz-type contacts, we must somehow estimate the contact
c     stiffnesses, so that a time step (or density) can be selected.
c     This is not a problem with linear contacts, since the contact stiffness
c     is independent of the contact overlaps.  So with Hertz-contacts
c     we will estimate the average stiffness by determining the average
c     contact overlap.  This means that we must use subroutin lister
c     to find the average overlap.
      if(lHertz(rve) .or. lJager(rve)
     x   .or. lJagr2(rve) .or. lJagr3(rve) .or. lJagr4(rve)) then
        if(istart(rve).le.2) then
          linitc(rve) = .true.
          nnnear = mnear
          nlist = mlist
          nlist2 = mlist2
          nlist3 = mlist3
          nboxs = mboxes
          call lister(rve,nnnear,nlist,nlist2,nlist3,nboxs)
          linitc(rve) = .false.
          nupdat(rve) = 0
          nupdat4(rve) = 0
c
c---------check whether there is a sufficient number of contacts to
c         for a load-bearing network of contacts.  If not, assign a small
c         value to ovravg
          ovrmin = 1.00d-5
          if(      (ndim1.eq.2 .and. ntacts(rve).lt.0.35d0*np(rve))
     x       .or. (ndim1.eq.3 .and. ntacts(rve).lt.0.50d0*np(rve))) then
            ovravg(rve) = ovrmin
          endif
c
c         if((     (ndim1.eq.2 .and. ntacts(rve).lt.0.35d0*np(rve)) 
c    x         .or.(ndim1.eq.3 .and. ntacts(rve).lt.0.50d0*np(rve)))
c            .and.ovrsav(rve).ne.0.)
c    x    then
c           ovravg(rve) = ovrsav(rve)
c         endif
c
c---------note that the average overlap (ovravg) includes multiple contacts
c         between (non-convex) particle pairs
          if(lHertz(rve) .or. lJager(rve) .or. lJagr3(rve)) then
c-----------contacts between spherical contours
            knh(rve) = (3.d0/4.d0)*Ebar(rve)
     x                  *sqrt(ovravg(rve) * ravg(rve) /2.d0)
          elseif(lJagr2(rve)) then
c-----------contacts between conical contours
            knh(rve) = (3.d0/pi/2.d0)* Ebar(rve)
     x            / A_1(rve) * (ovravg(rve) / 2.d0)
          elseif(lJagr4(rve)) then
c-----------contacts between general surfaces of revolution
            knh(rve) = (Cn(rve) / 2.d0) * (1.d0 + 1.d0/palpha(rve)) 
     x            * (ovravg(rve) / 2.d0)**(1.d0/palpha(rve))
          endif
c
          if(ndim1.eq.2) then
            knh(rve) = 2.0d0 * knh(rve)
            kratio(rve) = 1.d0
          elseif(ndim1.eq.3) then
            if(lHertz(rve)) then
              knh(rve) = 2.8d0 * knh(rve)
              kratio(rve) = 2.d0
            elseif(lJager(rve) .or. lJagr3(rve)) then
              knh(rve) = 2.8d0 * knh(rve)
              kratio(rve) = 1.d0
            elseif(lJagr2(rve)) then
              knh(rve) = 2.0d0 * knh(rve)
              kratio(rve) = 1.d0
            elseif(lJagr4(rve)) then
              knh(rve) = 2.4d0 * knh(rve)
              kratio(rve) = 1.d0
            endif
          endif
          kn(rve) = 2.d0 * knh(rve)
        endif
        kt(rve) = kratio(rve)*kn(rve)
        knh(rve) = kn(rve) / 2.d0
        kth(rve) = kt(rve) / 2.d0
        knmax(rve) = kn(rve)
      endif
c
c-----average of the normal and tangential stiffnesses
      if(kt(rve).ne.0.) then
        kmean(rve) = sqrt(knmax(rve)*kt(rve))
      else
        kmean(rve) = knmax(rve)
      endif
c
c-----with nobby and bumpy particles, it seems that thing run more efficiently
c     when we compute the particle mass (or time step) using a contact
c     stiffness is larger than the stiffness computed above
      if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
        kmean(rve) = 3.0d0 * kmean(rve)
      elseif(lnobby(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
        kmean(rve) = 1.5d0 * kmean(rve)
      endif
c
c-----with the Jager contact, it seems that things run more efficiently 
c     when we compute the particle mass (or time step) using a contact
c     stiffness is larger (bumpy particles) or smaller (other particles) 
c     than the stiffness computed above
      if(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)) then
        if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
          kmean(rve) = 3.0d0 * kmean(rve)
        else
          kmean(rve) = 1.00d0 * kmean(rve)
        endif
      elseif(lJagr4(rve)) then
        if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
          kmean(rve) = 2.5d0 * kmean(rve)
        else
          kmean(rve) = 1.00d0 * kmean(rve)
        endif
      endif
c
c-----the time increment, dt
c
c-----factors for computing (or checking) the time step:
c
c-----factor for the maximum stable time step.  I found these by trial
c     and error.  When both "dt" and "rho" are assigned non-zero values
c     in the RunFile, these values will be ignored (see below).
      if(ndim1.eq.2) then
        if(lexact) then
c---------assign different masses to all particles
          t2 = 0.6d0
        else
c---------assign the same mass to all particles
          t2 = 0.5d0
        endif
        fac = 6.75d0
c-------for a disk, the moment of inertia divided by the mass and r^2
        fac2 = 0.5d0
      elseif(ndim1.eq.3) then
        if(lexact) then
          t2 = 0.6d0
        else
          t2 = 0.4d0
        endif
c
c-------for a sphere, the moment of inertia divided by the mass and r^2
        fac2 = 0.4d0
c
        if(.not.(lJager(rve) .or. lJagr2(rve)
     x           .or. lJagr3(rve) .or. lJagr4(rve))) then
          if(.not.lbumpy(rve)) then
            fac = 1.75d0
          elseif(lbumpy(rve)) then
            fac = 2.00d0
            fac2 = Imean(rve) / Volum
            VolumQ(rve) = Volum
          endif
        elseif(lJager(rve) .or. lJagr3(rve)) then
          if(lbumpy(rve)) then
            fac = 4.00d0
            fac2 = Imean(rve) / Volum
            VolumQ(rve) = Volum
          elseif(lovoid(rve)) then
c           fac = 1.5d0 * avasp
            fac = 1.5d0 * sqrt(avasp(rve))
          else
            fac = 1.50d0
          endif
        elseif(lJagr2(rve)) then
          if(.not.lbumpy(rve)) then
            fac = 1.75d0
          elseif(lbumpy(rve)) then
            fac = 2.00d0
            fac2 = Imean(rve) / Volum
            VolumQ(rve) = Volum
          endif
        elseif(lJagr4(rve)) then
          if(.not.lbumpy(rve)) then
            fac = 1.625d0
          elseif(lbumpy(rve)) then
            fac = 2.75d0
            fac2 = Imean(rve) / Volum
            VolumQ(rve) = Volum
          endif
        endif
      endif
c
c-----factor for the recommended time step
      t1 = 0.8d0 * t2
c
c-----the time step and density (rho) was specified in the RunFile.  
c        if you set dt=0 and rho>0  then Oval will assign a recommended stable
c                                   time step, otherwise it will
c        if you set dt>0 and rho=0  then Oval will assign a density that
c                                   will make the given time step stable
c        if you set dt=0 and rho=0  then Oval will set dt=1 and assign a
c                                   density that will make the dt=1 stable
c        if you set dt>0 and rho>0  then Oval will use both of these given
c                                   values 
c        if, however dt > the stable time step, then Oval will print an error
c                                   message and stop
c        if you set dt<0 and rho>0  same as if dt=0, except that the time
c                                   step is increased by the factor abs(dt)
c        if you set dt<0 and rho=0  same as if dt=0, except that the time
c                                   step is increased by the factor abs(dt)
c        if you set dt=0 and rho<0  same as if dt=0, except that the density
c                                   is increased by the factor abs(rho)
c
c-----save the input values of rho and dt, in the event that they are
c     needed later
      rhoinp(rve) = rho(rve)
      dtinp(rve) = dt(rve)
c
      if(dt(rve).le.0.) then
        if(dt(rve).lt.0.) then
          dtfact = abs(dt(rve))
        else
          dtfact = 1.d0
        endif
c
        if(rho(rve).le.0.) then
c---------set dt=1 and compute the recommended mass
          dt(rve) = 1.d0
c
c---------optimum mass, using the geometric mean of kn and kt
          massav(rve) = kmean(rve) * (dt(rve) / (t1*dtfact))**2
          dtmax = t2 / dtfact * sqrt(massav(rve) / knmax(rve))
          if(lexact) then
            rho(rve) = massav(rve) / volmin(rve)
          endif
        else
c---------use the input "rho" and compute the recommended time step, using
c         the geometric mean of kn and kt
          if(lexact) then
            dt(rve) = t1 / dtfact *sqrt(rho(rve)*volmin(rve) 
     x                   / kmean(rve))
            dtmax = t2 * sqrt(rho(rve)*volmin(rve) / kmean(rve))
          else
            dt(rve) = t1 / dtfact * sqrt(massav(rve) / kmean(rve))
            dtmax = t2 * sqrt(massav(rve) / kmean(rve))
          endif
        endif
      elseif(rho(rve).le.0.) then
        if(rho(rve).lt.0.) then
          rhofact = abs(rho(rve))
        else
          rhofact = 1.d0
        endif
c
c-------use the input time step and compute the recommended mass
        massav(rve) =  kmean(rve) * (dt(rve) / t1)**2 * rhofact
        dtmax = t2 * sqrt(massav(rve) / knmax(rve))
        if(lexact) then
          rho(rve) = massav(rve) / volmin(rve)
        endif
      else
c-------use the input time step
        dt(rve) = dt(rve)
c-------estimate the maximum time step that will maintain a stable simulation
        dtmax = t2 * sqrt(massav(rve) / knmax(rve))
c
c-------check whether the input time step exceeds the maximum stable time step
        if(dt(rve).gt.dtmax.or.dt(rve).lt.0.) then
          write(ScrUnit(rve),860) dt(rve),dtmax
          write(ErrUnit(rve),860) dt(rve),dtmax
          stop
        endif
      endif
c
      if(lexact) then
        massd(rve) = rho(rve) * volavg(rve)
        mntav(rve) = rho(rve) * Iavg(rve)
      else
        massd(rve) = massav(rve)
        if(.not.(lHertz(rve) .or. lJager(rve)
     x           .or. lJagr2(rve) .or. lJagr3(rve) 
     x           .or. lJagr4(rve))) then
          mntav(rve) = fac * fac2
     x            * (kratio(rve)*2.d0) * massav(rve) * ravg(rve)**2
c         mntav = fac * fac2 * kratio * massav * ravg**2
        else
          mntav(rve) = fac * fac2 * massav(rve) * ravg(rve)**2
        endif
      endif
c
c-----some screen messages
      write(ScrUnit(rve),920) dt(rve),dtmax
  920 format(/,'  Your time step is:               ',1pe12.5,/,
     x         '  The maximum advised time step is:',1pe12.5)
c
c-----some more screen messages
      if(rho(rve).le.0.) then
        write(ScrUnit(rve),922) massav(rve)
      else
        write(ScrUnit(rve),923) rho(rve)
      endif
  922 format('  The reference particle mass is:  ',1pe12.5)
  923 format('  The particle mass density is:    ',1pe12.5)
c
c-----some debugging utilities get confused with 'dt'
      dtimer = dt(rve)
c
c-----when iexact=0, assign the same mass and moment of inertia to each
c     particle
      if(.not.lexact) then
c-------assign a common mass and moment of intertia to each particle
        do 835 igrain = 1,np(rve)
          mass(igrain,rve) = massav(rve)
          mnt(igrain,rve) =  mntav(rve)
          if(lovoid(rve)) then
            mnt2(igrain,rve) = mntav(rve)
          endif
  835   continue
      else
c-------assign individual masses and moments of intertia to each particle
        do 837 igrain = 1,np(rve)
c---------save these particle properties, they might be needed later
          v_p(igrain,rve) = mass(igrain,rve)
          vmnt_p(igrain,rve) = mnt(igrain,rve)
c
c---------multiply by the mass density
          mass(igrain,rve) = rho(rve) * v_p(igrain,rve)
          mnt(igrain,rve) =  rho(rve) * vmnt_p(igrain,rve)
          if(lovoid(rve)) then
            vmnt2p = mnt2(igrain,rve)
            mnt2(igrain,rve) = rho(rve) * vmnt2p
          endif
  837   continue
      endif
c
c-----compute some of the damping coefficients and related variables.
c     Initialize these now but change later, when appropriate
      lcdamp(rve) = .false.
      lbody(1,rve) = .false.
      lbody(2,rve) = .false.
c
c-----quantities required in the double-time integration algorithms:
c     inverse mass, inverse moment of inertia, etc.
      massi = 1.d0/massav(rve)
      massit(rve) = massi * dt(rve)
      mnti = 1.d0/mntav(rve)
      mntit(rve) = mnti * dt(rve)
c
c-----translational body damping coefficient.  The damping "pcrit(1)" is 
c     relative to the critical damping, 2.d0*sqrt(mass*knmax).  If the
c     input value of pcrit(1) is negative, we use its absolute value,
c     we only apply this damping to particles with no contacts (this feature
c     makes sense with non-periodic boundaries, when particles can possibly
c     "escape" from their confining boundaries
      lbody(1,rve) = pcrit(1,rve).ne.0.
      damp1(rve) = abs(pcrit(1,rve))
     x              *2.d0*sqrt(massd(rve)*knmax(rve))
c
c-----factors used in the implicit integration scheme
      tdampa(rve) = 0.5d0*massit(rve)*damp1(rve)
      tfact1(rve) = 1.d0 - tdampa(rve)
      tfact2(rve) = 1.d0 + tdampa(rve)
c
c-----rotational body damping coefficient
      lbody(2,rve) = pcrit(2,rve).ne.0.
      damp2(rve) = abs(pcrit(2,rve))
     x              *2.d0*ravg(rve)*sqrt(mntav(rve)*kt(rve))
c
c-----factors used in implicit integration scheme
      rdampa(rve) = 0.5d0*mntit(rve)*damp2(rve)
      rfact1(rve) = 1.d0 - rdampa(rve)
      rfact2(rve) = 1.d0 + rdampa(rve)
c
c-----Is contact damping being used?
      lcdamp(rve) = pcrit(3,rve).ne.0.
c
c-----contact damping coefficients
      dampc1(rve) = abs(pcrit(3,rve))
     x               * 2.d0 *sqrt(massd(rve)*knmax(rve))
     x               * 0.5d0 / dt(rve)
      dampc4 = abs(pcrit(3,rve))
     x         * 2.d0 * sqrt(mntav(rve)*kt(rve))/ravg(rve)
     x         * 0.5d0 / dt(rve)
      dampc2(rve) = dampc4 * 0.50d0 * 0.25d0
c
c-----will gravity (body force) be applied to the particles?  Check
c     the input values of gravity accelerations in the RunFile
c     lgrav(rve) = gravty(1).ne.0. .or. gravty(2).ne.0.
c    x              .or. gravty(3).ne.0.
      lgrav(rve) = .false.
c
c-----Factors for use with the Potyondy/Cundall type of damping
      adtm(rve) = pcrit(1,rve) * massit(rve) / 2.d0 
      athdtm(rve) = pcrit(2,rve) * mntit(rve) / 2.d0
c
c-----time increment with sinh dashpot
c     dtact = dt
c
c------------------------------------------------------------
c
c-----the void ratio
      voidn(rve) = (vcell(rve) - vso(rve))/vso(rve)
c
c-----the porosity
      porosn(rve) = voidn(rve) / (1.d0 + voidn(rve))
c
c-----solids fraction
      solidr(rve) = 1.d0/(1.d0 + voidn(rve))
c
c-----Print information to the screen at the start of the test
      if(lcircl(rve)) then
        write(ScrUnit(rve),901)
      elseif(loval(rve)) then
        write(ScrUnit(rve),902)
      elseif(lelips(rve)) then
        write(ScrUnit(rve),903)
      elseif(lspher(rve)) then
        write(ScrUnit(rve),904)
      elseif(lovoid(rve)) then
        write(ScrUnit(rve),905)
      elseif(lnobby(rve)) then
        write(ScrUnit(rve),907)
      elseif(lbumpy(rve)) then
        write(ScrUnit(rve),908)
      endif
c
c-----Print some more general information to the screen
      write(ScrUnit(rve),906)
     x  np(rve),voidn(rve),1.d0/(1.d0+voidn(rve)),
     x  voidn(rve)/(1.d0+voidn(rve)),vcell(rve)
c
  901 format(/,'  Particle shape =   Circular, 2D particles')
  902 format(/,'  Particle shape =   Four-arc oval, 2D particles')
  903 format(/,'  Particle shape =   Elliptical, 2D particles')
  904 format(/,'  Particle shape =   Spherical, 3D particles')
  905 format(/,'  Particle shape =   Ovoid, 3D particles')
  906 format(/,'  Number of particles     =',i8,
     x       /,'  Initial void ratio      =',f10.6,
     x       /,'  Initial solids fraction =',f10.6,
     x       /,'  Initial porosity        =',f10.6,
     x       /,'  Volume of the cell      =',1pe14.6)
  907 format(/,'  Particle shape =   Nobby, 2D particles')
  908 format(/,'  Particle shape =   Bumpy, 3D particles')
c
c-----Print information about the contact model
      if(imodel(rve).eq.0 .or. imodel(rve).eq.10) then
        write(ScrUnit(rve),914)
     x    kn(rve), kn(rve)/2.d0,kratio(rve),frict(rve)
  914   format(/,'  Linear contact model:',
     x         /,'  Normal (indentation) stiffness    = ',1pe11.4,
     x         /,'  Normal contact stiffness          = ',1pe11.4,
     x         /,'  Ratio tangential/normal stiffness = ',1pe11.4,
     x         /,'  Contact friction coefficient      = ',1pe11.4)
      elseif(imodel(rve).eq.5 .or. imodel(rve).eq.6
     x       .or. imodel(rve).eq.7 
     x       .or. imodel(rve).eq.8 .or. imodel(rve).eq.9) then
        if(imodel(rve).eq.5) then
          write(ScrUnit(rve),915)
  915     format(/,'  Conventional Hertz-Mindlin contact model:')
        elseif(imodel(rve).eq.6) then
          write(ScrUnit(rve),916)
  916     format(/,'  Jager contact model:')
        elseif(imodel(rve).eq.7) then
          write(ScrUnit(rve),919)
  919     format(/,'  Jager contact model for conical contacts:')
        elseif(imodel(rve).eq.8) then
          write(ScrUnit(rve),921)
  921     format(/,'  Jager contact model with Kalker rolling:')
        elseif(imodel(rve).eq.9) then
          write(ScrUnit(rve),925)
  925     format(/,'  Jager contact model for general contact shapes:')
        endif
        write(ScrUnit(rve),917) G(rve), nu(rve), frict(rve)
  917   format(  '  Shear modulus                =',1pe12.4,
     x         /,'  Poisson ratio                =',0pf10.6,
     x         /,'  Contact friction coefficient =',0pf10.6)
        if(imodel(rve).eq.7) then
          write(ScrUnit(rve),918) A_1(rve)
        endif
  918   format(  '  Conical slope, A_1           =',1pe12.4)
        if(imodel(rve).eq.9) then
          write(ScrUnit(rve),928) A_1(rve),palpha(rve)
        endif
  928   format(  '  Shape coefficient, A_alpha   =',1pe12.4,
     x         /,'  Contact contour power, alpha =',1pe12.4)
      endif
c
c----------------------------------------------------------------------
c
c     This block of code is only used for a special type of damping at the
c     contacts that was used for simulating soil creep.  This code will 
c     usually be of no consequence.
c
c-----Functions used for determining tangential components of contact forces.
c     We use a table look-up/interpolation approach in the later calculation 
c     of these functions.
c
      delx = 1.d0/mpts
      func1(0) = 1.d10
      do 207 i = 1,mpts
        x = i*delx
        func1(i) = log(tan(acos(x)/2.d0+pi/4.d0))
  207 continue
c
      dely = func1(1) / mpts
      do 208 i = 0,mpts
        y = i*dely
        func2(i) = 2.d0*(atan(exp(y)) - pi/4.d0)
  208 continue
c
      delx = 1.d0/mpts
      do 210 i = 1,mpts-1
        x = i*delx
        func3(i) = acos(x)
  210 continue
      func3(0) = pi/2.d0
      func3(mpts) = 0.
      func3(mpts+1) = 0.
c
      delz = pi/2.d0 / mpts
      do 212 i = 0,mpts+1
        x = i*delz
        func4(i) = cos(x)
        func5(i) = sin(x)
  212 continue
c
      dfunc6 = pi / 2.d0 / mpts
      do 214 i = 1,mpts
        func6(i) = log(abs(1.d0/sin(i*dfunc6) - 1.d0/tan(i*dfunc6)))
  214 continue
c
      dfunc7 = pi / 2.d0 / mpts
      func7(0) = 0.
      do 215 i = 1,mpts
        func7(i) = abs(1.d0/sin(i*dfunc7) - 1.d0/tan(i*dfunc7))
  215 continue
c
      dfunc7i = 1.d0 / mpts
      j = 1
      do 216 i = 0,mpts
        do 217 while (func7(j) .lt. (1.d0 - 0.001*dfunc7)*i*dfunc7i)
          j = j + 1
  217   continue
        func7i(i) = dfunc7*(j-1)
     x              + dfunc7 * (i*dfunc7i - func7(j-1))
     x                       / (func7(j) - func7(j-1))
  216 continue
c
c---------------------------------
c
c     Initialize other variables
c
c-----initialize linked-list parameters when the simulation is being
c     started from a "restar" StartFile
      if(istart(rve).eq.3) then
c-------is the linked-list ready for updating?
        lupdat(rve) = .false.
        ipoint(rve) = 1
      endif
c
c-----number of times that a messages have been written to the 'errfile'.
c     We set a maximum number of messages, so that the file doesn't fill
c     and entire file system
      nerror(rve) = 0
      merror = 500
c
c-----number of times that results have been reported
      iouti(rve) = -1
c
c-----flag for creating a intermediate restart file
      idumpi(rve) = 0
c
c-----report results at t = 0 into the A- and B-files?
      lreprt(rve) = .false.
c
c------------------------------------------------------
c
c-----data that will be needed if you are going to shear the cell into 
c     a "S" sinusoid-shape.  Otherwise, it is of no consequence.
      lreset(rve) = .false.
      llast(rve) = .false.
c
c------------------------------------------------------
c
      liso2(rve) = .false.
c
c-----the deformation-stress control segment, istep
      istep(rve) = 0
c
      istep2(rve) = 0
c
c-----istepm is the last control segment.  The simulation will stop when
c     it is reached
      istepa(rve) = istepm(rve)
c
c-----some values that are used in the stress-control feedback loop algorithm
      dsfm = 2.5d0
      dufm = 4.d0
c
c-----shear angles will be divided by spin to calculate mean-field rotation
      spin = 2.d0
c
c-----decomposition of incremental stress and deformation.  This code will
c     usually be of no consequence.
      if(istart(rve).le.2) then
        do 140 i = 1,3
          do 142 j = 1,3
            dstI(i,j) = 0.
            dstII(i,j) = 0.
            dstIIa(i,j) = 0.
            dstIIb(i,j) = 0.
            dstIIc(i,j) = 0.
            dstIId(i,j) = 0.
            dstIII(i,j) = 0.
            dstIIIa(i,j) = 0.
            dstIIIc(i,j) = 0.
            dstIIId(i,j) = 0.
c
            deftot(i,j) = 0.
            defttn(i,j) = 0.
            defttt(i,j) = 0.
            deftt1(i,j) = 0.
            deftt2(i,j) = 0.
            deftt3(i,j) = 0.
            defclt(i,j) = 0.
  142     continue
  140   continue
      endif
c
      if(istart(rve).le.2) then
c-------when the run is started with just a "D" or "E" file of particle
c       sizes and positions (that is, when a "restart" file is not being
c       used), we should initialize various time variables
        dtreal(rve) = dt(rve)
        dtrlo(rve) = dtreal(rve)
        treal(rve) = 0.
      endif
c
c--------------------------------------------------------------------
c
c-----initialize the particle velocites.  This will not be done if the
c     velocities are being provided with a 'restart' file (istart=3)
      if(istart(rve).le.2) then
        if(rmsvel(rve).le.0) then
c
c---------nothing to do here
c
c
c-------The type of algorithm being used to advance the particle positions
c       is read from the input file:
c       algori = 1 <- double time-integration algorithm, viscous damping
c       algori = 2 <- double time-integration algorithm, except that
c                     contact slips are only periodically updated.  I have
c                     experimented with this algorithm and believe that
c                     it gives better and more accurate performance.
c                     It only works, however, when the packing is dense.
c       algori = 3 <- same as algori=1, except with Potyondy/Cundall
c                     damping
c
        elseif(algori.eq.1) then
c---------assign initial random velocities to the particles, but adjust
c         the velocities so that the sqrt(average squared velocity) is equal
c         to 'rmsvel' given as input
c
c---------seed the random number generator.  We use the random number
c         code written and compiled by Barry W. Brown and James Lovato.
c         The input value 'xseed' is a double precision number between 0 and 1.
c         Convert this value to two integers and use the result in the
c         setall(int4, int4) subroutin.
          i4a = xseed(rve) * 2**30
          i4b = (1.d0 - xseed(rve)) * 2**30
          call setall(i4a, i4b)
c
c---------the sum of the squared particle velocities
          sumvsq = 0.
c
c---------adjust the particle velocities so that the momentum of the
c         assembly is zero (assumes that the mass of each particle is rmassa)
          do 70 j = 1,ndim1
            mentum = 0.
            masst = 0.
c
c-----------for all of the (np) particles
            do 72 igrain = 1,np(rve)
c-------------the function randof() produces a random number that is uniformly
c             distributed between 0 and 1 (non-inclusive).  The random
c             number is of real (4-byte) type
              vh(j,igrain,rve) = randof() - 0.5d0
cc------------renamed from the original ranf()
              mentum = mentum + vh(j,igrain,rve)*mass(igrain,rve)
              masst = masst + mass(igrain,rve)
   72       continue
c
c-----------velocity adjustment
            dvh = mentum / masst
c
c-----------adjust the velocities so that the total momentum is zero
            do 74 igrain = 1,np(rve)
              vh(j,igrain,rve) = vh(j,igrain,rve) - dvh
              sumvsq = sumvsq + vh(j,igrain,rve)**2
   74       continue
   70     continue
c
c---------velocity adjustment
          vfact = rmsvel(rve)/sqrt(sumvsq/np(rve))
c
c---------adjust the random velocities, so that the mean velocity is
c         equal to the input value of 'rmsvel', given in the RunFile
          do 80 j = 1,ndim1
            do 82 igrain = 1,np(rve)
c-------------the particle velocity
              vh(j,igrain,rve) = vh(j,igrain,rve)*vfact
              delx = vh(j,igrain,rve)*dt(rve)
c-------------the change in particle position
              dx(j,igrain,rve) = delx
c-------------the particle position
              xp(j,igrain,rve) = xp(j,igrain,rve) + delx
   82       continue
   80     continue
c
          if(loval(rve) .or. lelips(rve) .or. lovoid(rve)
     x             .or. lnobby(rve)
     x             .or. lbumpy(rve)) then
c-----------when non-circular or non-spherical particles are being used, 
c           assign random angular velocities
            sumvth(1) = 0.
            sumvth(2) = 0.
            sumvth(3) = 0.
c
            do 79 j = ndim2,3
              mentum = 0.
              masst = 0.
              do 76 igrain = 1,np(rve)
c---------------the function randof() produces a random number that is uniformly
c               distributed between 0 and 1 (non-inclusive).  The random
c               number is of real (4-byte) type
                vhth(j,igrain,rve) = randof() - 0.5d0
cc--------------renamed from the original ranf()
                mentum = mentum + vhth(j,igrain,rve)*mnt(igrain,rve)
                masst = masst + mnt(igrain,rve)
   76         continue
c
c-------------the average angular velocity
              dvth = mentum / masst
c
c-------------adjust the angular velocities so that the total 
c             angular momentum is zero
              do 78 igrain = 1,np(rve)
c---------------adjust the velocities
                vhth(3,igrain,rve) = vhth(3,igrain,rve) - dvth
c
c---------------compute the mean square angular velocity
                sumvth(j) = sumvth(j) + vhth(j,igrain,rve)**2
   78         continue
   79       continue
c
c-----------suppose that the desired average angular velocity is 10% of 
c           (the average translation velocity / the average radius).
c           So that, on average, the particles will rotate about 0.10 radians 
c           as they move a distance of 1 radius
            rotfac = 0.10d0
            vthdsr = rotfac * rmsvel(rve)/ravg(rve)
c
c-----------factor the angular velocities to produce the desired mean velocity
            vfact = vthdsr/sqrt((sumvth(1)**2 + sumvth(2)**2 + 
     x                           sumvth(3)**2)/np(rve))
c
c-----------factor the angular velocities to produce the desired mean
c           velocity.
            do 81 j = ndim2,3
              do 83 igrain = 1,np(rve)
                vhth(j,igrain,rve) = vhth(j,igrain,rve)*vfact
                delx = vhth(j,igrain,rve)*dt(rve)
                dth(j,igrain,rve) = delx
                ddth(j,igrain,rve) = delx
                theta(j,igrain,rve) = theta(j,igrain,rve) + delx
   83         continue 
   81       continue
c
c-----------With composite "bumpy" particles, we must update the orientation
c           quaternions  of the particles ...
            if(lbumpy(rve)) then
c-------------having computed the incremental rotation of the particle, we
c             must apply this increment to the quaternions that give the
c             particles' orientations
c
c-------------normalize the revised quaternion by dividing by the square root
c             of its norm
              inorm = 2
              do 121 igrain=1,np(rve)
c---------------the current orientation quaternion
                Qp_old(1) = Qp(1,igrain,rve)
                Qp_old(2) = Qp(2,igrain,rve)
                Qp_old(3) = Qp(3,igrain,rve)
                Qp_old(4) = Qp(4,igrain,rve)
c
c---------------the incremental rotation in the global frame (for either 
c               algori=1, algori=2)
                dw(1) = dth(1,igrain,rve)
                dw(2) = dth(2,igrain,rve)
                dw(3) = dth(3,igrain,rve)
c
c---------------apply the incremental rotation to the orientation quaternion
                call QIncRotate(Qp_old, Qp_new, dw, inorm)
c
c---------------the revised orientation quaternion
                Qp(1,igrain,rve) = Qp_new(1)
                Qp(2,igrain,rve) = Qp_new(2)
                Qp(3,igrain,rve) = Qp_new(3)
                Qp(4,igrain,rve) = Qp_new(4)
  121         continue
            endif
          endif
        endif
c
c-------we will want to compute the sines and cosines of the particle 
c       orientation angles theta().  ltheta is passed to subroutin locate
        ltheta(rve) = .true.
c
c-------compute the locations of the component pieces of ovals or ovoids.
c       Also recompute the sines and cosines of the particle orientation
c       angles theta()
        call locate(rve)
      endif
c
c------------------------------------------------------------------
c
c-----the simulations is not being started with a restart file
      lflag1(rve) = istart(rve).le.2
c
c-----estimate the stiffness of the assembly for use in controlling
c     the stresses during deformation
      lquez(rve) = .true.
      call quez(rve)
c
c-----the permutation matrix
      do 90 i = 1,3
        do 92 j = 1,3
          do 94 k = 1,3
            eperm(i,j,k) = 0.
   94     continue
   92   continue
   90 continue
c
c-----the permutation matrix
      eperm(1,2,3) = 1.d0
      eperm(3,1,2) = 1.d0
      eperm(2,3,1) = 1.d0
      eperm(2,1,3) = -1.d0
      eperm(1,3,2) = -1.d0
      eperm(3,2,1) = -1.d0
c
c-----whether to compute loop quantities from the particle graph.
c     The program does not support the analysis of particle graphs.
c     lcirct = icirct.eq.1
      lcirct(rve) = .false.
c
      return
c
  860 format(/,1x,
     x  'Error. The input time increment, dt, exceeded 40-60% of ',
     x  'sqrt(m/k)',/,
     x  '  Your input time step was:         ',1pd12.4,/,
     x  '  The maximum advised time step is: ',1pd12.4)
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine initFilesAB(rve,
     x  OutputDir,RunFile,StartFile,
     x  ndim1,iheat,hmodel,lout,lporo,mfiles,iporo,
     x  version, partyp, np, ravg, voidn,
     x  lHertz,lJager,lJagr2,lJagr3,
     x  lJagr4,
     x  AUnit,BUnit,itxt,Bversn)
c
c     include 'common-dempla-0.2.2.f'
c
      integer*2 AUnit,BUnit,Bversn,
     x          iheat,iporo,itxt,hmodel,mfiles,rve
      integer*4 aversn,ndim1,np
      double precision ravg,voidn
      character*1 tab
      character*24 version
      character*40 partyp
      character*400 OutputDir,RunFile,StartFile
      character*800 filename1, filename2
      logical lHertz, lJager, lJagr2, lJagr3, lJagr4, lout, lporo
c
      dimension lout(mfiles)
c
c-----initialize output files
c
c-----search for .txt extension with the RunFile name, so that the output
c     can be intelligently named for ease in using Windows
      itxt = index(RunFile,'.txt')
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      AUnit = 10 + 5*rve + 1
c
c-----Open the "A*.txt" file, being careful to avoid a double
c     ".txt.txt" extension
      if(lout(1)) then
        if(itxt.eq.0) then
c---------the RunFile name does not already end with ".txt"
          filename1 = OutputDir(1:LEN_TRIM(OutputDir))//
     x                'A'//
     x                RunFile(1:LEN_TRIM(RunFile))//
     x                '.txt'
          open(unit=AUnit,
     x         file=filename1,
     x         blank='zero')
        else
          filename1 = OutputDir(1:LEN_TRIM(OutputDir))//
     x              'A'//
     x              RunFile(1:index(RunFile,'.txt')-1)
          open(unit=AUnit,
     x         file=filename1,
     x         blank='zero')
        endif
c
c-------the tab character.  In the past, I used "h" format (Hollerith format)
c       to create the tab character in ouput.  This worked fine with most
c       compilers, but then I discovered that the gcc/g77 compiler
c       did not correctly produce the tab characters.  So now I must use
c       this rather stupid, cumbersome approach to inserting tabs.  
c       I know it is ridiculous, but this was the only way I could think to 
c       produce the tabs
        tab = achar(9)
c
c-------write header information to the top of the "A*.txt" file
        write(AUnit,601)
c
c-------version numbers for this output "A" file
        if(ndim1.eq.2) then
          if(.not.(lHertz .or. lJager
     x             .or. lJagr2 .or.lJagr3
     x             .or. lJagr4)) then
            aversn = 102
          else
            aversn = 103
          endif
        elseif(ndim1.eq.3) then
          if(iheat.eq.0) then
            aversn = 112
          elseif(iheat.eq.1 .and. hmodel.eq.1) then
            aversn = 113
          endif
        endif
c
        if(lporo) then
c---------when pore fluid pressure is included, we will need to write
c         pore pressure, etc.
          if(iporo.eq.1) then
            aversn = aversn + 30
          elseif(iporo.eq.3) then
            aversn = aversn + 40
          endif
        endif
c
c-------second line in the A-file
        write(AUnit,606) aversn
c
c-------write general information about the assembly at the top of the
c       A-file
        if(.not.(ndim1.eq.2 
     x     .and. (lHertz .or. lJager
     x            .or. lJagr2 .or. lJagr3
     x            .or. lJagr4))) then
          write(AUnit,602) tab,version,
     x                  tab,partyp,
     x                  tab,np,
     x                  tab,voidn,
     x                  tab,RunFile(1:LEN_TRIM(RunFile)),
     x                  tab,StartFile(1:LEN_TRIM(StartFile))
        else
          write(AUnit,607) tab,version,
     x                  tab,partyp,
     x                  tab,np,
     x                  tab,voidn,tab,tab,2.d0*ravg,
     x                  tab,RunFile(1:LEN_TRIM(RunFile)),
     x                  tab,StartFile(1:LEN_TRIM(StartFile))
        endif
c
c-------create colummn headers in the "A*.txt" file
        if(ndim1.eq.2) then
c---------for 2D simulations
          write(AUnit,603)
     x       tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x       tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x       tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x       tab
        elseif(ndim1.eq.3) then
c---------for 3D simulations
          write(AUnit,604)
     x     tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x     tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x     tab,tab,tab,tab,tab,tab,tab,tab,tab,tab,
     x     tab,tab,tab,tab,tab,tab,tab,tab,tab,tab
        endif
c
c-------note that I have embedded a tab character behind the '1h' Hollerith,
c       To do this using the "vi" editor, I inserted Ctrl-V Tab.
c
c-------forget that last comment.  Now tab characters are inserted with
c       with the "tab" variable in "a1" format
  601   format('Results of a DEM simulation with OVAL')
  602   format(   'Version:',a1,a24
     x         ,/,'Particle type:',a1,a40
     x         ,/,'Number of particles:',a1,i7
     x         ,/,'Initial void ratio:',a1,f10.7
     x         ,/,'Input file with control conditions:',a1,a
     x         ,/,'Input file of initial assembly configuration:'
     x               ,a1,a,/)
  603   format('Time',a1,
     x         'Def(1,1)',a1,'Def(2,2)',a1,'Def(1,2)',a1,
     x         'Stress(1,1)',a1,'Stress(2,2)',a1,'Stress(1,2)',
     x         a1,'chi1',a1,'chi2',a1,'psi',
     x         a1,'Contacts',
     x         a1,'F(1,1)',a1,'F(1,2)',a1,'F(2,2)',
     x         a1,'Fs(1,1)',a1,'Fs(1,2)',a1,'Fs(2,2)',
     x         a1,'v',
     x         a1,'Faces',a1,'Edges',a1,'Vertices',
     x         a1,'Void Ratio',a1,'Eff. Void Ratio',
     x         a1,'knrgy',a1,'pnrgy',
     x         a1,'slidet',a1,'viscbt',
     x         a1,'viscct',a1,'work1t',
     x         a1,'Sliding Contacts',a1,'Near Contacts',
     x         a1,'Solid Fraction')
  604   format('Time',a1,
     x         'Def(1,1)',a1,'Def(2,2)',a1,'Def(3,3)',a1,
     x         'Def(1,2)',a1,'Def(1,3)',a1,'Def(2,3)',a1,
     x         'Stress(1,1)',a1,'Stress(2,2)',a1,'Stress(3,3)',a1,
     x         'Stress(1,2)',a1,'Stress(1,3)',a1,'Stress(2,3)',a1,
     x         'chi1',a1,'chi2',a1,'psi',a1,
     x         'Contacts',a1,
     x         'F(1,1)',a1,'F(2,2)',a1,'F(3,3)',a1,
     x         'F(1,2)',a1,'F(1,3)',a1,'F(2,3)',a1,
     x         'Fs(1,1)',a1,'Fs(2,2)',a1,'Fs(3,3)',a1,
     x         'Fs(1,2)',a1,'Fs(1,3)',a1,'Fs(2,3)',a1,
     x         'v',a1,
     x         'Void Ratio',a1,'Eff. Void Ratio',a1,
     x         'knrgy',a1,'pnrgy',a1,
     x         'slidet',a1,'viscbt',a1,
     x         'viscct',a1,'work1t',a1,
     x         'Sliding Contacts',a1,'Near Contacts',a1,
     x         'Solid Fraction')
c 605   format('Time',a1,
c    x         'Def(1,1)',a1,'Def(2,2)',a1,'Def(3,3)',a1,
c    x         'Def(1,2)',a1,'Def(1,3)',a1,'Def(2,3)',a1,
c    x         'Stress(1,1)',a1,'Stress(2,2)',a1,'Stress(3,3)',a1,
c    x         'Stress(1,2)',a1,'Stress(1,3)',a1,'Stress(2,3)',a1,
c    x         'chi1',a1,'chi2',a1,'psi',a1,
c    x         'Contacts',a1,
c    x         'F(1,1)',a1,'F(2,2)',a1,'F(3,3)',a1,
c    x         'F(1,2)',a1,'F(1,3)',a1,'F(2,3)',a1,
c    x         'Fs(1,1)',a1,'Fs(2,2)',a1,'Fs(3,3)',a1,
c    x         'Fs(1,2)',a1,'Fs(1,3)',a1,'Fs(2,3)',a1,
c    x         'v',a1,
c    x         'Void Ratio',a1,'Eff. Void Ratio',a1,
c    x         'knrgy',a1,'pnrgy',a1,
c    x         'slidet',a1,'viscbt',a1,
c    x         'viscct',a1,'work1t',a1,
c    x         'Sliding Contacts',a1,'Near Contacts',a1,
c    x         'Solid Fraction',a1,
c    x         'Strsub(1,1)',a1,'Strsub(2,2)',a1,'Strsub(3,3)',a1,
c    x         'Strsub(1,2)',a1,'Strsub(1,3)',a1,'Strsub(2,3)',a1,
c    x         'Fsub(1,1)',a1,'Fsub(2,2)',a1,'Fsub(3,3)',a1,
c    x         'Fsub(1,2)',a1,'Fsub(1,3)',a1,'Fsub(2,3)',a1,
c    x         'Sub contact',a1,'Oct.Str.1',a1,'Oct.Str.2')
  606   format(i4)
  607   format(   'Version:',a1,a24
     x         ,/,'Particle type:',a1,a40
     x         ,/,'Number of particles:',a1,i7
     x         ,/,'Initial void ratio:',a1,f10.7
     x           ,a1,'Mean diameter',a1,1pe17.9
     x         ,/,'Input file with control conditions:',a1,a
     x         ,/,'Input file of initial assembly configuration:'
     x               ,a1,a,/)
c
c-------file number to be used across subroutins for the "B" file
        BUnit = 10 + 5*rve + 2
c
c-------open the B-file, the macro-results text file
        filename2 = OutputDir(1:LEN_TRIM(OutputDir))//
     x              'B'//
     x              RunFile(1:LEN_TRIM(RunFile))
        open(unit=BUnit,
     x       file=filename2,
     x       blank='zero')
c
c-------write header information to the top of the B-file.  The
c       first field (e.g., integer 10 or 11) describes the format of the
c       B-file, so that the data can be read by a postproccesing program
        if(ndim1.eq.2) then
c---------two-dimensional assemblies
          if(lout(5)) then
c-----------output shows higher-order stresses
            Bversn = 14
          elseif(.not.lout(8)) then
            Bversn = 10
          else
c           Bversn = 12
c-----------changed header format with DEMPLA
            Bversn = 22
          endif
        elseif(ndim1.eq.3) then
c---------three-dimensional assemblies
          if(lout(5)) then
c-----------output shows higher-order stresses
            Bversn = 15
          else
c           Bversn = 17
c-----------changed header format with DEMPLA
            Bversn = 27
          endif
        endif
      endif
c
      if(lporo) then
        if(iporo.eq.1) then
          Bversn = Bversn + 10
        elseif(iporo.eq.3) then
          Bversn = Bversn + 20
        endif
      endif
c
c-----write the B-file heading
      write(BUnit,600) Bversn,StartFile,version,rve
c
  600 format(i4,/,a80,/,a,/,i4.4)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine forces(rve)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 i,
     x          ipart,iremov,itask,islip1,islip2,
     x          j,jfn_togl,jpart,k,kpart,l,
     x          rve,nnnear(0:mrve),nparts,nsepf
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,i4a,i4old,
     x          i_avail,i_avail2,ichat1,ichat2,
     x          ierr,igrain,ihit,inorm,
     x          ipt1,ipt3,ipt5,isweep,ixg,
     x          j4,jgrain,jhit,k4,m_i,m_j,
     x          nlist2,nlistJ,nremov,nsteps,nsweep,ntorus
      integer*4 icatch, iclean1, iclean2,
     x          listk, listJ, 
     x          nboxs(0:mrve), nclean1, nclean2,
     x          nlist(0:mrve), nnlist2(0:mrve), nlist3(0:mrve)
c
      double precision acoef,adjust,a_i,a_j,arad,
     x          betaQ,betar1,betar2,betahi,betalo,
     x          c_eta,C_w,carea,
     x          coef4,coef5,coef7,cosbi,cosbj,cosft,cosx,
     x          ctheti,cthetj,
     x          d_xi,d_xi_adjust,d_xi_global,d_xio,
     x          Dcurnt,ddthr,ddxkn,ddxrel,ddxrln,ddxrlr,ddxrlt,
     x          dftabc,
     x          dheati,dheatj,diam,dm_stress,dn,domegr,
     x          dpnrg1,dpnrg2,ds1,dslip,dsold2,
     x          dtact,dthr,dtmpi,dtmpj,dTwirl,duRoll,duRolm,
     x          dviscc,dw,dworkc,dwork1,dwRoll,
     x          dxrel,dxrela,dxrelb,dxrelf,dxreln,dxrelt,
     x          dxrla,dxrlna,dxrlr,dxtch,
     x          epsv,
     x          fabric,fdmpav,fflex,fflexi,fflexj,fflxjo,
     x          fk,fn,Fn_new,fndamp,fnfar,fnnear,fnold,fnolds,
     x          FofPsi,fpcl,fricto,
     x          ft,ft2,ftfrac,ftmag1,ftmavg,ftoldm,ftolds,fttmag,fttot,
     x          Ft_old,Ft_oldo,
     x          Ft_xi,Ft_xit,
     x          hCosin,hSine,J_f,J_w,Jc,kthz,kthhz,l_i,l_j,
     x          nintx,omegar,ovrlap,
     x          p,p_mag,p1_i,p1_j,p2_i,p2_j,
     x          pih,pi2,
     x          Qc,Qci,Qc_new,Qci_new,Qpi,QRot,
     x          qs2,
     x          r1_i,r1_j,r2_i,r2_j,r_i,r_j,
     x          rad_i,rad_j,ratioi,ratioj,rcells,rcf_i,rcf_j,
     x          Reff,rjij,rmean2,rnear2,Rot_i,Rot_j,
     x          rradi,rradj,rrij1,rrij2,rsum,
     x          rtouch,rxcntr,
     x          seprat,stres2,
     x          stress_11,stress_12,stress_13,stress_21,stress_22,
     x          stress_23,stress_31,stress_32,stress_33,
     x          tempav,thetai,thetaj,tol,
     x          Tstar1,
     x          viscc,
     x          X_local,
     x          xreli,xrelj,
     x          zeta
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x          RJag,
     x          zeta_o, zeta_s0, zeta_s1, zeta_s
c
      logical last,last1,last2,last3,lbefor,lcase1,lcase2,lcatch,
     x        lchiav,ldbg,
     x        leras3,leras5,lexep,
     x        lgeom,lincld,lJagEl,lJsphr,lJcone,lJgen,
     x        ln_old,lnear,lnocon,lnr,lother,lprev,
     x        lslidc,ltact,ltogl,ltouch,
     x        plastic
c
c-----double precision arrays
      dimension acoef(0:mlimbs,3:mlimbs),a_i(3),a_j(3),
     x          betahi(2),betalo(2),
     x          c_eta(3),cosbi(3),cosbj(3),cosx(3),
     x          ctheti(3),cthetj(3),
     x          d_xi(2),dftabc(3),dn(4),duRoll(3),
     x          dw(3),dwRoll(3),dwTwrl(3),
     x          d_xi_global(3),d_xio(2),
     x          fabric(3,3,1),
     x          fflex(3),fflexi(3),fflexj(3),fflxjo(3),fpcl(3),
     x          Ft_old(2),Ft_oldo(2),
     x          Ft_xi(2),Ft_xit(3),
     x          Jc(3,3),l_i(3),l_j(3),
     x          nintx(3),p(3),qs2(3,3),
     x          Qc(4),Qci(4),Qc_new(4),Qci_new(4),
     x          Qpi(4),QRot(3,3),
     x          rcells(3),rcf_i(3),rcf_j(3),Rot_i(3,3),Rot_j(3,3),
     x          rxcntr(3),
     x          stres2(3,3),
     x          X_local(3),xreli(3),xrelj(3)
c
c-----real arrays
      dimension ddxrel(3),ddxrlf(3),ddxrlt(3),ddthr(3,2),
     x          domegr(3),
     x          dthr(3,2),dxrel(3),
     x          dxrela(3),dxrelb(3),dxrelf(3),dxrelt(3),
     x          dxrla(3),
     x          fk(3),ft(3),ftolds(3),fttot(3)
      dimension omegar(3)
c
      dimension dftot(3,3)
      dimension deftn(3,3),deftt(3,3),
     x          deft1(3,3),deft2(3,3),deft3(3,3)
      dimension defcl(3,3)
      dimension cost(3),fnew(3),cosft(3)
c
c
c-----these integers will be too large for integer*2 with large assemblies
      dimension iclean1(mlist2,3),iclean2(0:mlist2,4)
c
c-----integer*2 arrays
c
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c
c-----can be used for debugging
      lcatch = .false.
      jcatch = 0
c
c-----whether the contact profile of a Jager-type contact is spherical
c     or conical
      if(lJagr2(rve)) then
        lJcone = .true.
        lJsphr = .false.
        lJgen =  .false.
      elseif(lJagr4(rve)) then
        lJcone = .false.
        lJsphr = .false.
        lJgen =  .true.
      else
        lJcone = .false.
        lJsphr = .true.
        lJgen =  .false.
      endif
c
c
c-----this subroutin calculates the normal and tangential forces
c     between two spherical particles.  It then sums the forces on each
c     particle so that the revised motions can be computed.  The subroutin
c     also computes the average force and other quantities.
c
c-----two algorithms are available for advancing the particle positions:
c       algori=1   standard double integration of particle accelerations,
c                  viscous damping
c       algori=2   standard double integration of particle accelerations, but
c                  particles advanced in a psuedo-static manner
c----------------------------------------------------------------------------
c
c-----Initialize parameters, particle forces, ect.
c
c-----the variable "adjust" represents the portion of the previous time
c     step during which the two particles were in contact.  When adjust=1,
c     then the two particles were in contact for the full time step.
c     When adjust=0.01, then the two particles were in contact for only the
c     the final 0.01*dt of the time step
      adjust = 1.d0
c
c-----the elastic(potential) energy stored in the normal contact springs
      pnrgy1(rve) = 0.
c
c-----the elastic(potential) energy stored in the tangential contact springs
      if(.not.(lJager(rve) .or. lJagr2(rve)
     x         .or. lJagr3(rve) .or. lJagr4(rve))) then
        pnrgy2(rve) = 0.
      else
c-------with Jager contacts, we compute the change in the tangential elastic
c       energy from the previous time step, so that the tangential elastic
c       energy accumulates across time steps.  We start with the energy from
c       the previous time step and multiply by the volume (we do not yet
c       want the energy per volume, which will be computed later.
        pnrgy2(rve) = pnrgy2(rve) * vcellt(rve)
      endif
c
c
c-----the energy wasted in viscous contact movements
      viscc = 0.
c
c-----the energy wasted in frictional contact sliding
      dslide(rve) = 0.
c
c-----the viscous (contact) damping force in the normal direction
      fndamp = 0.
c
c-----magnitude of tangential contact force mid-way within a time step
      ftmavg = 0.
c
c-----misc. contact spring stiffnesses
      kthz = kth(rve)
      kthhz = kthh(rve)
c
c-----are the two particles touching?
      ltact = .false.
c
c-----initialize variable passed to subroutins ellips, ovals,
c     and ovoids for contact detection with elliptical, oval, and
c     ovoid particles:
c
c-----do not look for near-neighbors, just contacts
      lnr = .false.
c
c-----extract the contact geometry (subroutins ovoids, elips, oval, sphere)
      lgeom = .true.
c
c-----the maximum separation at which a contact force will develop.  For
c     standard contact models, in which only short range forces are active,
c     this separation is 0.  That is, a contact force will occur only when
c     the particles are touching.  For other contact models, in which 
c     long-range forces are active, the value can be greater than zero.
      seprat = seprat0(rve)
c
c-----increment of contact viscous dissipation for a particular contact
      dviscc = 0.
c
c-----the threshold "beta" angle for contact detection will equal
c     the input value of "beta" (this will not be relaxed as in a 
c     near-neighbor search.  Assign the cosine and sine of beta to
c     the threshold arrays betahi and betalo
      betahi(1) = cbeta(1,rve)
      betahi(2) = cbeta(2,rve)
      betalo(1) = cbeta(1,rve)
      betalo(2) = cbeta(2,rve)
c
c-----the number of increments used in computing the tangential contact
c     force with a Hertz-Mindlin model.  The contact movement is divided
c     into a series of smaller incremental movements, and the Mindlin
c     tangential force is computed along this path of movements.
      nsteps = 2
      if(lHertz(rve)) then
        plastic = .true.
      endif
c
c-----slip condition
      islip1 = 0
c
c-----we will store the previous orientation of the contact and use
c     this information to compute the rotation of the contact force
c     (use only with the Jager force option).
      ln_old = .true.
c
c-----initialize other variable that will be passed back and forth 
c     to subroutins ellips, ovals, and ovoids for determining whether
c     these particles are in contact
      lnear = .false.
      ltact = .false.
      ldbg = .false.
      ovrlap = 0.
      rad_i = 0.
      rad_j = 0.
      r_i = 0.
      r_j = 0.
      igrain = 0
      jgrain = 0
      m_i = 0
      m_j = 0
      isweep = 0
      rnear2 = 0.
      thetai = 0
      thetaj = 0
      ratioi = 0.
      ratioj = 0.
      rsum = 0.
      lprev = .false.
      betar1 = 0.
      betar2 = 0.
      pih = 0.
      pi2 = 0.
      tol = tolrnc(1,rve)
      arad = 0.
      Reff = 0.
c
c-----initialize orientation value for nobby particles
      cosbi(1) = 0.
      cosbi(2) = 0.
      cosbi(3) = 0.
      cosbj(1) = 0.
      cosbj(2) = 0.
      cosbj(3) = 0.
c
c-----initialize the number of (potential) chattering contacts: both
c     contact chattering or slip chattering
      ichat1 = 0
      ichat2 = 0
c
c-----squared norm of tangential contact force
      ft2 = 0.
c
c-----whether to exit the relaxation loop (when algori=2)
      llast(rve) = .false.
c
c-----the change d(1/V) * V for computing the effect of volume change
c     on the change in stress
      delv = (1.d0/vcell(rve) - 1.d0/vcell0(rve))*vcell0(rve)
c
c-----whether a contact had previously existed, in calculating tangential
c     force with the Jager algorithm
      lbefor = .false.
c
c-----other variables passed to the Jager subroutin
      nlistJ = 0
      nlist2 = 0
c
      fnolds = 0.
      do 10 i = 1,3
c
        fflxjo(i) = 0.
        fflexi(i) = 0.
        fflexj(i) = 0.
        fflex(i) = 0.
        fpcl(i) = 0.
c
c-------initialize stress and contributions to the stress.  See
c       Kuhn, M.R., "Factors Affecting the incremental stiffness of
c       particle assemblies," H. Adeli and R.L. Sierakowski (eds),
c       Mechanics Computing in the 1990s and Beyond, Vol. 2, ASCE,
c       1991, 1229-1233.
c
        ft(i) = 0.
        fttot(i) = 0.
        ftolds(i) = 0.
        fnew(i) = 0.
        cost(i) = 0.
        dxrela(i) = 0.
        dxrelt(i) = 0.
        omegar(i) = 0.
        domegr(i) = 0.
        dthr(i,1) = 0.
        dthr(i,2) = 0.
        ddthr(i,1) = 0.
        ddthr(i,2) = 0.
        dw(i) = 0.
c
        do 12 j = 1,3
          stress(i,j,rve) = 0.
          stres2(i,j) = 0.
          qs2(i,j) = 0.
c
          dftot(i,j) = 0.
          deftt(i,j) = 0.
          deftn(i,j) = 0.
          deft1(i,j) = 0.
          deft2(i,j) = 0.
          deft3(i,j) = 0.
          defcl(i,j) = 0.
c
          fabric(i,j,1) = 0.
c
c---------higher-order stresses
          Jc(i,j) = 0.
   12   continue
c
c-------initialize arrays passed to subroutin ellips, for contact detection
c       with elliptical particles
        c_eta(i) = 0.
        cosx(i) = 0.
        ctheti(i) = 0.
        cthetj(i) = 0.
        l_i(i) = 0.
        l_j(i) = 0.
c
c-------initialize arrays that are used in the Jager algorithm for 
c       tangential contact force
c       Ft_xi(i) = 0.;
        Ft_xit(i) = 0.;
        p(i) = 0.;
        dn(i) = 0.;
        dwRoll(i) = 0.
c
c-------higher-order stresses
        xreli(3) = 0.
        xrelj(3) = 0.
c
c-------contact rolling vector
        duRoll(i) = 0.
c
c-------tangential contact movement
        d_xi_global(i) = 0.
   10 continue
c
c-----Cauchy stress
      stress_11 = 0.
      stress_21 = 0.
      stress_31 = 0.
      stress_12 = 0.
      stress_22 = 0.
      stress_32 = 0.
      stress_13 = 0.
      stress_23 = 0.
      stress_33 = 0.
c
      do 111 i = 1,2
        Ft_xi(i) = 0.
  111 continue
c
c-----factors used in a sinh-dashpot
      if(lsinh(rve)) then
        coef4 = lambda(rve)/n1(rve)/2.d0/boltzman/temprt(rve)
        coef5 = lambda(rve)*(2.d0*boltzman*temprt(rve))/planck
     x          *exp(-(dele(rve)/rgas/temprt(rve)))
        coef7 = 0.5d0*coef5*kratio(rve)*kn(rve)/2.d0
      endif
c
c-----for computing the effect of volume change on the stress increment
      vcell0(rve) = vcell(rve)
c
      do 480 n = 3,mlimbs
c-------factors that are used to compute the average deformation within 
c       void cells in a 2D assembly.  These are the Q coefficients in
c       Kuhn, M.R., "Structured deformation in granular material,"
c       Mechanics of Material, 1999, 31(6), 407--429.
        acoef(0,n) = 0
        acoef(n,n) = 0.
        do 482 i = 1,n-1
          acoef(i,n) = (3.d0*n - 6.d0*i)/dble(n)
  482   continue
  480 continue
c
c-----deformation within a void cell
      do 484 i = 1,ndim1
        do 486 j = 1,ndim1
          dftot(i,j) = 0.
  486   continue
  484 continue
c
c-----the number of sliding contacts
      nslide(rve) = 0
c
c-----the average overlap among all contacting particles. With this measure,
c     we count multiple contacts between a particle pair as a single contact
      ovrsav(rve) = ovravg(rve)
      ovravg(rve) = 0.
c
c-----the average overlap among all contacting particles. With this measure,
c     we find the average overlap by individual contacts
      ovrsavz(rve) = ovravgz(rve)
      ovravgz(rve) = 0.
c
c-----the average normal force among the contacts
      fnavg(rve) = 0.
c
c-----the average normal force among sliding contacts
      fnavg2(rve) = 0.
c
c     start the relaxation cycle
c----------------------------------------------------------------------------
c
c-----the relaxation loop counter
      iloops = 1
c
c-----the logical variable 'last' when the contact forces are computed for
c     the last time (after establishing the relaxed particle positions, or
c     if the double-integration algorithm is being used).  The last loop
c     is distinguished from previous loops by:
c       1) contact forces are computed only once per contact and then added
c          to the two neighboring particles.  During other loops, the contact
c          forces are computed one particle at a time, so that each contact
c          is computed twice.
c       2) the linked list of tangential contact forces is updated
c
  101 continue
c
      lchiav = chiavg(rve).lt.chimax(rve)
c
      last =  (algori.eq.2
     x             .and. (((iloops.gt.nloops
     x                      .or. (iloops.gt.nloop1
     x                            .and.  lchiav
     x                            .and.  iloops.gt.nlpmin)
     x                     .or. linit(rve)                          ))
     x          ))
     x        .or. algori.eq.1
c
c-----the sum of the squared contact forces (for use in calculating ch1, etc.)
      ftsq(rve) = 0.
c
c-----the number of contacting particle pairs
      ntacts(rve) = 0
c
c-----number of contacts, which will differ from "ntacts" with non-convex
c     particles, which can have multiple contacts between 
c     a single particle pair
      ntactz(rve) = 0
c
c-----the number of contacts that are either touching or are
c     affected by long range forces
      nnear(rve) = 0
c
c-----the energy wasted in frictional sliding
      dslide(rve) = 0.
c
c-----the average contact force due to contact damping
      fdmpav = 0.
c
c-----number of instances requiring cleaning of linked lists
      nclean1 = 0
      nclean2 = 0
      iclean2(0,2) = 0
c
c-----for Jager contacts, initialize values that are passed between
c     subroutins forces and Jager_3D
      if(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)
     x   .or. lJagr4(rve)) then
        do 139 i4 = 0,mlist2
          iremov(i4,rve) = 0
          RJag(i4,rve) = 0.
          zeta_o(i4,rve) = 0.
          zeta_s0(i4,rve) = 0.
          zeta_s1(i4,rve) = 0.
          Fn_o(i4,rve) = 0.
          Fn_s0(i4,rve) = 0.
          Fn_s1(i4,rve) = 0.
          p_s0(i4,1,rve) = 0.
          p_s0(i4,2,rve) = 0.
          Ft_s(i4,1,1,rve) = 0.
          Ft_s(i4,1,2,rve) = 0.
          Ft_s(i4,2,1,rve) = 0.
          Ft_s(i4,2,2,rve) = 0.
          islip2(i4,rve) = 0
  139   continue
      endif
c
c-----whether to exit the relaxation loop (when algori=2)
      llast(rve) = last
      last1 = last
      last2 = last
      last3 = llast(rve) .and. lout(3)
c
c-----the number of interation in torus-torus contact determination
      nsweep = 0
c
c-----the number of torus-torus pairs
      ntorus = 0
c
      do 45 igrain = 1,np(rve)
c-------initialize the force on each particle
        do 47 j = 1,ndim1
          f(j,igrain,rve) = 0.
   47   continue
c
c-------initialize the moments on each particle
        do 49 j = ndim2,3
          fth(j,igrain,rve) = 0.
   49   continue
c
c-------initialize the number of sliding neigbors around each particle
        nslidc(igrain,rve) = 0
   45 continue
c
c-----we will count the number of contacts on each particle
      do 27 igrain = 1,np(rve)
        nabors(igrain,rve) = 0
   27 continue
c
c------------------------------------
c
c-----in this "do 100" loop, we examine all near-neighbor pairs in the 
c     linked list, perform contact detection, calculate the contact forces,
c     calculate the total force and moment imbalance on each particle, 
c     and increment the average stress tensor. 
c
      do 100 igrain = 1,np(rve)
c
c-------the pointer to the first particle's location within the linked list.  
        ipt1 = igrain
c
        if(lbumpy(rve)) then
          Qpi(1) = Qp(1,igrain,rve)
          Qpi(2) = Qp(2,igrain,rve)
          Qpi(3) = Qp(3,igrain,rve)
          Qpi(4) = Qp(4,igrain,rve)
c
c---------this subroutin uses the quaternion "Qp" to find the corresponding
c         rotation 3x3 matrix
          call QRotationMatrix(Qpi,Rot_i)
        endif
c
c-------in this "do 90" loop, we search through the linked list for all
c       of the near-neighbors of igrain
        do 90 while (list2(ipt1,rve).ne.0)
c
c---------the next pointer in igrain's list
          ipt1 = list2(ipt1,rve)
c
c---------the next near-neighbor particle (component) in igrain's list.  
          jgrain = list1(ipt1,rve)
c
          lincld = .true.
c
c---------whether a sliding contact exists between these two particles.
c         Required when idamp=3
          lslidc = .false.
c
c---------note that the linked list is a singly-directed linked list.
c         jgrain should always be .gt. igrain
c
c---------initialize an array that will be used to determine whether
c         a periodic boundary has been straddled by the pair of particles
          do 129 k = 1,ndim1
            rcells(k) = 0.
  129     continue
c
          do 30 k = 1,ndim1
c-----------branch vector between the centers of the two particles
            rxcntr(k) = xp(k,jgrain,rve) - xp(k,igrain,rve)
c
c-----------the number of periodic cell boundaries between the particle pair
c           (for example, when the pair straddles a periodic boundary)
            do 31 l = 1,ndim1
              rcells(l) = rcells(l) + xcelli(l,k,rve)*rxcntr(k)
   31       continue
   30     continue
c
c---------the integer number of periodic boundaries crossed by the
c         particle pair.
          do 137 k = 1,ndim1
            nintx(k) = nint(rcells(k))
  137     continue
c
          do 33 k = 1,ndim1
            do 34 l = 1,ndim1
c-------------adjust the distance between the two particles, adjusting
c             for the number of periodic boundaries crossed by the
c             particle pair.
c
c-------------branch vector between the centers of the two particles
              rxcntr(k) = rxcntr(k) - xcell(k,l,rve)*nintx(l)
   34       continue
   33     continue
c
          if(lbumpy(rve)) then
            Qpi(1) = Qp(1,jgrain,rve)
            Qpi(2) = Qp(2,jgrain,rve)
            Qpi(3) = Qp(3,jgrain,rve)
            Qpi(4) = Qp(4,jgrain,rve)
c
c-----------this subroutin uses the quaternion "Qp" to find the corresponding
c           rotation 3x3 matrix
            call QRotationMatrix(Qpi,Rot_j)
          endif
c
c---------CONTACT DETECTION AND FORCE COMPUTATION------------
c
c---------were the two particles NOT touching at t-dt?
          ltouch = liste(ipt1,rve).eq.0
c
c---------with composite particles (such as ovals and ovoids), we must
c         identify certain geometric parameters for the several component
c         pieces of each particle
          if(lcircl(rve).or.lspher(rve)) then
c
c-----------radii of the two particles
            r_i = rad(igrain,rve)
            r_j = rad(jgrain,rve)

c-----------radii of curvature at the contact point (for computing contact
c           force with Hertzian contacts)
            rad_i = rad(igrain,rve)
            rad_j = rad(jgrain,rve)
          elseif(loval(rve) .or. lovoid(rve)) then
c-----------prepare data to pass to subroutins "ovals" or "ovoids", 
c           which will check whether the particles are contacting.  
c           The array a_vect( , ) contains the unit orientation vectors 
c           for all particles.  Just pass the 4 or 6 values that are needed 
c           for the two particles:
            a_i(1) = a_vect(1,igrain,rve)
            a_i(2) = a_vect(2,igrain,rve)
            a_j(1) = a_vect(1,jgrain,rve)
            a_j(2) = a_vect(2,jgrain,rve)
c
            if(lovoid(rve)) then
              a_i(3) = a_vect(3,igrain,rve)
              a_j(3) = a_vect(3,jgrain,rve)
            endif
c
c-----------dimensions of the component pieces of the two particles
            r1_i = r_piec(1,igrain,rve)
            r1_j = r_piec(1,jgrain,rve)
            r2_i = r_piec(2,igrain,rve)
            r2_j = r_piec(2,jgrain,rve)
            p1_i = r_piec(3,igrain,rve)
            p1_j = r_piec(3,jgrain,rve)
            p2_i = r_piec(4,igrain,rve)
            p2_j = r_piec(4,jgrain,rve)
c
c-----------radii of the two particles
            r_i = rad(igrain,rve)
            r_j = rad(jgrain,rve)
          elseif(lnobby(rve)) then
c
c-----------radii of the two particles
            r_i = rad(igrain,rve)
            r_j = rad(jgrain,rve)
c
c-----------orientation cosines of the two particles
            cosbi(1) = cos(theta(3,igrain,rve))
            cosbi(2) = sin(theta(3,igrain,rve))
            cosbj(1) = cos(theta(3,jgrain,rve))
            cosbj(2) = sin(theta(3,jgrain,rve))
          elseif(lbumpy(rve)) then
c
c-----------radii of the two particles
            r_i = rad(igrain,rve)
            r_j = rad(jgrain,rve)
          endif
c
c---------we will treat all particle types (including circles and spheres)
c         as if they are composite particles (a circle, sphere, or ellipse
c         is simply a composite particle with a single component piece)
c
c---------no contact has yet been found among the component pieces of the
c         two particles
          lnocon = .true.
c
c---------consider the combinations of component pieces that are 
c         near-neighbors for this pair of particles
          ipart = 0
c
c---------the number of pairs of component pieces that are near-neighbors
c         for the two particles
          nparts = list3(ipt1,0,rve)
c
c---------This is index of the pair of component pieces that was in contact
c         during the previous deformation step.  We will start our contact
c         search with this pair.  If this pair is no longer in contact, we
c         will check the other pairs of component pieces.
          jpart = list3(ipt1,-1,rve)
c
c---------In certain cases, we want to force the reporting of information
c         about contact indentations
          lexep = .not.ltouch .and. last .and. lout(4)
c
c---------search through the pairs of component pieces for a contact.  The
c         logical variable "lnocon" is true until a contact is found, then
c         it becomes false so that the search ends.  The logical variable
c         "lconvx" is true for convex particle shapes, which can only
c         contact each other at a single point (unlike nobby and
c         bumpy particles)
          do 91 while ((lconvx(rve)
     x                   .and. (ipart.le.nparts-1 .and. lnocon))
     x                 .or. (.not.lconvx(rve) .and. ipart.le.nparts-1))
c
c-----------the pair of component pieces that is currently be checked
            kpart = mod(jpart+ipart,nparts)
c
c-----------fix the modulo value
            if(kpart.eq.0) then
              kpart = nparts
            endif
c
c-----------consider the component pieces from the two particles.  Extract
c           the types of components from the digits of list3
            m_i = list3(ipt1,kpart,rve)/10
            m_j = mod(list3(ipt1,kpart,rve),10)
c
c-----------compute whether the two particles (or arcs) are touching
            if(lcircl(rve).or.lspher(rve)) then
c-------------circular or spherical particles
c
c-------------establish whether contact has occured, and if so, compute
c             various auxilary quantities
              call sphere(r_i,r_j,rxcntr,seprat,ndim1,lexep,lgeom,
     x                    c_eta,ovrlap,l_i,l_j,carea,ltact)
c
            elseif(loval(rve)) then
c-------------oval particles
c
c-------------establish whether contact has occured, and if so, compute
c             various auxilary quantities
              call ovals(a_i,a_j,betahi,betalo,
     1            p1_i,p1_j,p2_i,p2_j,
     2            r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,seprat,
     3            m_i,m_j,lgeom,
     4
     5            c_eta,ovrlap,l_i,l_j,ltact)
c
            elseif(lnobby(rve)) then
c-------------nobby particles
c
c-------------establish whether contact has occured, and if so, compute
c             various auxilary quantities
              call nobby(r_i,r_j,cenrad(rve),satrad(rve),
     2                   rxcntr,cosa,cosbi,cosbj,
     3                   m_i,m_j,lgeom,lexep,seprat,lhiddn(rve),
     4
     5                   c_eta,ovrlap,l_i,l_j,ltact,
     6                   rve, mrve)
c
            elseif(lelips(rve)) then
c-------------ellipse particles
c
c-------------prepare data that will be passed to the contact detection
c             subroutin "ellips"
              ctheti(1) = ctheta(1,igrain,rve)
              ctheti(2) = ctheta(2,igrain,rve)
              cthetj(1) = ctheta(1,jgrain,rve)
              cthetj(2) = ctheta(2,jgrain,rve)
              thetai = theta(3,igrain,rve)
              thetaj = theta(3,jgrain,rve)
              ratioi = aspect(igrain,rve)
              ratioj = aspect(jgrain,rve)
              rradi = rad(igrain,rve)
              rradj = rad(jgrain,rve)
c
c-------------establish whether contact has occured.  The subroutin ellips
c             will also compute the amount of overlap and information
c             concerning the location of the contact point
c
              call ellips(lnear,
     x               ltact,ovrlap,c_eta,rad_i,rad_j,
     x               ctheti,cthetj,l_i,l_j,lnr,lgeom,
     x               rradi,rradj,ratioi,ratioj,rxcntr,
     x               sep(rve),thetai,thetaj)
c
            elseif(lovoid(rve)) then
c-------------ovoid particles
c
c-------------radii of curvature at the contact point (for computing contact
c             force with Hertzian contacts).  Rather than using the 
c             mean curvature (the proper approach), we will use the average
c             radius of the ovoid
              rad_i = r_i*(2.d0 + aspect(igrain,rve))/3.d0
              rad_j = r_j*(2.d0 + aspect(jgrain,rve))/3.d0
c
c-------------establish whether the two ovoids are touching within the
c             two component pieces, and if so, compute various auxilary
c             quantities
              call ovoids(a_i,a_j,betahi,betalo,
     1                    p1_i,p1_j,p2_i,p2_j,
     2                    r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                    seprat,tol,
     3                    m_i,m_j,lgeom,
     4                 
     5                    c_eta,ovrlap,l_i,l_j,isweep,ltact)
c
c-------------for diagnostic purposes, find the number of torus-torus
c             pairs and the number of iterations for their 
c             contact determination
              if(isweep.ne.0) then
c---------------a torus-torus pair
                ntorus = ntorus + 1
                nsweep = nsweep + isweep
              endif
c
            elseif(lbumpy(rve)) then
c-------------3D bumpy particles
              continue
c
c-------------radii of curvature at the contact point (for computing contact
c             force with Hertzian contacts)
              rad_i = r_i*s_rad(m_i,rve)
              rad_j = r_j*s_rad(m_j,rve)
c
c-------------establish whether contact has occured, and if so, compute
c             various auxilary quantities
              call bumpy(r_i, r_j, b_rad, s_rad, xlocal,
     x                   rxcntr, Rot_i, Rot_j, m_i, m_j,
     x                   lgeom, lexep, seprat,
     x                   c_eta, ovrlap, l_i, l_j, ltact,
     x                   rve, mrve)
              continue

            endif
c
c-----------when there is no contact and we have exhausted all near-neighbor
c           pairs of component pieces for the pair of particles
            if(.not.ltact) then
c------------- NO CONTACT ----------------------------------------
c
c-------------check whether the contact is freshly broken
              if(.not.ltouch) then
c---------------the two particles were touching in the previous time step, 
c               The particular contact between the particles may be freshly
c               broken.  Some bookkeeping is required to remove the contact
c               from linked lists, etc.
c
                if(last2) then
c-----------------it's time to do that bookkeeping
c
c-----------------the two particles were touching in the previous time step
c
c-----------------if leras3 becomes .true. then the two particles are no longer
c                 touching.  If leras5 becomes .true. then the two particles
c                 are no longer touching at the particular contact (for
c                 non-convex particles)
                  leras3 = .false.
                  leras5 = .false.
c
                  if (lconvx(rve) .and. ipart.eq.nparts-1) then
c-------------------the two particles are convex, so they can only touch at
c                   a single point.  And we have exhausted all near-neighbor
c                   pairs of component pieces for the pair of particles
c
c-------------------pointer to information on this contact
                    ipt5 = liste(ipt1,rve)
c
                    leras3 = .true.
                    leras5 = .true.
c
                  elseif(.not.lconvx(rve)) then
c-------------------the two partcles are non-convex, so they can touch at
c                   multiple points.  We know that the two particles were 
c                   touching in at least one point during the previous time 
c                   step. There are three possiblities.
c                       1) The particles were touching, but not at this
c                          particular contact.
c                       2) The particles were touching only at this one contact
c                       3) The particles were touching at multiple contacts,
c                          including this contact
c                   In the first situation, nothing needs to be done with
c                   the lists.  In the second situation, we must eliminate
c                   the item from both the contact list and the particle-
c                   touching lists.  In the third situation, we must elimate
c                   the item from the contact list only.
c
c                   Search through "listf0" to find (1) whether this 
c                   particular contact had existed in the previous time
c                   step, and (2) if it did exist, whether there were 
c                   other contacts between the two particles (lother = .true.)
                    lother = .false.
                    ihit = 0
                    j4 = 0
c
c-------------------liste points to the first contact of this pair of particles
                    i4 = liste(ipt1,rve)
                    do 804 while (i4.ne.0)
                      if(listf1(i4,rve).eq.m_i
     x                   .and. listf2(i4,rve).eq.m_j) then
c-----------------------this contact was present in the previous time step
                        ihit = i4
                        jhit = j4
                      else
c-----------------------other contacts were present between the two particles
                        lother = .true.
                      endif
                      j4 = i4
                      i4 = listf0(i4,rve)
  804               continue
c
                    if(ihit.eq.0 .and. lother) then
c---------------------case (1): The particles were touching, but not at this
c                     particular contact. Don't do anything.
                    elseif(ihit.ne.0 .and. .not.lother) then
c---------------------case (2): The particles were touching only at this one
c                     contact
                      leras3 = .true.
                      leras5 = .true.
                      ipt5 = ihit
                    elseif(ihit.ne.0 .and. lother) then
c---------------------case (3): The particles were touching at multiple
c                     contacts, including this contact
                      leras5 = .true.
                      ipt5 = ihit
                    else
                      write(ScrUnit(rve),*) 
     x                  'Error in subroutin forces: strange case3a'
                    endif
                  endif
c
                  if(leras3.or.leras5) then
c-------------------we will clean the linked lists after all contacts
c                   are analyzed.  This will enable simpler
c                   parallelization. Gather the changes here.
                    nclean1 = nclean1 + 1
                    iclean1(nclean1,1) = ipt1
                    iclean1(nclean1,2) = m_i
                    iclean1(nclean1,3) = m_j
                  endif
c
                  if(leras5) then
c-------------------information about this contact must be removed, since
c                   the contact no longer exists
c
c-------------------reset the tangential contact force
                    do 260 k = 1,ndim1
                      ftold(k,ipt5,rve) = 0.
                      l_i_old(k,ipt5,rve) = 0.
  260               continue
c
c-------------------reset the normal contact force
                    fnold1(ipt5,rve) = 0.
c
c-------------------reset the slip condition
                    islip(ipt5,rve) = 0
c
c-------------------reset the branch of the long-range contact force
c                   (imodel=3 only)
                    if(imodel(rve).eq.3) then
                      ifn_togl(ipt5,rve) = 0
                    elseif(lHertz(rve)) then
                      Tstar(ipt5,rve) = 0.
                    endif
c
c-------------------used in computing tangential force in a sinh-dashpot
                    if(lsinh(rve)) then
                      dsold1(ipt5,rve) = 0.
                    endif
c
c-------------------reset whether sliding was occuring at the contact
                    lplold(ipt5,rve) = .false.
c
c-------------------reset these values for use in output to F-files
                    if(ndim1.eq.2) then
                      c_etas(1,ipt5,rve) = 0.
                      c_etas(2,ipt5,rve) = 0.
c
c---------------------reset these values for use in output to F-files.  They are
c                     associated with the particle-pair, not a contact (in the
c                     case of non-convex particles with multiple contacts).
                      branch(1,ipt5,rve) = 0.
                      branch(2,ipt5,rve) = 0.
                    endif
c
                    if(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)
     x                 .or. lJagr4(rve)) then
c---------------------reset information for use in the Jager algorithm for 
c                     contact force
                      c_etas(1,ipt5,rve) = 0.
                      c_etas(2,ipt5,rve) = 0.
                      c_etas(3,ipt5,rve) = 0.
c
c---------------------quaternion orientation of local contact frame
                      if(l3d) then
                        Qc_old(1,ipt5,rve) = 0.
                        Qc_old(2,ipt5,rve) = 0.
                        Qc_old(3,ipt5,rve) = 0.
                        Qc_old(4,ipt5,rve) = 0.
                      endif
c
                      xi_old(1,ipt5,rve) = 0.
                      xi_old(2,ipt5,rve) = 0.
c
c---------------------Flush three lists of load-path data for this 
c                     contact: zeta_s(), Fn_s(), tan_b().  Also,
c                     pointer listk to 0, and rearrange the linked list
c                     listJ
c---------------------set a flag for flushing the list later in
c                     subroutin forces
                      iremov(ipt5,rve) = -1
                    endif
c
c-------------------with 4-arc ovals, reset the storage of the particular 
c                   arcs that are touching.  The information is written to
c                   an output G-file for input to the graphics OvalPlot
c                   program.  The array quad() is not used internally within
c                   the program Oval
                    if(loval(rve)) then
                      quad(1,ipt5,rve) = 0
                      quad(2,ipt5,rve) = 0
                    endif
                  endif
c
                  if(leras3) then
c-------------------the two particles are no longer touching
                    if(.not.lconvx(rve)) then
c---------------------the particles are not convex
                      ipt3 = 0
                      ltouch = .true.
                    endif
                  endif
                endif
              else
                lincld = .false.
              endif
c
            elseif(ltact) then
c-------------a CONTACT -----------------------------------------------
c
c-------------whether this particular contact had existed in the previous
c             time step
              lbefor = .false.
c
c-------------new contacts can be of two types: (1) the first contact between
c             two particles, and (2) an additional contact between two 
c             non-convex particles that were previously touching.  We will
c             assume that neither is true
              lcase1 = .false.
              lcase2 = .false.
c
c-------------establish the pointers ipt3 and ipt5 of the contact information
              if(ltouch) then
c---------------the two particles were NOT touching in the previous time
c               step (case 1, above), so (1) the two particles are now 
c               touching but were not touching before, and (2) a new contact
c               exists.  Note that with non-convex particles, (2) does 
c               not imply (1)
c
c---------------do not include this contact in local strain calculations
                lincld = .false.
c
c---------------mark this contact for initializing later
                lcase1 = .true.
c
              else
c---------------the two particles were touching in the previous time step
c
                if (lconvx(rve)) then
c-----------------the two particles are convex, so they can only touch at
c                 a single point.
c
c-----------------pointer to information on this contact
                  ipt5 = liste(ipt1,rve)
c
c-----------------the fraction of the previous time step in which the 
c                 particles were in contact
                  rtouch = 1.d0
c
c-----------------this contact had existed in the previous time step
                  lbefor = .true.
                else
c-----------------the two partcles are non-convex, so they can touch at
c                 multiple points.  We know that the two particles were 
c                 touching in the previous time step. Search through the 
c                 array "listf0" to determine whether this same contact
c                 existed in the previous time step.
c
c-----------------assume that the contact was fully established throughout
c                 the previous time step
                  rtouch = 1.d0
c
c-----------------the two particles were touching prior to this time step,
c                 but this is a new contact between a non-convex pair
c                 of particles
                  ipt5 = 0
                  i4 = liste(ipt1,rve)
                  do 802 while (i4.ne.0)
                    if(listf1(i4,rve).eq.m_i
     x                 .and. listf2(i4,rve).eq.m_j) then
                      ipt5 = i4
                    endif
                    i4 = listf0(i4,rve)
  802             continue
c
                  if(ipt5.ne.0) then
c-------------------this contact had previously existed
                    lbefor = .true.
                  else
c-------------------mark this contact for initializing later
                    lcase2 = .true.
                  endif
                endif
              endif
c
              if(lcase1.or.lcase2) then
                nclean2 = nclean2 + 1
                iclean2(nclean2,1) = ipt1
                iclean2(nclean2,2) = listf0(iclean2(nclean2-1,2),rve)
                iclean2(nclean2,3) = m_i
                iclean2(nclean2,4) = m_j
c
                ipt5 = iclean2(nclean2,2)
c               write(ScrUnit(rve),*) iclean2(nclean2,1)
c
                if(listf0(ipt5,rve).eq.-1) then
                  write(ScrUnit(rve),910)
     x              timer(rve),igrain,jgrain,mlist2
                  write(ErrUnit(rve),910)
     x              timer(rve),igrain,jgrain,mlist2
  910             format('array listf0() is too short in subroutin',
     x                      'force. '
     x             ,/,'  Try changing mlist2 in the',
     x                ' param-dempla-0.2.2.f file and recompiling.'
     x             ,/,'  time=',1pe12.4,'  igrain=',i6,
     x                '  jgrain=',i6,'  mlist2=',i7)
                  stop
                endif
              endif
c
              if(lcase2) then
c---------------the fraction of the previous time step in which the
c               contact existed
                rtouch = 0.
              endif
c
              if(last2 .and. (lcase1.or.lcase2)) then
c---------------re-initialize the contact forces that were orginally
c               being stored for an old contact
                do 333 k = 1,ndim1
                  ftold(k,ipt5,rve) = 0.
                  l_i_old(k,ipt5,rve) = 0.
  333           continue
c
c---------------re-initialize the normal contact force
                fnold1(ipt5,rve) = 0.
c
c---------------reset the slip condition
                islip(ipt5,rve) = 0
c
c---------------reset the branch of the long-range contact force,
c               as in Thornton and Randall (1988) 
c               (imodel=3 only)
                if(imodel(rve).eq.3) then
                  ifn_togl(ipt5,rve) = 0
                elseif(lHertz(rve)) then
                  Tstar(ipt5,rve) = 0.
                endif
c
                if(lsinh(rve)) then
                  dsold1(ipt5,rve) = 0.
                endif
c
c---------------re-initialize whether the contact was sliding
                lplold(ipt5,rve) = .false.
c
c---------------store these values for use in output to F-files
                if(ndim1.eq.2) then
c-----------------the contact unit normal vector
                  c_etas(1,ipt5,rve) = 0.
                  c_etas(2,ipt5,rve) = 0.
                endif
c
c---------------with 4-arc ovals, reset storage of the particular arcs 
c               that are touching.  The information is written to
c               an output G-file for input to the graphics OvalPlot
c               program.  The array quad() is not used internally withen
c               the program Oval.
                if(loval(rve)) then
                  quad(1,ipt5,rve) = 0
                  quad(2,ipt5,rve) = 0
                endif
c
                if(lJager(rve) .or. lJagr2(rve)
     x             .or. lJagr3(rve) .or. lJagr4(rve)) then
c-----------------reset information for use in the Jager algorithm for 
c                 contact force
                  listk(ipt5,rve) = Zero
                  c_etas(1,ipt5,rve) = 0.
                  c_etas(2,ipt5,rve) = 0.
                  c_etas(3,ipt5,rve) = 0.
                  if(l3d) then
                    Qc_old(1,ipt5,rve) = 0.
                    Qc_old(2,ipt5,rve) = 0.
                    Qc_old(3,ipt5,rve) = 0.
                    Qc_old(4,ipt5,rve) = 0.
                  endif
                  xi_old(1,ipt5,rve) = 0.
                  xi_old(2,ipt5,rve) = 0.
                endif
              endif
c
c-------------normal force calculation
c
c-------------the normal force is composed of two parts: a parts that derives
c             for the contact of the two particles (fnnear), and a long range
c             part that can occur at a distance (fnfar).
              fnfar = 0.
c
c-------------initialize normal force to zero
              fn = 0.
c
              if(imodel(rve).eq.0 .or. lsinh(rve)) then
c---------------a linear (spring) contact: fn = ovrlap*knh
                call fn_model0(knh(rve), ovrlap, fnfar, fnnear)
c
c---------------We separate the normal force into two parts: a part due to
c               the actual touching of the particles (fnnear), and a long-range
c               force (fnfar) that can be active even when the particles do
c               not touch
                fn = fnnear
              elseif(imodel(rve).eq.1) then
c---------------a piece-wise linear model with long-range forces
                call fn_model1
     x               (knh(rve), ovrlap, seprat0(rve), pforce, psep,
     x                lc2, ldiams,
     x                fnfar, fnnear, ScrUnit, rve, mrve)
                fn = fnnear
              elseif(imodel(rve).eq.2) then
                diam = rad(igrain,rve) + rad(jgrain,rve)
                call fn_model2
     x               (diam, knh(rve), ovrlap,
     x                seprat0(rve), pforce, psep, 
     x                lc2, ldiams, nsepf, fnfar, fnnear,
     x                sepdia)
                fn = fnnear
              elseif(imodel(rve).eq.3 .or. imodel(rve).eq.4) then
                jfn_togl = ifn_togl(ipt5,rve)
                call fn_model34(fnfar, fnnear,
     x                       knh(rve),knsep2(rve),knseph(rve), 
     x                       ovrlap, psep1(rve), psep2(rve), jfn_togl)
                fn = fnnear
              elseif(lHertz(rve)) then
c---------------a Hertz type contact
                rad_i = rad(igrain,rve)
                rad_j = rad(jgrain,rve)
                call Hertz(rad_i, rad_j, ovrlap,
     x                     Ebar(rve),fnnear,Reff,arad)
                fn = fnnear
              endif
c
c-------------the number of contacts for each of the two particles
              nabors(igrain,rve) = nabors(igrain,rve) + 1
              nabors(jgrain,rve) = nabors(jgrain,rve) + 1
c
              if(ovrlap.ge.0. .and. lnocon) then
c---------------the total number of contacting pairs in the assembly
                ntacts(rve) = ntacts(rve) + 1
              endif
c
c-------------flag to stop searching for a contact between other components
c             of these two particles (we have already found the contact)
              lnocon = .false.
c
c-------------update the index for this pair of component pieces, so that
c             the next contact search will begin with this pair
              list3(ipt1,-1,rve) = kpart
c
c-------------before we can compute the tangential contact force we will 
c             need to determine the contact movement, establish whether 
c             this is a new contact, etc.
              if(last) then
                adjust = 1.d0
              endif
c
              if((lfrict(rve) .or. lsinh(rve))
     x           .or. ((lHertz(rve) .or. lJager(rve)
     x                   .or. lJagr2(rve) 
     x                   .or. lJagr3(rve) .or. lJagr4(rve)) 
     x                 .and. frict(rve).gt.0.)) then
c---------------the standard, frictional contact, or the "sinh-dashpot".
c               Note that this section of code is skipped when friction
c               is "turned off" by setting the friction coefficient
c               frict=0.
c
                fricto = frict(rve)
c
                dxreln = 0.
                ddxrln = 0.
                ddxrlr = 0.
                dxrlna = 0.
                do 38 k = 1,ndim1
c-----------------the relative movement (not rotation) between the particles
                  dxrel(k) = dx(k,jgrain,rve) - dx(k,igrain,rve)
c
                  dxrla(k) = 0.
                  do 37 l = 1,ndim1
c-------------------correct the relative movement in the event that the
c                   two particles "straddle" a periodic boundary
                    dxrel(k) = dxrel(k) - dxcell(k,l,rve)*nintx(l)
   37             continue
c
                  if(lcdamp(rve)) then
c-------------------when contact damping is being used, we need to compute
c                   the rate of movement at the contact
                    ddxrel(k) = (vh(k,jgrain,rve)
     x                           - vh(k,igrain,rve))*dt(rve)
                  endif
   38           continue
c
c---------------get ready to compute the contact movement produced by
c               particle rotations
                do 249 k = ndim2,3
                  dthr(k,1) = dth(k,igrain,rve)
                  dthr(k,2) = dth(k,jgrain,rve)
  249           continue
c
                if(lcdamp(rve)) then
c-----------------contact damping is being used.  We need to compute the
c                 rate of contact movement produced by particle spins
                  do 40 k = ndim2,3
                    ddthr(k,1) = vhth(k,igrain,rve)*dt(rve)
                    ddthr(k,2) = vhth(k,jgrain,rve)*dt(rve)
   40             continue
                endif
c
c---------------compute the contact movement produced by the particle
c               rotations
                call omega(ddthr,dthr,l_i,l_j,l3d,lcdamp(rve),
     x                     domegr,omegar)
c
                dxrlr = 0.
                do 50 k = 1,ndim1
c
c-----------------the total amount of relative movement between the two
c                 particles at the contact point
                  dxrelf(k) = dxrel(k)  + omegar(k)
c
c-----------------the rate at which the relative movement is occuring
c                 between the two particles at the contact point
                  ddxrlf(k) = ddxrel(k) + domegr(k)
c
c-----------------the component of movement in the direction of the 
c                 contact normal vector
                  dxreln = dxreln + dxrelf(k)*c_eta(k)
c
c-----------------the component of the rate of movement in the direction of
c                 the contact normal vector
                  ddxrln = ddxrln + ddxrlf(k)*c_eta(k)
c
c-----------------the component of movement due to particle displacements
c                 (not rotations) in the direction of the contact normal vector
                  dxrlr = dxrlr + dxrel(k)*c_eta(k)
   50           continue
c
c---------------determine whether the contact was established during the
c               time step.  
c                  rtouch=1.0: contact has been established for the full step
c                  rtough=0.5: contact was established at mid-step
c                  rtouch=0.0: contact has just been established
                if(     (lconvx(rve)      .and. ltouch) 
     x             .or. (.not.lconvx(rve) .and. .not.lbefor)) then
c-----------------note that rtouch<1 only when the contact had not existed
c                 in the previous time step
                  dxtch = -ovrlap
                  if(dxreln.ne.0.) then
                    rtouch = dxtch/dxreln
                    if(rtouch.le.0.) then
                      rtouch = .1d0
                    elseif(rtouch.gt.1.d0) then
                      rtouch = 1.d0
                    endif
                  else
c-------------------the contact had existed before
                    rtouch = 1.d0
                  endif
                endif
c
c
c---------------compute the Cartesian components of certain vectors that
c               are related to the tangential contact force
                do 63 k = 1,ndim1
c-----------------the total amount of relative movement between the two
c                 particles at the contact point and in the tangential
c                 direction.  Note that we multiply by rtouch, in the
c                 event that the contact is established during the current
c                 time step.  (The contact spring can not compress until
c                 the particles are in contact.)
                  dxrelt(k) = (dxrelf(k) - dxreln*c_eta(k))*rtouch
c
c-----------------the rate of relative movement between the two
c                 particles at the contact point in the tangential
c                 direction
                  ddxrlt(k) = ddxrlf(k) - ddxrln*c_eta(k)
c
c-----------------the movement due to particle displacements (not rotation) 
c                 in the contact tangential direction
                  dxrela(k) = dxrel(k) - dxrlr*c_eta(k)
c
c-----------------the movement due to particle displacements (not rotation)
c                 in the contact normal direction
                  dxrelb(k) = dxrlr*c_eta(k)
   63           continue
c
c---------------determine the components of tangential force----------------
c
c---------------is the contact frictional with linear stiffness?
                if((lfrict(rve).or.lsinh(rve)) .and. fn.gt.0.) then
c-----------------a simple frictional contact mechanism with linear
c                 tangential stiffness
c
                  do 153 k = 1,ndim1
c-------------------the previous tangential force, stored in the
c                   linked list ftold()
                    ftolds(k) = ftold(k,ipt5,rve)
  153             continue
                  fnolds = fnold1(ipt5,rve)
c
c
c-----------------with temperature-dependent model, find change in
c                 the contact friction coefficient that results from 
c                 temperature change
                  if(iheat(rve).eq.1 .and. hmodel(rve).eq.1) then
c-------------------contact temperature.  Average of particle temperatures
                    tempav = 0.5d0
     x                       * (tempr(igrain,rve) + tempr(jgrain,rve))
c
                    if(lfrict(rve)) then
c---------------------adjust the friction coefficient.  Note that tdepf
c                     should be negative, if the coefficient decreases with
c                     increasing temperature
                      fricto = fricto
     x                         + tdepf(rve)*(tempav - ambtmp(rve))
c
c---------------------apply minimum friction coefficient, if applicable
                      if(fricto.lt.frictm(rve)) then
                        fricto = frictm(rve)
                      endif
                    elseif(lsinh(rve)) then
                      coef4 = lambda(rve)/n1(rve)/2.d0/boltzman/tempav
                      coef5 = lambda(rve)*(2.d0*boltzman*tempav)/planck
     x                        *exp(-(dele(rve)/rgas/tempav))
                      coef7 = 0.5d0*coef5*kratio(rve)*kn(rve)/2.d0
                    endif
                  endif
c
c-----------------call the subroutin frictn that computes the tangent force for
c                 a simple linear contact
                  if(lfrict(rve)) then
                    if(ifrctnl(rve).eq.0) then
                      call frictn(c_eta,dampc2(rve),ddxrlt,
     x                     dely,delz,dthr,dxreln,dxrelt,
     x                     fdmpav,fn,fnold,fricto,ftolds,
     x                     func1,func2,func3,func4,func5,knh(rve),kthz,
     x                     l3d,last2,lcdamp(rve),
     x                     ltouch,ndim1,rtouch,viscc,
     x
     x                     cosft,dslip,
     x                     ft,ft2,ftmavg,fttot,mpts,plastic,
     x                     ScrUnit, rve)
                    else
                      fnold = fnolds
                      call frictl(c_eta,dampc2(rve),ddxrlt,
     x                      dfunc7i,dthr,dxreln,dxrelt,
     x                      fdmpav,fn,fnold,fricto,ftolds,
     x                      func7i,knh(rve),kthz,
     x                      l3d,last2,lcdamp(rve),
     x                      ltouch,ndim1,rtouch,viscc,
     x                      linitf(rve),
     x
     x                      cosft,dslip,
     x                      ft,ft2,ftmavg,fttot,mpts,plastic,
     x                      ScrUnit, rve)
                    endif
c
                    if(plastic) then
                      islip1 = 1
                    else
                      islip1 = 0
                    endif
                  elseif(lsinh(rve)) then
c-------------------a sinh-dashpot
c
c-------------------previous slip rate
                    dsold2 = dsold1(ipt5,rve)
c
c-------------------the actual time step
                    dtact = dt(rve) * dtfctr(rve)
c
c-------------------frictional slip
                    plastic = .false.
c
                    do 263 k = 1,ndim1
c---------------------the change in tangential contact force that would result
c                     from this movement if there were no frictional slipping
c                     (this value will, of course, need to be modified in the 
c                     event of frictional slipping between particles
                      dftabc(k) = dxrelt(k)*kthz
  263               continue
c
                    call sinhf(fn,
     x                         timer(rve),coef4,coef5,coef7,dftabc,
     x                         ds1,dsold2,
     x                         dtact,fnold,ft,ftolds,fttot,ptol(rve),
     x                         rtouch,kthhz,viscc,dviscc,ltouch,
     x                         itrack,
     x                         igrain,jgrain,ScrUnit,rve,mrve)
                  endif
                elseif(lHertz(rve) .and. fn.gt.0.) then
c-----------------a Hertz-Mindlin model of contact force.
                  do 155 k = 1,ndim1
c-------------------the previous tangential force, stored in the
c                   linked list ftold()
                    ftolds(k) = ftold(k,ipt5,rve)
  155             continue
c-----------------the previous normal force, stored in a linked list
                  fnolds = fnold1(ipt5,rve)
c-----------------the previous yield parameter, stored in a linked list
                  Tstar1 = Tstar(ipt5,rve)
c
                  call Mindlin(ovrlap, Ebar(rve), Gbar(rve),
     x                     fricto, dxreln,
     x                     dxrelt, l3d, lcdamp(rve), Tstar1, ftolds,
     x                     Reff, rtouch, dampc2(rve), fn, arad, nsteps,
     x                     ft, ft2, fttot, ftmavg, cosft, dslip, ierr)
c
c-----------------is the contact undergoing full frictional slip?
                  plastic = ft2 .gt. (fn * fricto * 0.9999d0)**2
c
c-----------------slip condition
                  if(plastic) then
                    islip1 = 1
                  else
                    islip1 = 0
                  endif
c
c-----------------place tangential force within the tangent plane
                  ftmag1 = 0.
                  fttmag = 0.
                  do 256 k = 1,ndim1
                    ftmag1 = ftmag1 + ft(k)**2
                    fttmag = fttmag + fttot(k)**2
  256             continue
                  ftmag1 = sqrt(ftmag1)
                  fttmag = sqrt(fttmag)
c
                  do 257 k = 1,ndim1
                    ft(k) = ft(k) - ftmag1*c_eta(k)
                    fttot(k) = fttot(k) - fttmag*c_eta(k)
  257             continue
c
                elseif(lJager(rve) .or. lJagr2(rve)
     x                 .or. lJagr3(rve) .or. lJagr4(rve)) then
c-----------------calculate the normal and tangential contact forces using
c                 the algorithm of Jager.  The algorithm computes the
c                 tangential forces based upon Hertz and Mindlin-Deresiewicz
c                 theory
c
c-----------------the Jager algorithm works with indentations (zeta) rather
c                 than overlaps, and 1/2 tangential movements (xi) rather
c                 than full tangential movements (dxrelt)
                  d_xi_global(1) = 0.5d0*dxrelt(1)
                  d_xi_global(2) = 0.5d0*dxrelt(2)
                  d_xi_global(3) = 0.5d0*dxrelt(3)
c
c-----------------the indentation (half the overlap) of the two particles
                  zeta = 0.5d0 * ovrlap
c
                  if(.not.lbefor) then
c-------------------A new contact
c
c-------------------the previous tangential force (on the rotated contact
c                   plane), stored in the linked list ftold()
                    Ft_old(1) = 0.
                    Ft_old(2) = 0.
                  else
c-------------------the previous tangential force (on the rotated contact
c                   plane), stored in the linked list ftold()
                    Ft_old(1) = ftold(1,ipt5,rve)
                    Ft_old(2) = ftold(2,ipt5,rve)
                  endif
c
                  if(l3d) then
c-------------------three-dimensional particles.  Use quaternions to
c                   rotate the contact plane
c
c-------------------lbefor is .true. whenever this contact existed in the 
c                   previous time step, but is .false. for a fresh contact.  
c                   The value of lbefor depends on "ltouch" and (for 
c                   non-convex particles) whether the two particles that 
c                   were touching were touching at this particular contact
                    if(.not.lbefor) then
c---------------------A new contact
c
c---------------------When the particles first touch, compute the initial 
c                     orientation quaternion.  The initial quaterion, Qc, will 
c                     rotate a 3-vector that lies within the (global) contact 
c                     plane into a 2-vector (that is a 3-vector with zero 
c                     as its 3rd, "z" component).  For example, the initial
c                     (global) tangential displacement of the particles at the
c                     contact (a 3-vector) would be transformed (rotated) into
c                     a 2-dimensional vector within the "xi plane".
c
c---------------------This rotation is produced as follows.  Let "n" be the 
c                     contact normal vector ("c_eta" in the Oval code).  
c                     We will rotate "n" so that it is aligned with the "z" 
c                     axis, so that the x-y plane now represents the 
c                     "xi plane".  We use the cross product 
c                             n X k = |n||k|.sin(betaQ).p
c                     where "k" is the unit vector in the "z" direction, 
c                     "p" is the unit axis of rotation, and betaQ is the 
c                     rotation angle.
                      p(3) = 0.
                      p_mag = sqrt(c_eta(1)**2 + c_eta(2)**2)
                      if(p_mag .gt. tolQ) then
c-----------------------the rotation axis, which lies in the x-y plane
                        p(1) =  c_eta(2) / p_mag
                        p(2) = -c_eta(1) / p_mag
c
c-----------------------The rotation angle between the contact normal vector 
c                       and the z-axis
                        betaQ = acos(c_eta(3))
                      else
                        p(1) = 1.d0
                        p(2) = 0.
                        if(c_eta(3) .gt. 0.) then
                          betaQ = 0.
                        else
                          betaQ = pi
                        endif
                      endif
c
c---------------------Sine and Cosine of the half-angle
                      hSine = sin(betaQ / 2.d0)
                      hCosin = cos(betaQ / 2.d0)
c
c---------------------The following unit quaternion, Qc, rotates the 
c                     (global) contact tangential plane into the (Jager)
c                     xi-plane whose normal is in the z-direction:
c
c---------------------Qc = [cos(betaQ / 2.d0), sin(betaQ / 2.d0)*[p(1),p(2),0.]]
                      Qc(1) = hCosin
                      Qc(2) = hSine*p(1)
                      Qc(3) = hSine*p(2)
                      Qc(4) = 0.
c
c---------------------Since the contact was just now created, its incremental 
c                     rotation since the previous time step is zero.  Express 
c                     the rotation as an (imaginary) quaternion of four 
c                     components.
                      dw(1) = 0.
                      dw(2) = 0.
                      dw(3) = 0.
                    else
c---------------------a pre-existing contact
c
c---------------------This contact had existed in the previous time step.  
c                     Retrieve the contact rotation quaternion for this contact.
                      Qc(1) = Qc_old(1,ipt5,rve)
                      Qc(2) = Qc_old(2,ipt5,rve)
                      Qc(3) = Qc_old(3,ipt5,rve)
                      Qc(4) = Qc_old(4,ipt5,rve)
c
c---------------------In this and subsequent time steps, the contact frame will 
c                     undergo increments of rotation.  The quaternion Q must be 
c                     altered through composition. That is, if dQ represents 
c                     the quaternion of the incremental rotatation, the
c                     new reference frame is rotated by the composite
c                     quaternion Qc = dQ o Qc, which replaces the previous
c                     quaternion Q.  When the contact is first established, 
c                     the dQ is the identity element <1, 0, 0, 0>.
c
c---------------------The incremental rotation of the contact plane is the 
c                     result of two effects: (1) a rotation of the contact 
c                     normal about an axis perpendicular to the normal, as 
c                     would be produced by rolling and/or rigid rotations 
c                     of the particle pair, which we will simply call "rolling 
c                     rotation", and (2) a twirling of the two particles about
c                     the contact normal
c
c---------------------First, compute the incremental rotation of the contact 
c                     normal.  There are two ways of doing this: 1) using
c                     information about the surface curvatures of the particles
c                     and the particle rotations, 2) by storing and retrieving
c                     the previous contact normal.
c
                      if(.not.ln_old .and. lsphr(rve)) then
c-----------------------If the two contacting surfaces are spherical, then we
c                       can more easily compute the rolling rotation of the
c                       contact plane.  This situation applies to circle,
c                       sphere, nobby, and bumpy particles.  In these
c                       statements, ri and rj are the radii of curvature of 
c                       the two particles.  The following approach is based on
c                       work in the paper M.R. Kuhn and K. Bagi, "Alternative
c                       definition of particle rolling in a granular assembly," 
c                       J. Engrg. Mech., 2004, 130(7), 826-835.  In
c                       particular, we apply equations 9 and 14 in that paper.
                        rjij = rad_j / (rad_i + rad_j)
c
                        dn(1) =   dthr(2,1)*c_eta(3) 
     x                          - dthr(3,1)*c_eta(2)
     x                   + (rjij * (  (dthr(2,2) - dthr(2,1))*c_eta(3)
     x                              - (dthr(3,2) - dthr(3,1))*c_eta(2)
     x                              + dxrelt(1) / rad_j ))
                        dn(2) =   dthr(3,1)*c_eta(1) 
     x                          - dthr(1,1)*c_eta(3)
     x                   + (rjij * (  (dthr(3,2) - dthr(3,1))*c_eta(1)
     x                              - (dthr(1,2) - dthr(1,1))*c_eta(3)
     x                              + dxrelt(2) / rad_j ))
c
                        if(l3d) then
                          dn(3) =   dthr(1,1)*c_eta(2) 
     x                            - dthr(2,1)*c_eta(1)
     x                     + (rjij * (  (dthr(1,2) - dthr(1,1))*c_eta(2)
     x                                - (dthr(2,2) - dthr(2,1))*c_eta(1)
     x                                + dxrelt(3) / rad_j ))
                        endif
                      else
c-----------------------If the particle surfaces are not spherical at the
c                       contact, we can use the method in Kuhn & Bagi, but
c                       things become much more complex.  We will instead
c                       compute the rolling rotation of the contact normal
c                       would by storing the previous normal vector (as, say
c                       c_eta_old), and then subtracting from the current
c                       normal: dn = c_eta-c_eta_old
                        dn(1) = c_eta(1) - c_etas(1,ipt5,rve)
                        dn(2) = c_eta(2) - c_etas(2,ipt5,rve)
                        dn(3) = c_eta(3) - c_etas(3,ipt5,rve)
                      endif
c
c---------------------Compute the angular rotation vector of this rolling
c                     contribution: the cross product n x dn
                      dwRoll(1) = c_eta(2)*dn(3) - c_eta(3)*dn(2)
                      dwRoll(2) = c_eta(3)*dn(1) - c_eta(1)*dn(3)
                      dwRoll(3) = c_eta(1)*dn(2) - c_eta(2)*dn(1)
c
c---------------------Next, compute the incremental (scalar) twirling of 
c                     the two particles
                      dTwirl = 0.5d0*
     x                            (  (dthr(1,1) + dthr(1,2)) * c_eta(1)
     x                             + (dthr(2,1) + dthr(2,2)) * c_eta(2)
     x                             + (dthr(3,1) + dthr(3,2)) * c_eta(3))
c
c---------------------express this twirling (scalar) rotation as an angular 
c                     rotation vector about the normal axis.
                      dwTwrl(1) = dTwirl*c_eta(1)
                      dwTwrl(2) = dTwirl*c_eta(2)
                      dwTwrl(3) = dTwirl*c_eta(3)
c
c---------------------Combine the two contributions, rolling and twirling, 
c                     as an infinitesimal angular rotation of the contact 
c                     frame.  Express the rotation as an (imaginary) quaternion 
c                     of four components.
c                     dw(1) = 0.
                      dw(1) = dwRoll(1) + dwTwrl(1)
                      dw(2) = dwRoll(2) + dwTwrl(2)
                      dw(3) = dwRoll(3) + dwTwrl(3)
                    endif
c
c-------------------The inverse quaternion, which rotates the (Jager) 
c                   xi-plane (whose normal is in the z-direction) into 
c                   the (global) contact plane
                    Qci(1) =  Qc(1)
                    Qci(2) = -Qc(2)
                    Qci(3) = -Qc(3)
                    Qci(4) = -Qc(4)
c
c-------------------Apply the incremental rotation "dw" to the quaternion
c                   Qci to find the updated quaternion Qci_new.  
c                      Qci_new -> Qci + dQci = Qci + (1/2) dw*Qci, where "*" is
c                   the quaternion composition operator.
c                   Normalize the updated quaternion using Katz's approximation
c                   (inorm = 1).  The updated quaternion Qci_new will rotate 
c                   the (Jager) xi-plane (whose normal is in the z-direction)
c                   into the (global) contact tangent plane
                    inorm = 1
                    call QIncRotate(Qci, Qci_new, dw, inorm)
c
c-------------------The inverse (unit) quaternion, which rotates the 
c                   contact plane (whose normal is the contact normal 
c                   "n" or c_eta) into the xi-plane (whose normal is 
c                   in the z-direction)
                    Qc_new(1) =  Qci_new(1)
                    Qc_new(2) = -Qci_new(2)
                    Qc_new(3) = -Qci_new(3)
                    Qc_new(4) = -Qci_new(4)
c
c-------------------The new quaterion Qc_new is used to rotate the tangential 
c                   displacement into the Jager xi-frame, so that the new 
c                   (xi-frame) contact force can be computed by subroutin 
c                   Jager.  After computing the xi-frame force, we then apply 
c                   the inverse of Qc_new (called "Qci_new") to rotate the 
c                   xi-frame force back into the global frame.
c
c-------------------Compute the rotation matrix of quaternion Qc_new,
c                   which rotates vectors from the (global) frame of 
c                   the contact tangential plane to the local (Jager) 
c                   xi-plane frame
                    call QRotationMatrix(Qc_new, QRot)
c
c-------------------Rotate the global vector "d_xi_global" of tangential
c                   contact movement to the local xi-plane movement
                    ixg = 2
                    call QMatrixRotateVector(QRot, X_local, 
     x                                       d_xi_global, ixg)
                    d_xi(1) = X_local(1)
                    d_xi(2) = X_local(2)
c
                  else
c-------------------two-dimenstional particles.  Quaternions are not needed
c
c-------------------d_xi(1) will represent the counter-clockwise tangential
c                   half-displacement
                    d_xi(1) =  -d_xi_global(1)*c_eta(2) 
     x                        + d_xi_global(2)*c_eta(1)
                    d_xi(2) = 0.
c
                    X_local(1) = d_xi(1)
                    X_local(2) = 0.
                  endif
c
c-----------------save the d_xi and Ft_old values for computing the work
c                 dissipated in sliding at this contact
                  d_xio(1) = d_xi(1)
                  d_xio(2) = d_xi(2)
                  Ft_oldo(1) = Ft_old(1)
                  Ft_oldo(2) = Ft_old(2)
                  fnolds = fnold1(ipt5,rve)
c
c-----------------if rolling is to be considered in the calculation of
c                 contact force (lJagr3=.true.), then adjust the tangential
c                 displacement d_xi
                  if(lJagr3(rve)) then
c-------------------we are including the effects of contact rolling
c                   in computing the contact force.  See the paper
c                   M.R. Kuhn and K. Bagi, "Alternative definition of 
c                   particle rolling in a granular assembly," 
c                   J. Engrg. Mech., 2004, 130(7), 826-835.  In
c                   particular, we apply equations 15 and 16 in that paper.
                    if(lspher(rve)) then
c---------------------surfaces of the two particles are spherical
c
c---------------------factors that will be used in computing 
c                     the rolling vector
                      rrij1 = rad_i * rad_j / (rad_i + rad_j)
                      rrij2 = 0.5d0 * (rad_i - rad_j)/(rad_i + rad_j)
c
                      if(l3d) then
c-----------------------a 3D simulation
                        duRoll(3) = -rrij1*
     x                              (  (dthr(1,2)-dthr(1,1))*c_eta(2)
     x                               - (dthr(2,2)-dthr(2,1))*c_eta(1))
     x                              - rrij2*dxrelt(3)
                      endif
                      duRoll(1) = -rrij1*
     x                            (  (dthr(2,2)-dthr(2,1))*c_eta(3)
     x                             - (dthr(3,2)-dthr(3,1))*c_eta(2))
     x                            - rrij2*dxrelt(1)
                      duRoll(2) = -rrij1*
     x                            (  (dthr(3,2)-dthr(3,1))*c_eta(1)
     x                             - (dthr(1,2)-dthr(1,1))*c_eta(3))
     x                            - rrij2*dxrelt(2)
c
c---------------------magnitude of the rolling vector
                      duRolm = sqrt(  duRoll(1)**2 
     x                              + duRoll(2)**2 + duRoll(3)**2)
                    else
c---------------------rolling can only be computed with spherical surfaces
                      write(ScrUnit(rve),*)
     x                  'duRoll can not be computed in subroutin forces'
                      write(ErrUnit(rve),*)
     x                  'duRoll can not be computed in subroutin forces'
                      stop
                    endif
c
                    if(lbefor) then
c---------------------a pre-existing contact
c
c---------------------the previous normal force, stored in a linked list
                      fnolds = fnold1(ipt5,rve)
c
c---------------------We must rotate the tangential force from the 
c                     (global) contact tangential plane into the 
c                     (Jager) xi-plane.  Use the rotation matrix QRot, 
c                     but use the inverse of QRot, with ixg=1.
c                     Note that the xi-plane components Ft_xit(3) = 0.
c
c---------------------magnitude of the previous tangential force
                      ftoldm = sqrt(Ft_old(1)**2 + Ft_old(2)**2)
c
                      ftfrac = ftoldm / (frict(rve)*fnolds)
                      if(ftfrac.lt.0.999999d0) then
c---------------------the magnitude of the steady-state creepage rate
                        FofPsi = C_11nu(rve)
     x                           * sqrt(zeta * 2.d0 * rrij1)
     x                           / (2.d0 * rrij1)
     x                           * (1.d0 - (1.d0 - ftfrac)**(1.d0/3.d0))
                      else
                        FofPsi = C_11nu(rve)
     x                           * sqrt(zeta * 2.d0 * rrij1)
     x                           / (2.d0 * rrij1)
                      endif
                    else
                      ftoldm = 0.
                      FofPsi = 1.d0
                    endif
c
                    if(ftoldm.gt.0.) then
                      d_xi_adjust = FofPsi*(duRolm/2.d0)/ftoldm
                      d_xi(1) = d_xi(1) - d_xi_adjust*Ft_old(1)
                      d_xi(2) = d_xi(2) - d_xi_adjust*Ft_old(2)
                    endif
                  endif
c
c-----------------total tangential movement in the local frame
                  xi_old(1,ipt5,rve) = xi_old(1,ipt5,rve) + d_xi(1)
                  xi_old(2,ipt5,rve) = xi_old(2,ipt5,rve) + d_xi(2)
c
c-----------------These rotated displacements and force are passed to the 
c                 Jager subroutin, which computes the new tangential force 
c                 and revises the load history vectors "p_s".  The new 
c                 tangential forces and p_s vectors within the rotated 
c                 "xi plane".  The tangential force must be rotated into 
c                 the original spatial frame
c
c-----------------save the previous contact forces so that the elastic
c                 contact energy can be computed
                  Fn_o(ipt5,rve) = Fn_s(listk(ipt5,rve),rve)
                  zeta_o(ipt5,rve) = zeta_s(listk(ipt5,rve),rve)
                  Ft_s(ipt5,1,1,rve) = Ft_old(1)
                  Ft_s(ipt5,1,2,rve) = Ft_old(2)
c
c-----------------calculate the normal and tangential contact forces using
c                 the algorithm of Jager.  The algorithm computes the
c                 tangential forces based upon Hertz and Mindlin-Deresiewicz
c                 theory
                  call Jager3D(
     x                      rad_i, rad_j, zeta,
     x                      d_xi, Ft_old,
     x                      Ebar(rve), A_1(rve),
     x                      palpha(rve), Cn(rve), kappa(rve),
     x                      frict(rve), frict2(rve), fk2(rve),
     x                      lJsphr, lJcone, lJgen,
     x                      Fn_new, Ft_xi,
     x                      ipt5, nlist2, nlistJ,
     x                      rve)
c
                  if(nlist2.eq.0) then
                    icatch = nlist2
                  endif
c
c-----------------the new normal force
                  fn = Fn_new
c
c-----------------normal contact force
                  fnnear = fn
c
c-----------------save the contact force so that it can be used for comuting
c                 the contact elastic energy
                  Ft_s(ipt5,2,1,rve) = Ft_xi(1)
                  Ft_s(ipt5,2,2,rve) = Ft_xi(2)
c
c-----------------The squared magnitude of the normal force
                  ft2 = Ft_xi(1)**2 + Ft_xi(2)**2
c
c-----------------is the contact undergoing full frictional slip?
                  plastic = ft2 .gt. (fn * fricto * 0.9999d0)**2
c
c-----------------add any velocity-dependent contact damping to the 
c                 tangential contact force, but only when the contact
c                 is slipping
                  if(.not.plastic .and. lcdamp(rve)) then
                    Ft_xit(1) = Ft_xi(1) + dampc2(rve)*X_local(1)
                    Ft_xit(2) = Ft_xi(2) + dampc2(rve)*X_local(2)
                  else
c-------------------the contact is not slipping (plastic=.false.) OR
c                   contact damping is not being used in the simulation
c                   as with the input value of pcrit(3)=0
                    Ft_xit(1) = Ft_xi(1)
                    Ft_xit(2) = Ft_xi(2)
                  endif
c
c-----------------We must rotate the tangential force from the 
c                 (Jager) xi-plane back into the (global) contact 
c                 tangential plane.  
                  if(l3d) then
c-------------------three-dimensional particles.  Use quaternions
c
c                   Use the rotation matrix QRot, but use the inverse of 
c                   QRot, with ixg=2.  Note that the xi-plane components
c                   Ft_xit(3) = 0.
c
                    ixg = 1
                    Ft_xit(3) = 0.
                    call QMatrixRotateVector(QRot, Ft_xit, fttot, ixg)
                  else
c-------------------two-dimensional particles
                    fttot(1) = -Ft_xit(1)*c_eta(2)
                    fttot(2) =  Ft_xit(1)*c_eta(1)
                  endif
c
                else
c-----------------a frictionless contact with linear stiffness
                  ft(1) = 0.
                  ft(2) = 0.
                  ft(3) = 0.
                  ft2 = 0.
                  dslip = 0.
                  ftmavg = 0.
                  plastic = .false.
                  fttot(1) = 0.
                  fttot(2) = 0.
                  fttot(3) = 0.
                endif
c
c---------------the number of contacts that are either touching or are
c               affected by long range forces
                if(fnnear+fnfar.gt.0.) then
                  nnear(rve) = nnear(rve) + 1
                endif
c
                if(last2) then
c-----------------this is the final loop (algori=2) before the next
c                 deformation increment
c
c-----------------is this contact currently sliding?
                  if(plastic) then
c-------------------the number of sliding contacts
                    nslide(rve) = nslide(rve) + 1
c
c-------------------the average normal force among sliding contacts
                    fnavg2(rve) = fnavg2(rve) + fn
                  endif
c
c-----------------whether sliding is occuring between these two particles
                  lslidc = lslidc .or. plastic
                endif
              endif
c
              if(last2) then
c---------------this is the final loop (algori=2) before the next
c               deformation increment
c
c---------------the average normal force
                fnavg(rve) = fnavg(rve) + fn
c
c---------------the average overlap between contacting particles.  We may
c               want to consider the ratio of the average overlap to the
c               average particle diameter.
                ovravg(rve) = ovravg(rve) + ovrlap
              endif
c
c------------------------------------------------------------------------------
c
c-------------add the forces at this contact to the total forces acting on each 
c             of the companion particles and to the volume-averaged stresses. 
c
              do 60 k = 1,ndim1
                if(lcdamp(rve)) then
c-----------------with contact damping . . . add the viscous force due
c                 to velocities in the direction of the contact normal
                  ddxkn = ddxrln*c_eta(k)
                  fndamp = dampc1(rve)*ddxkn
c
c-----------------the energy expended by viscous damping due to movement
c                 in the normal direction
                  viscc = viscc + fndamp*ddxkn*rtouch
c
c-----------------the average (squared) damping force per contact
                  fdmpav = fdmpav + fndamp**2
                endif
c
c---------------the kth component of the contact force, including 
c               contact damping force, fndamp
                fk(k) = -((fn + fnfar)*c_eta(k)) + fttot(k) + fndamp
c
c---------------force acting on the two particles
                f(k,igrain,rve) = f(k,igrain,rve) + fk(k)
                f(k,jgrain,rve) = f(k,jgrain,rve) - fk(k)
   60         continue
c
c-------------cross product of contact force and the radial vector from
c             the center of the particle to the contact point
              if(l3d) then
c---------------particle igrain
                rcf_i(1) =   l_i(2)*fk(3) - l_i(3)*fk(2)
                rcf_i(2) =   l_i(3)*fk(1) - l_i(1)*fk(3)
c---------------particle jgrain
                rcf_j(1) = -(l_j(2)*fk(3) - l_j(3)*fk(2))
                rcf_j(2) = -(l_j(3)*fk(1) - l_j(1)*fk(3))
              endif
              rcf_i(3) =   l_i(1)*fk(2) - l_i(2)*fk(1)
              rcf_j(3) = -(l_j(1)*fk(2) - l_j(2)*fk(1))
c
              do 61 k = ndim2,3
c---------------moment acting on the two particles
                fth(k,igrain,rve) = fth(k,igrain,rve) + rcf_i(k)
                fth(k,jgrain,rve) = fth(k,jgrain,rve) + rcf_j(k)
   61         continue
c
c-------------terms used to compute the average imbalance of particle forces.
c             Now, we compute the mean square contact force 
c             and its (approximate) moment
              ftsq(rve) = ftsq(rve) + ft2 + (fn + fnfar)**2
c
              if(last) then
c---------------iterations within the time-step are finished.  Compute
c               values at the end of this time step.
c
c---------------number of contacts.  Note that "ntacts" is the number of
c               particle pairs that are touching.  "ntactz" and "ntacts"
c               will differ for non-convex particles, which can have 
c               multiple contacts between a single particle pair
                ntactz(rve) = ntactz(rve) + 1
c
c---------------contributions to the Cauchy stress and higher-order stresses
c
c---------------Cauchy stress
                stress_11 = stress_11 + fk(1)*rxcntr(1)*adjust
                stress_21 = stress_21 + fk(1)*rxcntr(2)*adjust
                stress_31 = stress_31 + fk(1)*rxcntr(3)*adjust
                stress_12 = stress_12 + fk(2)*rxcntr(1)*adjust
                stress_22 = stress_22 + fk(2)*rxcntr(2)*adjust
                stress_32 = stress_32 + fk(2)*rxcntr(3)*adjust
                stress_13 = stress_13 + fk(3)*rxcntr(1)*adjust
                stress_23 = stress_23 + fk(3)*rxcntr(2)*adjust
                stress_33 = stress_33 + fk(3)*rxcntr(3)*adjust
c
                if(imodel(rve).eq.0 .or. lsinh(rve)) then
c-----------------linear contact springs
c
c-----------------potential (elastic) energy stored in the normal contact
c                 spring
                  dpnrg1 = fn**2
c
c-----------------potential (elastic) energy stored in the tangential contact
c                 spring
                  dpnrg2 = 0.
                  do 81 k = 1,ndim1
                    dpnrg2 = dpnrg2 + ft(k)**2
   81             continue
                elseif(lHertz(rve)) then
c-----------------elastic energy in normal contact force
                  dpnrg1 = Ebar(rve) / 5.d0
     x                     * sqrt(Reff * ovrlap**5 / 2.d0)
                  dpnrg2 = 0.
                elseif(lJager(rve) .or. lJagr2(rve)
     x                 .or. lJagr3(rve) .or. lJagr4(rve)) then
c
c-----------------the incremental tangential work in contact: twice the d_xi
c                 movement times the average of the previous and current
c                 contact force. Factor rtouch is applied to fresh contacts to
c                 account for the portion of the time step over which the
c                 particles were in contact.
                  if(lbefor) then
c-------------------an existing contact.  A factor of (2 particles) *(1/2 avg)
                    dworkc =   (Ft_oldo(1) + Ft_xi(1)) * d_xio(1)
     x                       + (Ft_oldo(2) + Ft_xi(2)) * d_xio(2)
                  else
c-------------------a fresh contact
                    dworkc = (  Ft_xi(1) * d_xio(1)
     x                        + Ft_xi(2) * d_xio(2))*rtouch
                  endif
c
c-----------------an estimate of the increment of frictional (dissipated)
c                 work at the contact:  the force-work (dworkc) minus the 
c                 change in tangential elastic energy in the contact
c                 (dpnrg2).  The latter is just an estimate, as it is based
c                 on an estimated elastic stiffness
c                 dslide = dslide + dworkc - dpnrg2
                  dslide(rve) = dslide(rve) + dworkc
c
c-----------------accumulated force-work at all contacts
                  workc(rve) = workc(rve) + dworkc
c
c-----------------save the accumulated (estimate of) frictional dissipation
                  if(.false.) then
                    dslidet(rve) = dslidet(rve) + dworkc - dpnrg2
                  endif
c
                  if(lJager(rve)) then
c-------------------Hertz-Mindlin contact between spherical surfaces
c
c-------------------Hertz-Mindlin contact between spherical surfaces
                    rmean2 = 2.d0 * (rad_i*rad_j) / (rad_i + rad_j)
c
c-------------------potential (elastic) energy stored in normal contact spring
                    dpnrg1 = Ebar23n(rve)*(fn**5 / rmean2)**(1.d0/3.d0)
c
c-------------------potential (elastic) energy in tangential contact spring
c                   dpnrg2 = Ebar23t * (ft2**5 / rmean2**2)**(1.d0/6.d0)
                  elseif(lJagr2(rve)) then
c-------------------Hertz-Mindlin contact between conical surfaces
c
c-------------------potential (elastic) energy stored in normal contact spring
                    dpnrg1 = Ebar43n(rve) * sqrt(fn**3)
c
c-------------------potential (elastic) energy in tangential contact spring
c                   dpnrg2 = Ebar43t * (ft2**3)**(1.d0/4.d0)
                  elseif(lJagr4(rve)) then
c-------------------Hertz-Mindlin contact between surfaces having a general
c                   power-law profile
c
c-------------------potential (elastic) energy stored in normal contact spring
                    dpnrg1 = Cn_1(rve) 
     x                     * fn**((2.d0*palpha(rve)+1.d0)
     x                             /(palpha(rve)+1.d0))
c
c-------------------potential (elastic) energy in tangential contact spring
c                   dpnrg2 = Cn_2
c    x                    * ft2**((2.d0*palpha+1.d0)/(palpha+1.d0)/2.d0)
                  endif
                endif
c
c---------------add to the total for the assembly
                pnrgy1(rve) = pnrgy1(rve) + dpnrg1
c
c---------------add the contribution of this particle to the total for
c               the assembly. Correction: compute the total tangential
c               elastic energy in subroutin Jager3D_etc
c               pnrgy2 = pnrgy2 + dpnrg2
c
                if(last2) then
c-----------------energy expended in frictional sliding in this time increment
c                 for the entire assembly
                  if(imodel(rve).eq.0 .or. lHertz(rve)) then
                    if(plastic) then
                      dslide(rve) = dslide(rve) + ftmavg*dslip
c
c---------------------with temperature-dependent model, find change in
c                     particle temperature that results from frictional sliding
                      if(iheat(rve).eq.1 .and. hmodel(rve).eq.1) then
c-----------------------apportion the frictional heat to the two particles
                        dheati = ftmavg*dslip 
     x                         * v_p(igrain,rve)
     x                           / (v_p(igrain,rve) + v_p(jgrain,rve))
                        dheatj = ftmavg*dslip 
     x                         * v_p(jgrain,rve)
     x                          / (v_p(igrain,rve) + v_p(jgrain,rve))
c
c-----------------------temperature change in the two particles, based upon
c                       the specific heat (spheat), particle volumes (v_p), 
c                       and particle density (h_rho)
                        dtmpi = dheati
     x                       / (spheat(rve) * v_p(igrain,rve)
     x                          * h_rho(rve))
                        dtmpj = dheatj
     x                       / (spheat(rve) * v_p(jgrain,rve)
     x                          * h_rho(rve))
c
c-----------------------particle temperatures
                        tempr(igrain,rve) = tempr(igrain,rve) + dtmpi
                        tempr(jgrain,rve) = tempr(jgrain,rve) + dtmpj
                      endif
                    endif
                  elseif(lsinh(rve)) then
                    if(iheat(rve).eq.1 .and. hmodel(rve).eq.1) then
c---------------------apportion the frictional heat to the two particles
                      dheati = dviscc
     x                       * v_p(igrain,rve)
     x                        / (v_p(igrain,rve) + v_p(jgrain,rve))
                      dheatj = dviscc
     x                       * v_p(jgrain,rve)
     x                        / (v_p(igrain,rve) + v_p(jgrain,rve))
c
c---------------------temperature change in the two particles, based upon
c                     the specific heat (spheat), particle volumes (v_p), 
c                     and particle density (h_rho)
                      dtmpi = dheati
     x                        / (spheat(rve)*v_p(igrain,rve)
     x                           * h_rho(rve))
                      dtmpj = dheatj
     x                        / (spheat(rve)*v_p(jgrain,rve)
     x                           * h_rho(rve))
c
c---------------------particle temperatures
                      tempr(igrain,rve) = tempr(igrain,rve) + dtmpi
                      tempr(jgrain,rve) = tempr(jgrain,rve) + dtmpj
                    endif
                  endif
c
c-----------------store the tangential force in the linked list
                  if(.not.(lJager(rve) .or. lJagr2(rve)
     x                     .or. lJagr3(rve) 
     x                     .or. lJagr4(rve))) then
c
c-------------------store the tangential contact force
                    do 59 k = 1,ndim1
                      ftold(k,ipt5,rve) = ft(k)
   59               continue
c
c-------------------store the orientation of the contact normal
                    c_etas(1,ipt5,rve) = c_eta(1)
                    c_etas(2,ipt5,rve) = c_eta(2)
                    c_etas(3,ipt5,rve) = c_eta(3)
                  elseif(lJager(rve) .or. lJagr2(rve)
     x                   .or. lJagr3(rve) 
     x                   .or. lJagr4(rve)) then
c-------------------when the Jager algorithm is used for computing the contact
c                   force, then we store the tangential force on the rotated
c                   (local) contact xi-plane.  In this case, there is no
c                   need to store the ftold(3,:) component
                    ftold(1,ipt5,rve) = Ft_xi(1)
                    ftold(2,ipt5,rve) = Ft_xi(2)
c
c-------------------store the orientation of the contact normal
                    c_etas(1,ipt5,rve) = c_eta(1)
                    c_etas(2,ipt5,rve) = c_eta(2)
                    c_etas(3,ipt5,rve) = c_eta(3)
c
                    if(l3d) then
c---------------------store the quaternion for rotating back and forth between
c                     the global frame and the local contact xi-frame
                      Qc_old(1,ipt5,rve) = Qc_new(1)
                      Qc_old(2,ipt5,rve) = Qc_new(2)
                      Qc_old(3,ipt5,rve) = Qc_new(3)
                      Qc_old(4,ipt5,rve) = Qc_new(4)
                    endif
                  endif
c
c-----------------store the vector from the center of igrain to the contact 
c                 point
                  do 859 k = 1,ndim1
                    l_i_old(k,ipt5,rve) = l_i(k)
  859             continue
c
c-----------------store the normal force in the linked list
                  fnold1(ipt5,rve) = fn
c
c-----------------store the slip condition
                  islip(ipt5,rve) = islip1
c
c-----------------reset the branch of the long-range contact force
c                 (imodel=3 only)
                  if(imodel(rve).eq.3) then
                    ifn_togl(ipt5,rve) = jfn_togl
                  elseif(lHertz(rve)) then
                    Tstar(ipt5,rve) = Tstar1
                  endif
c
                  if(lsinh(rve)) then
                    dsold1(ipt5,rve) = ds1 / (dt(rve)*dtact)
                  endif
c
c-----------------was the contact sliding?
                  lplold(ipt5,rve) = plastic
c
c-----------------store these values for use in output to F-files
                  if(ndim1.eq.2) then
                    branch(1,ipt5,rve) = rxcntr(1)
                    branch(2,ipt5,rve) = rxcntr(2)
                    c_etas(1,ipt5,rve) = c_eta(1)
                    c_etas(2,ipt5,rve) = c_eta(2)
                  endif
c
c-----------------with 4-arc ovals, record the particular arcs that are
c                 touching.  The information is written to
c                 an output G-file for input to the graphics OvalPlot
c                 program.  The array quad() is not used internally withen
c                 the program Oval.
                  if(loval(rve)) then
                    quad(1,ipt5,rve) = m_i
                    quad(2,ipt5,rve) = m_j
                  endif
                endif
c
              endif
            endif
c
c-----------the next pair of component pieces of the two particles
            ipart = ipart + 1
   91     continue
c
c---------the number of neighboring particles that are sliding with this
c         particle
          if(lslidc) then
            nslidc(igrain,rve) = nslidc(igrain,rve) + 1
            nslidc(jgrain,rve) = nslidc(jgrain,rve) + 1
          endif
   90   continue
  100 continue
c
c-------we must do some housekeeping to add all of the new contacts to
c         listf0(), listf1(), and listf2().  We have journaled these
c       necessary changes above, and we will make the changes now.
c       This will enable parallelization
        if(last) then
        if(nclean2.gt.0) then
          do 149 i4 = 1,nclean2
            ipt1 = iclean2(i4,1)
            ipt5 = iclean2(i4,2)
            m_i = iclean2(i4,3)
            m_j = iclean2(i4,4)
c
            if(liste(ipt1,rve).eq.0) then
c-------------the two particles were not previously touching
              liste(ipt1,rve) = ipt5
            else
c-------------the two particles were previously touching, but not 
c             at this contact.  Find the tail of the list of contacts
c             for this pair of particles
              i4a = liste(ipt1,rve)
              do 803 while (i4a.ne.0)
                i4old = i4a
                i4a = listf0(i4a,rve)
  803       continue
c
c-------------tie the list of previous contacts between the particles
c             to the current contact
              listf0(i4old,rve) = ipt5
            endif
c
c-----------amend the linked list listf0()
            listf0(0,rve) = listf0(ipt5,rve)
            listf0(ipt5,rve) = 0
            listf1(ipt5,rve) = m_i
            listf2(ipt5,rve) = m_j
  149   continue
        endif
c
c-------we must do some housekeeping to modify the lists
c       listf0(), listf1(), and listf2().  Contacts that were
c       previously touching are no longer touching.  We have
c       journaled these changes above, and we will make the changes now.
c       This will enable parallelization
        if(nclean1.gt.0) then
          do 147 i4 = 1,nclean1
            ipt1 = iclean1(i4,1)
            m_i = iclean1(i4,2)
            m_j = iclean1(i4,3)
c
c-----------the two particles were touching in the previous time step
c
c-----------if leras3 becomes .true. then the two particles are no longer
c           touching.  If leras5 becomes .true. then the two particles
c           are no longer touching at the particular contact (for
c           non-convex particles)
            leras3 = .false.
            leras5 = .false.
c
            if (lconvx(rve)) then
c-------------the two particles are convex, so they can only touch at
c             a single point.  And we have exhausted all near-neighbor
c             pairs of component pieces for the pair of particles
c
c-------------pointer to information on this contact
              ipt5 = liste(ipt1,rve)
c
              leras3 = .true.
              leras5 = .true.
c
            elseif(.not.lconvx(rve)) then
c-------------the two partcles are non-convex, so they can touch at
c             multiple points.  We know that the two particles were 
c             touching in at least one point during the previous time 
c             step. There are three possiblities.
c                 1) The particles were touching, but not at this
c                    particular contact.
c                 2) The particles were touching only at this one contact
c                 3) The particles were touching at multiple contacts,
c                    including this contact
c             In the first situation, nothing needs to be done with
c             the lists.  In the second situation, we must eliminate
c             the item from both the contact list and the particle-
c             touching lists.  In the third situation, we must elimate
c             the item from the contact list only.
c
c             Search through "listf0" to find (1) whether this 
c             particular contact had existed in the previous time
c             step, and (2) if it did exist, whether there were 
c             other contacts between the two particles (lother = .true.)
              lother = .false.
              ihit = 0
              j4 = 0
c
c-------------liste points to the first contact of this pair of particles
              i4a = liste(ipt1,rve)
              do 806 while (i4a.ne.0)
                if(listf1(i4a,rve).eq.m_i
     x             .and. listf2(i4a,rve).eq.m_j) then
c-----------------this contact was present in the previous time step
                  ihit = i4a
                  jhit = j4
                else
c-----------------other contacts were present between the two particles
                  lother = .true.
                endif
                j4 = i4a
                i4a = listf0(i4a,rve)
  806       continue
c
              if(ihit.eq.0 .and. lother) then
c---------------case (1): The particles were touching, but not at this
c               particular contact. Don't do anything.
              elseif(ihit.ne.0 .and. .not.lother) then
c---------------case (2): The particles were touching only at this one
c               contact
                leras3 = .true.
                leras5 = .true.
                ipt5 = ihit
              elseif(ihit.ne.0 .and. lother) then
c---------------case (3): The particles were touching at multiple
c               contacts, including this contact
                leras5 = .true.
                ipt5 = ihit
              else
                write(ScrUnit(rve),*)
     x            'Error in subroutin forces: strange case3'
              endif
            endif
c
            if(leras5) then
              if(.not.lconvx(rve)) then
c---------------the two particles are not convex.  In the previous time
c               step, one or more contacts existed between the two
c               particles.  The current contact has disengaged.  Remove
c               the the link to this contact's information.
                if(liste(ipt1,rve).eq.ipt5) then
                  liste(ipt1,rve) = listf0(ipt5,rve)
                else
                  listf0(jhit,rve) = listf0(ipt5,rve)
                endif
                listf0(ipt5,rve) = listf0(0,rve)
                listf0(0,rve) = ipt5
                listf1(ipt5,rve) = 0
                listf2(ipt5,rve) = 0
              endif
            endif
c
            if(leras3) then
c-------------the two particles are no longer touching
              liste(ipt1,rve) = 0
c
              if(.not.lconvx(rve)) then
c---------------the particles are not convex
                ipt3 = 0
                ltouch = .true.
              endif
            endif
 147    continue
        endif
c
c-------we must do some housekeeping to modify the linked lists that were
c       used in subroutin Jager3D.  This is being done outside of
c       subroutin Jager3D to enable parallelization.
c
c-------remove legs of the contact's linked-list history.  In the paper, 
c       see lines 52 and 78 and Fig. 7
c
c-------scan through the vector iremov(). iremov=0, no leg to remove.
c       iremov>0, remove this number of legs behind the final rve
c       (noting that a new rve will be added). iremov=-1, remove
c       all legs for this contact, as the contact is fully sliding.
        if(lJager(rve) .or. lJagr2(rve)
     x     .or. lJagr3(rve) .or. lJagr4(rve)) then
          do 141 i4 = 1,mlist2
c-----------the number of legs to remove
            nremov = iremov(i4,rve)
c-----------the slip condition of the contact: islip=0 elastic;  
c           islip=1 full slip;  islip=2 micro-slip (Jager)
            islip(i4,rve) = islip2(i4,rve)
c
            if(nremov.gt.0) then
c-----------for all of the legs that must be removed...
              do 370 j = 1,nremov
                k4 = listk(i4,rve)
c-------------remove numerical data of the leg
                zeta_s(k4,rve) = 0.
                Fn_s(k4,rve) = 0.
                p_s(k4,1,rve) = 0.
                p_s(k4,2,rve) = 0.
c
c-------------modify the linked list (Fig. 7)
                listk(i4,rve) = listJ(k4,rve)
                listJ(k4,rve) = listJ(Zero,rve)
                listJ(Zero,rve) = k4
  370       continue
            elseif(nremov.eq.-1) then
c-------------remove all information about this contact in the linked lists.
c             In the paper see line 6 and Fig. 7
              k4 = listk(i4,rve)
              do 372 while(k4 .gt. Zero)
                zeta_s(k4,rve) = 0.
                Fn_s(k4,rve) = 0.
                p_s(k4,1,rve) = 0.
                p_s(k4,2,rve) = 0.
c
                listk(i4,rve) = listJ(k4,rve)
                listJ(k4,rve) = listJ(Zero,rve)
                listJ(Zero,rve) = k4
                k4 = listk(i4,rve)
  372       continue
              listk(i4,rve) = Zero
            endif
c
c-----------add new leg to the equivalent loading path. Lines 70 and
c           71, Fig. 2 of [3]
            if(nremov.ge.0.and.zeta_s0(i4,rve).ne.0.) then
              if(zeta_s1(i4,rve).ne.0.) then
c---------------before adding the new leg, modify information about the 
c               previous rve.  Slide back the previous rve on the equivalent
c               load path (for example, point 3 to point 2a in Fig. 4b).  
c               See Line 55 of [3]
                k4 = listk(i4,rve)
                zeta_s(k4,rve) = zeta_s1(i4,rve)
                Fn_s(k4,rve) = Fn_s1(i4,rve)
                p_s(k4,1,rve) = p_s1(i4,1,rve)
                p_s(k4,2,rve) = p_s1(i4,2,rve)
              endif
c
c-------------the current "next available opening" in the linked list
              i_avail = listJ(Zero,rve)
c-------------after adding a leg to the equivalent loading path, the new "next
c             available opening" in the linked list
              i_avail2 = listJ(i_avail,rve)
c
c-------------check whether we have reached the end of the linked list
              if(i_avail2 .ne. -1) then
c---------------Line 70, Fig. 2 of [3]
                listJ(i_avail,rve) = listk(i4,rve)
                listk(i4,rve) = listJ(Zero,rve)
                listJ(Zero,rve) = i_avail2
                k4 = listk(i4,rve)
              else
                write(ScrUnit(rve),900) mlistJ
                write(ErrUnit(rve),900) mlistJ
  900         format(/,
     x         'Insufficient space in array listJ in subroutin Jager3D',
     x           /,'  Change the value of mlistJ in subroutin Jager3D',
     x           ' and in the param-dempla-0.2.2.f file.',
     x           /,'  The current value of mlistJ is ', i9)
                stop
              endif
c
c-------------add information about the new leg to the equivalent loading path
              zeta_s(k4,rve) = zeta_s0(i4,rve)
              Fn_s(k4,rve) = Fn_s0(i4,rve)
              p_s(k4,1,rve) = p_s0(i4,1,rve)
              p_s(k4,2,rve) = p_s0(i4,2,rve)
            endif
  141   continue
c
c---------approximate the equivalent load histories by removing adjacent
c         legs with similar slopes p_s()
          ltogl = .true.
          lJagEl = .false.
          call Jager3D_etc(Ebar(rve), A_1(rve),
     x                   palpha(rve), Cn(rve), kappa(rve),
     x                   frict2(rve), pdif2(rve),
     x                   lJsphr, lJcone, lJgen,
     x                   pnrgy2(rve), lApprox(rve),
     x                   lJagEl, ltogl, rve)
          ltogl = .false.
c
c---------compute the elastic energy at the contacts
          lJagEl = .true.
          call Jager3D_etc(Ebar(rve), A_1(rve),
     x                   palpha(rve), Cn(rve), kappa(rve),
     x                   frict2(rve), pdif2(rve),
     x                   lJsphr, lJcone, lJgen,
     x                   dpnrg2, lApprox(rve), lJagEl, ltogl,
     x                   rve)
c
c---------compute the energy dissipated in sliding during this time step
          dslide(rve) = dslide(rve) - dpnrg2
          pnrgy2(rve) = pnrgy2(rve) + dpnrg2
        endif
      endif
c
      if(algori.eq.2 .and. .not.linit(rve)) then
c-------we are using the 2nd DEM algorithm.  In this approach we cycle
c       through the force algorithm several times, until the particles
c       are close to being in equilibrium
c
        lreset(rve) = last
c
c
c-------integrate the accelerations and velocities to find the new particle
c       positions.
        call integ1(rve)
c
        lreset(rve) = .false.
c-------calculate whether to update the near-neighbor list
        call near(rve)
        if(lupdat(rve)) then
          nnnear(rve) = mnear
          nlist(rve) = mlist
          nnlist2(rve) = mlist2
          nlist3(rve) = mlist3
          nboxs(rve) = mboxes
          call lister(rve,nnnear(rve),
     x                     nlist(rve),nnlist2(rve),nlist3(rve),
     x                     nboxs(rve))
        endif
      endif
c
c-----check whether the arrays in subroutin Jager agree with those in
c     this subroutin
      if(frict(rve).gt.0. .and. ntacts(rve).ne.0
     x   .and. (lJager(rve) .or. lJagr2(rve)
     x          .or. lJagr3(rve) .or. lJagr4(rve))
     x   .and. (nlist2.ne.mlist2 .or. nlistJ.ne.mlistJ)) then
        write(ScrUnit(rve),973) nlist2,nlistJ,mlist2,mlistJ
        write(ErrUnit(rve),973) nlist2,nlistJ,mlist2,mlistJ
        stop
  973   format('values of mlist2 and mlistJ (', i9, ' and', i9,')',
     x         ' in subroutin Jager3D must ', 
     x         'agree with values in the param-dempla-0.2.2.f file ',
     x         '(', i9, ' and', i9,')')
      endif
c
c-----compute measures of force and moment imbalance on particles
      if(.not.last) then
        if(ftsq(rve).gt.0. .and. np(rve).ne.0) then
c---------the average force imbalance per particle (fbalsq/np) divided
c         by the average contact force (ftsq/ntacts)
          chi1(rve) = sqrt(fbalsq(rve)*ntacts(rve)
     x                      / (ftsq(rve)*np(rve)))
c
c---------the average moment imbalance per particle (thblsq/np) divided
c         by the average contact force (ftsq/ntacts) divided by the average
c         radius
c         if(lrotat(rve)) then
            chi2(rve) = sqrt(thblsq(rve)*ntacts(rve)
     x                        / (ftsq(rve)*np(rve)))/ravg(rve)
c         else
c           chi2(rve) = 0.
c         endif
c
c---------the average contact damping force per particle divided by the average
c         contact force
          chi3(rve) = sqrt(fdmpav/ftsq(rve))
c
c---------the average body damping force per particle (fdampa/np) divided 
c         by the average contact force(ftsq/ntacts)
          chi4(rve) = sqrt(fdampa(rve)*ntacts(rve)
     x                      / (ftsq(rve)*np(rve)))
        else
          chi1(rve) = 0.
          chi2(rve) = 0.
          chi3(rve) = 0.
          chi4(rve) = 0.
        endif
c
c-------an average of chi1 and chi2
        chiavg(rve) = (chi1(rve) + chi2(rve)) / 2.d0
      endif
c
      if(.not.last) then
c-------we will loop back through the force calculation algorithm again
c       when algori=2
c
c-------the number of loops
        iloops = iloops + 1
        goto 101
      else
        loopst(rve) = loopst(rve) + iloops
      endif
c
      if(iloops.gt.nloops) then
        lpsxcd(rve) = lpsxcd(rve) + 1
      endif
c
c-------------------------------------------------------------------
c
c-----calculate the volume of the assembly
c     if((iflexc(1)/10)*mod(iflexc(1),10).eq.0) then
        vcell(rve) = 1.d0
        do 119 i = 1,ndim1
          vcell(rve) = vcell(rve)*xcell(i,i,rve)*xcelle(i,rve)
  119   continue
c     endif
c
c-----the inverse of the cell volume
      vcelli(rve) = 1.d0 / vcell(rve)
c
c-----mean effective stress
      stravg(rve) = 0.
c
c-----effective stress.  Divide the sum of the stress contribution 
c     by the assembly volume
      stress(1,1,rve) = stress_11*vcelli(rve)
      stress(2,1,rve) = stress_21*vcelli(rve)
      stress(3,1,rve) = stress_31*vcelli(rve)
      stress(1,2,rve) = stress_12*vcelli(rve)
      stress(2,2,rve) = stress_22*vcelli(rve)
      stress(3,2,rve) = stress_32*vcelli(rve)
      stress(1,3,rve) = stress_13*vcelli(rve)
      stress(2,3,rve) = stress_23*vcelli(rve)
      stress(3,3,rve) = stress_33*vcelli(rve)
      if(ndim1.eq.2) then
        stravg(rve) = stress(1,1,rve) + stress(2,2,rve)
      elseif(ndim1.eq.3) then
        stravg(rve) = stress(1,1,rve) + stress(2,2,rve)
     x                 + stress(3,3,rve)
      endif
c
c-----the mean stress (the negative pressure)
      stravg(rve) = stravg(rve) / ndim1
c
      if(lporo(rve)) then
c-------we compute total stress, which includes the pore fluid pressure
c
c-------when started from a D-file, changes in the effective stress
c       are computed relative to the effective stress at the start
c       of the simulations
        if(timer(rve).eq.0. 
     x     .and. (istart(rve).eq.1 .or. istart(rve).eq.2)) then
c---------reference stress at the start of the simulation
          stres0(1,1,rve) = stress(1,1,rve)
          stres0(2,2,rve) = stress(2,2,rve)
          stres0(3,3,rve) = stress(3,3,rve)
c
c---------reference porosity at the start of the simulation
          poros0(rve) = porosn(rve)
        endif
c
c-------Jacobian of the bulk deformation gradient
        J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
        if(.not.ldrain(rve)) then
c---------drainage is being controlled. We must compute the pore fluid pressure
c
          if(iporo(rve).eq.1) then
c-----------the simplest model of pore fluid compressibility.  Assumes
c           full saturation
c           * "defw" is net inflow of pore fluid per unit of original volume:
c             the difference between the Jacobian of the bulk (skeleton) 
c             deformation gradient and the Jacobian of the deformation 
c             gradient of the pore fluid.  When multiplied by the original 
c             porosity, "defw" is the volumetric inflow of fluid per unit 
c             of original volume.  That is, it is a "discharge" inflow 
c             (instead of a "seepage" inflow), referenced to the original 
c             volume.  For undrained conditions, "defw" is zero.
c           * poros0 is the original porosity (typically, this is established
c             at the data in a D-file)
c           * p_o is the original pore fluid pressure (provided in the RunFile,
c             or from a C-file)
c           * stres0 is the effective stress tensor (typically, this is 
c             established when started with a D-file or carried over in
c             a C-file)
            pfluid(rve) = p_o(rve)
     x               + (1.d0 - J_f + poros0(rve)*defw(rve)
     x                   + (1.d0 - poros0(rve))
     x                     *( (stress(1,1,rve) + stress(2,2,rve)
     x                         + stress(3,3,rve))
     x                       -(stres0(1,1,rve) + stres0(2,2,rve)
     x                         + stres0(3,3,rve)))
     x                      /(3.d0*K_s(rve)))
     x                 / ((1.d0 - poros0(rve))/K_s(rve) 
     x                           + poros0(rve)/K_f(rve))
c
          elseif(iporo(rve).eq.3) then
c-----------a model of pore fluid compressibility that includes dissolution
c           of pore gas and includes surface tension of gas bubbles.
c           Besides the parameters listed above, these other parameters are
c           involved in computing the water pressure.  Note that "pfluid"
c           is the liquid-phase pore pressure, measured relative to 
c           atmospheric pressure
c
c           * gamm is the bubble surface tension
c           * p_atm is the reference atmospheric pressure
c           * Hcc is the dimensionless Henrys coefficient
c           * S_o is the initial saturation of the pore fluid with liquid
c           * D_o is the initial bubble size
c           * N_o is the initial number/density of bubbles
c
c-----------compressibility of pore liquid
            C_w = 1.d0 / K_f(rve)
c
c-----------change in mean effective stress from the original (reference)
c           condition
            dm_stress = 
     x        ( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x         -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve)))
     x        /3.d0
c
c-----------whether to compute (1) water pressure with a given strain, or
c           (2) fluid strain with a given water pressure
            itask = 1
c
c-----------small number that is used to find the threshold
c           volumetric strain (or water pressure) of the pore
            epsv = 1d-10
c
            call bubble(gamm(rve), p_atm(rve), p_o(rve), 
     x                  Hcc(rve), C_w, S_o(rve), D_o(rve), N_o(rve),
     x                  J_f, pfluid(rve), p_vap(rve), p_wcav(rve), 
     x                  Dcurnt, S_now(rve),
     x                  K_s(rve), poros0(rve), defw(rve), dm_stress,
     x                  Dlast(rve), itask)
c
c-----------maximum fluid pressure
            if(jCap(rve).eq.1) then
              pfluid(rve) = min(pfluid(rve), pCap(rve))
            endif
c
c-----------save current bubble diameter, to expedite the next time step
            Dlast(rve) = Dcurnt
          elseif(iporo(rve).eq.4) then
c-----------with this poroelastic model, the soil is assumed dry
c
c-----------Jacobian of the air's deformation gradient
            J_w = J_f - defw(rve)
c
c-----------air pressure, realtive to atmospheric pressure
            pfluid(rve) = (p_o(rve) + p_atm(rve))
     x                    * (1.d0
     x                       - (1.d0 - poros0(rve))
     x                         *(  ( (stress(1,1,rve) + stress(2,2,rve)
     x                                + stress(3,3,rve))
     x                              - (stres0(1,1,rve) + stres0(2,2,rve)
     x                                 + stres0(3,3,rve)))
     x                             / (3.d0*K_s(rve))
     x                           + (p_o(rve) + p_atm(rve))
     x                             / K_s(rve)
     x                          )
     x                      )
     x                    / J_w
     x                    / (1.d0 - (p_o(rve) + p_atm(rve))
     x                              * (1.d0 - poros0(rve))
     x                              / (K_s(rve) * J_w))
     x                    - p_atm(rve)
          endif
        endif
      endif
c
c-----the average normal force
      if(ntacts(rve).ne.0) then
        fnavg(rve) = fnavg(rve) / ntacts(rve)
      else
        fnavg(rve) = 0.
      endif
c
c-----the average normal force among sliding contacts
      if(nslide(rve).ne.0) then
        fnavg2(rve) = fnavg2(rve) / nslide(rve)
      else
        fnavg2(rve) = 0.
      endif
c
c-----total expended work since the start of the simulation.  Divide by the
c     original volume
      slidet(rve) = slidet(rve) + dslide(rve) / vcellt(rve)
c
c-----elastic energy stored at contacts per unit of original volume
c
      if(imodel(rve).eq.0 .or. lsinh(rve)) then
c-------normal contact elastic energy of all contacts per unit of original
c       volume
        pnrgy1(rve) = pnrgy1(rve) / 2.d0 / knh(rve) / vcellt(rve)
c
c-------tangential contact elastic energy of all contacts per unit of original
c       volume
        pnrgy2(rve) = pnrgy2(rve) / 2.d0 / kth(rve) / vcellt(rve)
c       
c-------total cotnact elastic energy of all contacts
        pnrgy(rve) = pnrgy1(rve) + pnrgy2(rve)
      elseif(lHertz(rve)) then
        pnrgy1(rve) = pnrgy1(rve) / vcellt(rve)
        pnrgy2(rve) = pnrgy2(rve) / vcellt(rve)
c
c-------total cotnact elastic energy of all contacts
        pnrgy(rve) = pnrgy1(rve) + pnrgy2(rve)
      elseif(lJager(rve) .or. lJagr2(rve)
     x       .or. lJagr3(rve) .or. lJagr4(rve)) then
c-------normal and tangential contact elastic energy of all contacts
        pnrgy1(rve) = pnrgy1(rve) / vcellt(rve)
        pnrgy2(rve) = pnrgy2(rve) / vcellt(rve)
c
c-------total cotnact elastic energy of all contacts
        pnrgy(rve) = pnrgy1(rve) + pnrgy2(rve)
      endif
c
c-----compute work done by average stress
      dwork1 = 0.
c
      do 510 i = 1,ndim1
        do 520 j = 1,ndim1
c-----------the increment of work during the past time step
            dwork1 = dwork1 + ddefme(i,j,rve)*
     x                        (stress(i,j,rve) + strold(i,j,rve))/2.d0
  520   continue
  510 continue
c
c-----we express this work per unit of original volume
      work1t(rve) = work1t(rve) + dwork1 * vcell(rve) / vcellt(rve)
c
      if(algori.eq.1) then
c-------the viscous work done at the contacts per unit of original volume
        viscc = viscc / vcellt(rve)
c
c-------the viscous work since the beginning of the simulation
        viscct(rve) = viscct(rve) + viscc
      endif
c
c-----number of time increments since the last printout of results
      ipoint(rve) = ipoint(rve) + 1
c
c-----calculate chi1, a measure of the average force acting on a particle.
c     Large values of chi1 indicate an imbalance of the contact forces on
c     individual particles, large accelerations, and a poor approximation
c     of pseudo-static conditions.  chi1 is normalized by dividing the average
c     net force acting on the particles by the average magnitude on the
c     contact forces.
c
      if(ftsq(rve).gt.0. .and. np(rve).ne.0) then
c-------the average force imbalance per particle (fbalsq/np) divided
c       by the average contact force (ftsq/ntacts)
        chi1(rve) = sqrt(fbalsq(rve)*ntacts(rve)
     x                    / (ftsq(rve)*np(rve)))
        chi1t(rve) = chi1t(rve) + chi1(rve)
c
c-------the average body damping force per particle (fdampa/np) divided
c       by the average contact force(ftsq/ntacts)
        chi4(rve) = sqrt(fdampa(rve)*ntacts(rve)
     x                    / (ftsq(rve)*np(rve)))
        chi4t(rve) = chi4t(rve) + chi4(rve)
      else
        chi1(rve) = 0.
        chi4(rve) = 0.
      endif
c
      if(ravg(rve).ne.0. .and. ftsq(rve).gt.0.) then
c-------the average moment imbalance per particle (thblsq/np) divided
c       by the average contact force (ftsq/ntacts) divided by the average
c       radius
c       if(lrotat(rve)) then
          chi2(rve) = sqrt(thblsq(rve)*ntacts(rve)
     x                      / (ftsq(rve)*np(rve))) / ravg(rve)
c       else
c         chi2(rve) = 0.
c       endif
c
c-------we sum the chi2 values for several time steps.  These will later
c       be averaged when the values are printed as output in subroutin 'output'
        chi2t(rve) = chi2t(rve) + chi2(rve)
c
c-------the average contact damping force per particle divided by the average
c       contact force
        chi3(rve) = sqrt(fdmpav/ftsq(rve))
c-------we sum the chi3 values for several time steps.  These will later
c       be averaged when the values are printed as output in subroutin 'output'
        chi3t(rve) = chi3t(rve) + chi3(rve)
      else
        chi2(rve) = 0.
        chi3(rve) = 0.
      endif
c
c-----the average value will be used with algori=2 when determining whether
c     enough cycles have been completed for this deformation step
      chiavg(rve) = (chi1(rve) + chi2(rve))/2.0d0
c
      linit(rve) = .false.
      llast(rve) = .false.
c
c-----the average overlap among the particles.  With this measure,
c     we count multiple contacts between a particle pair as a single contact
      if(ntacts(rve).ne.0) then
        ovravg(rve) = ovravg(rve) / ntacts(rve)
      else
        ovravg(rve) = 0.
      endif
c
c-----the average overlap among the particles.  With this measure,
c     we find the average overlap by individual contacts
      if(ntactz(rve).ne.0) then
        ovravgz(rve) = ovravgz(rve) / ntactz(rve)
      else
        ovravgz(rve) = 0.
      endif
c
c-----the average number of torus-torus detection interations per
c     torus-torus pair
      if(ntorus.ne.0) then
        sweep(rve) = dble(nsweep) / dble(ntorus)
      else
        sweep(rve) = 0.
      endif
c
c-----for linear-frictional contacts, the old normal forces have
c     now been computed
      linitf(rve) = .false.
c
      return
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine near(rve)
c
c-----this subroutin computes various diagnostics for measuring the
c     performance of the simulation.
c
c-----this subroutin does the following determines whether the linked list of
c     nearly-touching particles must be updated.  The linked list was
c     constructed in subroutin "lister", where "nearly-touching" means a
c     separation of no more than the input distance "seprat".  During the
c     subsequent time steps, the particles move, this subroutin determines
c     whether the particles might have moved enough to bring two particles
c     into contacts
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 box1,box2,i,igrain,iptbx,j,jboxi,k,nwmod4
      integer*2 rve
c
      logical ldth
c
      dimension dthmax(mboxes),dxmin(3),dxmax(3),
     x          dxminb(3,mboxes),dxmaxb(3,mboxes)
      dimension jboxi(3)
      dimension kmax(3),kmin(3)
c     dimension dymin(3),dymax(3),iymin(3),iymax(3)
c
c-----calculate various diagnostics following subrotin forces
c
c-----the number of time steps since the last update of the linked list
c     (in subroutin lister)
      iupdat(rve) = iupdat(rve) + 1
c
c-----incremental particle rotations, which might bring two non-spherical
c     particles into contact
      dthmr = 0.
c
c-----find the maximum relative movement between particles in
c     adjoining cells, to determine whether to update the linked list of
c     near-neighbors.  A "near-neighbor" is defined as a pair of particles 
c     whose separation is less than the variable "sep", which is derived
c     from the input file.  Near-neighbors are identified with
c     subroutin "lister".  However, it is not necessary to enter 
c     "lister" with each time step.  (The subroutin "lister" requires
c     significant computational time.)  So "lister" is only entered 
c     periodically.  The trick is to enter "lister" before any
c     pair of particles, not previously in the near-neighbor list,
c     can come into contact.  The following code identifies whether
c     any pair of particles could have approached each other by more
c     than the critical distance "sep".  If so, "lister" will need to
c     be run.
c
c-----the following code searches through a grid of cells (boxes) and determins
c     the maximum (and minumum) velocity of particles within each cell.
c     The particles were placed into the cells during the near-neighbor
c     search of subroutin lister.
c
c     We then consider neighboring cells to determin the maximum relative
c     velocity between particle pairs (actually just an upper bound of
c     the relative velocity).  We use this relative velocity to determine
c     whether it is possible for two particles (which are not currently
c     in the near-neighbor list to be in near contact.
c
c-----non-spherical or non-circular particles
      ldth = loval(rve) .or. lelips(rve)
     x       .or. lovoid(rve) .or. lnobby(rve) .or. lbumpy(rve)
c
c-----search through each box (cell)
      do 240 box1 = 1,nboxes(rve)
c
c-------initialize the max. and min. particle velocities within each box
        do 246 i = 1,ndim1
          dxminb(i,box1) = xcell(i,i,rve)*10.
          dxmaxb(i,box1) = -dxminb(i,box1)
  246   continue
c
c-------for non-cirular, non-sphereical particles, we will want to compute
c       the possible effect of particle rotations on the particles' proximity
        if(ldth) then
          dthmax(box1) = 0.
        endif
c
c-------search through the linked list for the contents of this cell,
c       which are the various particles that comprise the entire assembly.
c       We use a singly connected linked list data structure to store
c       the contents fo the various boxes.
c
c-------the header link
        iptbx = iptbx1(box1,rve)
c
        do 242 while(iptbx.ne.0)
          igrain = iptbx2(iptbx,rve)
          if(lcircl(rve).or.lspher(rve)) then
c
          elseif(loval(rve).or.lelips(rve)) then
c-----------with ovals and ellipses, include the effect of particle rotations,
c           which can bring an arc into proximity of another arc
            dthmax(box1) = max(dthmax(box1), 
     x                      abs(rad(igrain,rve)
     x                          *(1.d0 - aspect(igrain,rve))
     x                      * thmove(3,igrain,rve)))
          elseif(lnobby(rve)) then
c-----------non-circular nobby particles (2D). Here we use the difference
c           between the inner and outer radii of a particle
            dthmax(box1) = max(dthmax(box1),
     x                         abs(rad(igrain,rve)*(rout(rve)
     x                             - rin(rve))
     x                         * thmove(3,igrain,rve)))
          elseif(lbumpy(rve)) then
c-----------non-spherical bumpy particles (3D). Here we use the difference
c           between the inner and outer radii of a particle
            dthmax(box1) = max(dthmax(box1),
     x                         abs(rad(igrain,rve)
     x                             *(rout(rve) - rin(rve)))
     x                         * sqrt(thmove(1,igrain,rve)**2 +
     x                                thmove(2,igrain,rve)**2 +
     x                                thmove(3,igrain,rve)**2))
          elseif(lovoid(rve)) then
c-----------with ovoids, include the effect of particle rotations
            dthmax(box1) = max(dthmax(box1),
     x                     abs(rad(igrain,rve)
     x                         *(1.d0 - aspect(igrain,rve)))
     x                     * sqrt(thmove(1,igrain,rve)**2 +
     x                            thmove(2,igrain,rve)**2 +
     x                            thmove(3,igrain,rve)**2)
     x                        )
          endif
c
          iptbx = iptbx1(iptbx,rve)
c
c---------min and max movements within a box
          do 244 i = 1,ndim1
            dxminb(i,box1) = min(dxminb(i,box1),xmove(i,igrain,rve))
            dxmaxb(i,box1) = max(dxmaxb(i,box1),xmove(i,igrain,rve))
  244     continue
  242   continue
  240 continue
c
c-----determine the number of neighboring cells that will be searched in
c     each coordinate direction.  For very small assemblies, with just
c     one or two cells in any direction, we must be sure that we don't
c     "wrap" around the periodic boundary to search in the identical cell
      do 33 i = 1,3
        if(nbox(i,rve).le.2) then
c---------two or fewer cells in direction "i"
          kmin(i) = 0
        else
          kmin(i) = -1
        endif
c
        if(nbox(i,rve).le.1) then
          kmax(i) = 0
          if(nbox(i,rve).eq.0) then
            write(ScrUnit(rve),*)
     x        'Oops! What happened here? Zero grids in the ',
     x        'near-neighbor search?!'
            stop
          endif
        else
          kmax(i) = 1
        endif
   33 continue
c
c-----initialize the relative velocities between the max and min velocities
c     of particles in neighboring cells
      do 216 i = 1,ndim1
        dxmin(i) = xcell(i,i,rve)*10.
        dxmax(i) = -dxmin(i)
  216 continue
c
c-----look through all of the boxes (cells), containing particles
      do 200 box1 = 1,nboxes(rve)
c-------the maximum and minimum (negative) relative particle velocities 
c       within the current box
        do 218 i = 1,ndim1
          dxmin(i) = min(dxmin(i),dxminb(i,box1)-dxmaxb(i,box1))
          dxmax(i) = max(dxmax(i),dxmaxb(i,box1)-dxminb(i,box1))
  218   continue
c
c-------now, search through all of the surrounding boxes (cells) to find the
c       the maximum and minimum particle velocities within these boxes (cells).
c       These velocities will be used to find the max and min relative
c       particle velocities between the current box (box1) and the surrounding
c       boxes (cells).
c
c-------there are usually three rows, -1,0,1, of boxes in each
c       coordinate direction (i,j,k)
        do 210 i = kmin(1),kmax(1)
c---------locate the neighboring boxes' x1-location
          jboxi(1) = boxi(box1,1,rve) + i
c---------periodic boundaries in the 1 direction
          jboxi(1) = nwmod4(jboxi(1),nbox(1,rve))
c
          do 212 j = kmin(2),kmax(2)
c-----------locate the neighboring boxes' x2-location
            jboxi(2) = boxi(box1,2,rve) + j
            jboxi(2) = nwmod4(jboxi(2),nbox(2,rve))
c
            do 214 k = kmin(3),kmax(3)
c-------------locate the neighboring boxes' x3-location
              jboxi(3) = boxi(box1,3,rve) + k
              jboxi(3) = nwmod4(jboxi(3),nbox(3,rve))
c
              box2 = box(jboxi(1),jboxi(2),jboxi(3),rve)
c
              if(ldth) then
                dthmr = 1.d0*(dthmax(box1) + dthmax(box2))
              endif
c
c-------------the maximum relative velocity among all particles in
c             a cluster of boxes (cells)
              do 220 l = 1,ndim1
                dxmin(l) = 
     x              min(dxmin(l),dxminb(l,box2)-dxmaxb(l,box1)-dthmr)
                dxmax(l) = 
     x              max(dxmax(l),dxmaxb(l,box2)-dxminb(l,box1)+dthmr)
  220         continue
c
  214       continue
  212     continue
  210   continue
  200 continue
c
c-----now that we have found these maximum and minimum relative velocities
c     between particles, we will add the effects of deformation (not
c     included in the velocities themselves) that may bring particles
c     closer together.
      dxym(rve) = 0.
      do 250 i = 1,ndim1
        dxabs = max(abs(dxmin(i)),abs(dxmax(i)))
c-------add deformation effects, which can bring particles closer
c       together
        dxabs = dxabs + 
     x          abs(def(i,i,rve)-defup(i,rve))*2.d0*
     x              (rmax(rve) + (sep(rve)-seprat0(rve))*0.5d0)
        dxym(rve) = dxym(rve) + dxabs**2
  250 continue
c
c-----the maximum (actually an upper bound of) accumulated relative
c     movement among the particles
      dxym(rve) = sqrt(dxym(rve))
c
c-----is it time for another update?  Check each of two criteria.
c     Whether two particles (not currently in the near-neighbor list)
c     may now be in near contact.  Whether the input value of iupdtm
c     has been exceeded.
      lupdat(rve) = dxym(rve).ge.(sep(rve)-seprat0(rve))
     x         .or. iupdat(rve).ge.iupdtm(rve)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine newdt(rve)
c
c-----this subroutin computes a new, optimized time step
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        double precision chilmt, dfactr, dfactor, dtfact, dtmax,
     x                   fac, fac2, massi, mnti, t1, t2,
     x                   vmnt2p
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain,nchilmt
        integer*2 rve
c
c       logical 
c
        dimension chilmt(0:10), dfactr(0:10)
c
        if(lnewc(rve)) then
          nchilmt = 4
          chilmt(0) = 0.
          chilmt(1) = 0.020d0
          chilmt(2) = 0.030d0
          chilmt(3) = 0.050d0
          chilmt(4) = 0.100d0
c
          dfactr(0) = 1.d0
          dfactr(1) = 1.25d0
          dfactr(2) = 1.40d0
          dfactr(3) = 1.50d0
          dfactr(4) = 2.00d0
c
          do 77 i = 0,nchilmt
            if(chia1(rve) .gt. chilmt(i)) then
              dfactor = dfactr(i)
            endif
   77     continue
        else
          dfactor = 1.d0
        endif
c
        if(lnewdt(rve)) then
c
c---------with Hertz-type contacts, we must somehow estimate the contact
c         stiffnesses, so that a time step (or density) can be selected.
c         This is not a problem with linear contacts, since the contact 
c         stiffness is independent of the contact overlaps.  So with 
c         Hertz-contacts we will estimate the average stiffness by 
c         determining the average contact overlap.  This means that we 
c         must use subroutin lister to find the average overlap.
          if(lHertz(rve) .or. lJager(rve)
     x       .or. lJagr2(rve) .or. lJagr3(rve) .or.lJagr4(rve)) then
c
c-----------check whether there is a sufficient number of contacts to
c           for a load-bearing network of contacts.  If not, assign a small
c           value to ovravg
            ovrmin = 1.00d-5
            if((     (ndim1.eq.2 .and. ntacts(rve).lt.0.35d0*np(rve)) 
     x           .or.(ndim1.eq.3 .and. ntacts(rve).lt.0.50d0*np(rve)))
     x          .and.ovrsav(rve).ne.0.)
     x      then
              ovravg(rve) = ovrsav(rve)
            endif
c
c-----------note that the average overlap (ovravg) includes multiple contacts
c           between (non-convex) particle pairs
            if(lHertz(rve) .or. lJager(rve) .or. lJagr3(rve)) then
c-------------contacts between spherical contours
              knh(rve) = (3.d0/4.d0)*Ebar(rve)
     x                    *sqrt(ovravg(rve) * ravg(rve) / 2.d0)
            elseif(lJagr2(rve)) then
c-------------contacts between conical contours
              knh(rve) = (3.d0/pi/2.d0)* Ebar(rve)
     x              / A_1(rve) * (ovravg(rve) / 2.d0)
            elseif(lJagr4(rve)) then
c-------------contacts between general surfaces of revolution
              knh(rve) = (Cn(rve) / 2.d0)
     x              * (1.d0 + 1.d0/palpha(rve)) 
     x              * (ovravg(rve) / 2.d0)**(1.d0/palpha(rve))
            endif
c
            if(ndim1.eq.2) then
              knh(rve) = 2.0d0 * knh(rve)
              kratio(rve) = 1.d0
            elseif(ndim1.eq.3) then
              if(lHertz(rve)) then
                knh(rve) = 2.8d0 * knh(rve)
                kratio(rve) = 2.d0
              elseif(lJager(rve) .or. lJagr3(rve)) then
                knh(rve) = 2.8d0 * knh(rve)
                kratio(rve) = 1.d0
              elseif(lJagr2(rve)) then
                knh(rve) = 2.0d0 * knh(rve)
                kratio(rve) = 1.d0
              elseif(lJagr4(rve)) then
                knh(rve) = 2.4d0 * knh(rve)
                kratio(rve) = 1.d0
              endif
              kn(rve) = 2.d0 * knh(rve)
            endif
            kt(rve) = kratio(rve)*kn(rve)
            knh(rve) = kn(rve) / 2.d0
            kth(rve) = kt(rve) / 2.d0
            knmax(rve) = kn(rve)
          endif
c
c---------average of the normal and tangential stiffnesses
          if(kt(rve).ne.0.) then
            kmean(rve) = sqrt(knmax(rve)*kt(rve))
          else
            kmean(rve) = knmax(rve)
          endif
c
c---------with nobby and bumpy particles, it seems that things run more
c         efficiently when we compute the particle mass (or time step) 
c         using a contact stiffness that is larger than the stiffness 
c         computed above
          if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
            kmean(rve) = 3.0d0 * kmean(rve)
          elseif(lnobby(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
            kmean(rve) = 1.5d0 * kmean(rve)
          endif
c
c---------with the Jager contact, it seems that things run more efficiently 
c         when we compute the particle mass (or time step) using a contact
c         stiffness is larger (bumpy particles) or smaller (other particles) 
c         than the stiffness computed above
          if(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)) then
            if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
              kmean(rve) = 3.0d0 * kmean(rve)
            else
              kmean(rve) = 1.00d0 * kmean(rve)
            endif
          elseif(lJagr4(rve)) then
            if(lbumpy(rve) .and. rout(rve).gt.rin(rve)*1.05d0) then
              kmean(rve) = 2.5d0 * kmean(rve)
            else
              kmean(rve) = 1.00d0 * kmean(rve)
            endif
          endif
c
c---------the time increment, dt
c
c---------factors for computing (or checking) the time step:
c
c---------factor for the maximum stable time step.  I found these by trial
c         and error.  When both "dt" and "rho" are assigned non-zero values
c         in the RunFile, these values will be ignored (see below).
          if(ndim1.eq.2) then
            if(lexact) then
c-------------assign different masses to all particles
              t2 = 0.6d0
            else
c-------------assign the same mass to all particles
              t2 = 0.5d0
            endif
            fac = 6.75d0
c-----------for a disk, the moment of inertia divided by the mass and r^2
            fac2 = 0.5d0
          elseif(ndim1.eq.3) then
            if(lexact) then
              t2 = 0.6d0
            else
              t2 = 0.4d0
            endif
c
c-----------for a sphere, the moment of inertia divided by the mass and r^2
            fac2 = 0.4d0
c
            if(.not.(lJager(rve) .or. lJagr2(rve)
     x               .or. lJagr3(rve) .or. lJagr4(rve))) then
              if(.not.lbumpy(rve)) then
                fac = 1.75d0
              elseif(lbumpy(rve)) then
                fac = 2.00d0
                fac2 = Imean(rve) / VolumQ(rve)
              endif
            elseif(lJager(rve) .or. lJagr3(rve)) then
              if(lbumpy(rve)) then
                fac = 4.00d0
                fac2 = Imean(rve) / VolumQ(rve)
              elseif(lovoid(rve)) then
c               fac = 1.5d0 * avasp
                fac = 1.5d0 * sqrt(avasp(rve))
              else
                fac = 1.50d0
              endif
            elseif(lJagr2(rve)) then
              if(.not.lbumpy(rve)) then
                fac = 1.75d0
              elseif(lbumpy(rve)) then
                fac = 2.00d0
                fac2 = Imean(rve) / VolumQ(rve)
              endif
            elseif(lJagr4(rve)) then
              if(.not.lbumpy(rve)) then
                fac = 1.625d0
              elseif(lbumpy(rve)) then
                fac = 2.75d0
                fac2 = Imean(rve) / VolumQ(rve)
              endif
            endif
          endif
c
c---------factor for the recommended time step
          t1 = 0.8d0 * t2
c
c---------the time step and density (rho) was specified in the RunFile.  
c           if you set dt=0 and rho>0  then Oval will assign a recommended
c                                      stable time step, otherwise it will
c           if you set dt>0 and rho=0  then Oval will assign a density that
c                                      will make the given time step stable
c           if you set dt=0 and rho=0  then Oval will set dt=1 and assign a
c                                      density that will make the dt=1 stable
c           if you set dt>0 and rho>0  then Oval will use both of these given
c                                      values 
c           if, however dt > the stable time step, then Oval will print an error
c                                      message and stop
c           if you set dt<0 and rho>0  same as if dt=0, except that the time
c                                      step is increased by the factor abs(dt)
c           if you set dt<0 and rho=0  same as if dt=0, except that the time
c                                      step is increased by the factor abs(dt)
c           if you set dt=0 and rho<0  same as if dt=0, except that the density
c                                      is increased by the factor abs(rho)
c
          if(dtinp(rve).le.0.) then
            if(dtinp(rve).lt.0.) then
              dtfact = abs(dtinp(rve))
              fac2 = fac2 / 0.30d0
            else
              dtfact = 1.d0
            endif
c
            if(rhoinp(rve).le.0.) then
c-------------set dt=1 and compute the recommended mass
              dt(rve) = 1.d0
c
c-------------optimum mass, using the geometric mean of kn and kt
              massav(rve) = kmean(rve) * (dt(rve) / (t1*dtfact))**2
              dtmax = t2 / dtfact * sqrt(massav(rve) / knmax(rve))
              if(lexact) then
                rho(rve) = massav(rve) / volmin(rve)
              endif
            else
c-------------use the input "rho" and compute the recommended time step, using
c             the geometric mean of kn and kt
              if(lexact) then
                dt(rve) = t1 / dtfact
     x                     * sqrt(rho(rve)*volmin(rve) / kmean(rve))
                dtmax = t2 * sqrt(rho(rve)*volmin(rve) / kmean(rve))
              else
                dt(rve) = t1 / dtfact * sqrt(massav(rve) / kmean(rve))
                dtmax = t2 * sqrt(massav(rve) / kmean(rve))
              endif
            endif
          elseif(rhoinp(rve).le.0.) then
c-----------use the input time step and compute the recommended mass
            massav(rve) =  kmean(rve) * (dtinp(rve) / t1)**2
            dtmax = t2 * sqrt(massav(rve) / knmax(rve))
            if(lexact) then
              rho(rve) = massav(rve) / volmin(rve)
            endif
          else
c-----------use the input time step
            dt(rve) = dtinp(rve)
c-----------estimate the maximum time step that will maintain a stable
c           simulation
            dtmax = t2 * sqrt(massav(rve) / knmax(rve))
c
c-----------check whether the input time step exceeds the maximum stable 
c           time step
c           if(dt.gt.dtmax.or.dt.lt.0.) then
c             write(*,860) dt,dtmax
c             write(ErrUnit(rve),860) dt,dtmax
c             stop
c           endif
          endif
c
          if(lexact) then
            massd(rve) = rho(rve) * volavg(rve)
            mntav(rve) = rho(rve) * Iavg(rve)
          else
            massd(rve) = massav(rve)
            if(.not.(lHertz(rve) .or. lJager(rve)
     x               .or. lJagr2(rve) .or. lJagr3(rve)
     x               .or. lJagr4(rve))) then
              mntav(rve) = fac * fac2
     x                * (kratio(rve)*2.d0) * massav(rve)*ravg(rve)**2
            else
              mntav(rve) = fac * fac2 * massav(rve) * ravg(rve)**2
            endif
          endif
c
c---------some screen messages
c         write(*,920) dt,dtmax
c 920     format(/,'  Your time step is:               ',1pe12.5,/,
c    x             '  The maximum advised time step is:',1pe12.5)
c
c---------some more screen messages
c         if(rho.eq.0.) then
c           write(*,922) massav
c         else
c           write(*,923) rho
c         endif
c 922     format('  The reference particle mass is:  ',1pe12.5)
c 923     format('  The particle mass density is:    ',1pe12.5)
c
c
c---------when iexact=0, assign the same mass and moment of inertia to each
c         particle
          if(.not.lexact) then
c-----------assign a common mass and moment of intertia to each particle
            do 835 igrain = 1,np(rve)
              mass(igrain,rve) = massav(rve)
              mnt(igrain,rve) =  mntav(rve)
              if(lovoid(rve)) then
                mnt2(igrain,rve) = mntav(rve)
              endif
  835       continue
          else
c-----------assign individual masses and moments of intertia to each particle
            do 837 igrain = 1,np(rve)
              mass(igrain,rve) = rho(rve) * v_p(igrain,rve)
              mnt(igrain,rve) =  rho(rve) * vmnt_p(igrain,rve)
              if(lovoid(rve)) then
                vmnt2p = mnt2(igrain,rve)
                mnt2(igrain,rve) = rho(rve) * vmnt2p
              endif
  837       continue
          endif
c
c---------quantities required in the double-time integration algorithms:
c         inverse mass, inverse moment of inertia, etc.
          massi = 1.d0/massav(rve)
          massit(rve) = massi * dt(rve)
          mnti = 1.d0/mntav(rve)
          mntit(rve) = mnti * dt(rve)
c
c---------translational body damping coefficient.  The damping "pcrit(1)" is 
c         relative to the critical damping, 2.d0*sqrt(mass*knmax).  If the
c         input value of pcrit(1) is negative, we use its absolute value,
c         we only apply this damping to particles with no contacts (this feature
c         makes sense with non-periodic boundaries, when particles can possibly
c         "escape" from their confining boundaries
          damp1(rve) = dfactor*abs(pcrit(1,rve))*2.d0
     x                  *sqrt(massd(rve)*knmax(rve))
c
c---------factors used in the implicit integration scheme
          tdampa(rve) = 0.5d0*massit(rve)*damp1(rve)
          tfact1(rve) = 1.d0 - tdampa(rve)
          tfact2(rve) = 1.d0 + tdampa(rve)
c
c---------rotational body damping coefficient
          damp2(rve) = dfactor*abs(pcrit(2,rve))
     x                  *2.d0*ravg(rve)*sqrt(mntav(rve)*kt(rve))
c
c---------factors used in implicit integration scheme
          rdampa(rve) = 0.5d0*mntit(rve)*damp2(rve)
          rfact1(rve) = 1.d0 - rdampa(rve)
          rfact2(rve) = 1.d0 + rdampa(rve)
c
c---------Is contact damping being used?
c         lcdamp = pcrit(3,rve).ne.0.
c
c---------contact damping coefficients
          dampc1(rve) = dfactor*abs(pcrit(3,rve)) 
     x             * 2.d0*sqrt(massd(rve)*knmax(rve))
     x             * 0.5d0 / dt(rve)
          dampc4 = dfactor*abs(pcrit(3,rve)) 
     x             * 2.d0*sqrt(mntav(rve)*kt(rve))/ravg(rve)
     x             * 0.5d0 / dt(rve)
          dampc2(rve) = dampc4 * 0.50d0 * 0.25d0
        endif
c
c-------Factors for use with the Potyondy/Cundall type of damping
        adtm(rve) = pcrit(1,rve) * massit(rve) / 2.d0
        athdtm(rve) = pcrit(2,rve) * mntit(rve) / 2.d0
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer function switch(t,dt,tclock,tclokm,
     x                        dbegin,defi,seffi,stoti,finali,
     x                        igoala,igoalb)
c
c-----this subroutin determines whether it is time to enter a new
c     control step.  The input RunFile lists a series of control steps,
c     along with criteria of how long each control step is to last.
c     The criteria can be a given amount of elapsed time, or the
c     arrival of a particular stress or deformation condition.
c
c-----the output is = 1 if it is time to enter a new control step, the
c     output is = 0 if it is not yet time
c
      implicit double precision(a-h,o-z)
      double precision dt,tclock,tclokm,dbegin,defi,seffi,stoti,
     x                 finali,dnow
      integer*2 igoala,igoalb
c
c-----check whether a new control period has been entered . . . .
c
      if(t.eq.0.) then
        switch = 1
      elseif(igoala.eq.7) then
c-------with igoala=7, the control period lasts a specified period time; 
c       check whether this time has been exceeded
        if(tclock .gt. tclokm - dt*0.5d0) then
c---------note that tclock is the actual time, tcolkm is the time at which
c         to enter the next control step
          switch = 1
        else
          switch = 0
        endif
      else
c-------a limiting stress or deformation marks the end of the control period.
c       Find the difference between the present stress/deformation and the
c       final value that marks the end of the current control period
        if(igoalb.eq.0) then
c---------the control period is limited by a target deformation
          dnow = defi - finali
        elseif(igoalb.eq.1) then
c---------the control period is limited by a target effective stress
          dnow = seffi - finali
        elseif(igoalb.eq.2) then
c---------the control period is limited by a target total stress
          dnow = stoti - finali
        endif
c
        if(dbegin*dnow .ge. 0.) then
c---------when dbegin and dnow are of the same sign, then the deformation
c         or stress has "crossed over" the target value, and it is time
c         to switch to the next control period
          switch = 1
        else
          switch = 0
        endif
      endif
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine contrl(rve,OutputFolderName,OutputRunFile)
c  
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 jstep
      integer*2 ihelp,ihelp2,irve,rve,npnts
c
      double precision a(8,8),qis(8,8)
      logical lflag2,lprop
c
      character*400 OutputFolderName,OutputRunFile
c
      dimension jstep(3)
c
c-----this subroutin establishes the stress-strain control parameters
c     at the beginning of a new control period
c
c-----flags used in this subroutin
c       lflag1: t = 0 and this run is not being started with a restart file
c       lflag2: a new type of control is being used in a new control period
c
c-----a subscript of 1,2 or 3 is used with many variables to
c     designate xx, xy, and yy components respectively
c
c-----the current control period
      istep(rve) = istep(rve) + 1
      istep2(rve) = istep2(rve) + 1
c
c-----convert istep to a 3-character string.  First, find the digits of
c     istep.  Note that this code assumes that 0<= istep <= 999.  This
c     character string will become part of the file names created
c     with idump, imicro, and iplot
      jstep(1) = mod(istep(rve),10)
      jstep(2) = mod(istep(rve)/10,10)
      jstep(3) = mod(istep(rve)/100,10)
c
c-----the 3-character string, with the character '-'.
      cstep(rve) = achar(48+jstep(3))//achar(48+jstep(2))//
     x              achar(48+jstep(1))//'-'
c
c-----change the friction coefficient.  This option is enabled with
c     icoef=1.  Non-zero values of defdot give the friction coefficient,
c     and the coefficient is abruptly changed to this new value.
      if(icoef.eq.1 .and. defdot(istep(rve),rve).ne.0.) then
        frict(rve) = defdot(istep(rve),rve)
      else
        frict(rve) = frict_sav(rve)
      endif
      frict2(rve) = frict(rve)**2
      if(lHertz(rve) .or. lJager(rve)
     x   .or. lJagr2(rve) .or. lJagr3(rve) .or. lJagr4(rve)) then
        fk2(rve) =(frict(rve) * kappa(rve))**2
      endif
c
c-----should a "snapshot" of the current condition be stored: "F" and "H"
c     files, which can be analyzed later
      if(imicro(istep(rve),rve) .eq. 1) then
c-------create "F" files of particle positions, contact force, etc.
        call micro(rve)
      endif
c
      if(istep(rve).gt.1 .and.
     x   (     idump(istep(rve)-1,rve).ge.1)) then
c    x    .or. idump(istep(rve)-1,rve).eq.3
c    x    .or. idump(istep(rve)-1,rve).eq.5
c    x    .or. idump(istep(rve)-1,rve).eq.6) then
c-------a binary restart file will be created from the current condition.
c       Its name will be prefixed with 'C' and a second letter 
c       (beginning with 'a' for the first control step). This two-letter 
c       prefix will be followed by the name of the input file.
c
c-------the name of the file: C[a-z]$INPUT_FILE_NAME
c-------remove the .txt extension, if it exists
        if(     idump(istep(rve)-1,rve).eq.3
     x     .or. idump(istep(rve)-1,rve).eq.6) then
          if(itxt(rve).eq.0) then
            apend(rve) = 
     x        'C'//cstep(rve)//
     x        OutputFolderName(1:LEN_TRIM(OutputFolderName))//
     x        OutputRunFile(1:LEN_TRIM(OutputRunFile))
          else
            apend(rve) = 
     x              'C'//cstep(rve)//
     x              OutputFolderName(1:LEN_TRIM(OutputFolderName))//
     x              OutputRunFile(1:index(OutputRunFile,'.txt')-1)
          endif
        elseif(     idump(istep(rve)-1,rve).eq.1
     x         .or. idump(istep(rve)-1,rve).eq.4) then
          if(itxt(rve).eq.0) then
            apend(rve) = 
     x        'D'//cstep(rve)//
     x        OutputFolderName(1:LEN_TRIM(OutputFolderName))//
     x        OutputRunFile(1:LEN_TRIM(OutputRunFile))
          else
            apend(rve) = 
     x        'D'//cstep(rve)//
     x        OutputFolderName(1:LEN_TRIM(OutputFolderName))//
     x        OutputRunFile(1:index(OutputRunFile,'.txt')-1)
          endif
        endif
c
        idumpi(rve) = idump(istep(rve)-1,rve)
        call dumpot(rve)
      endif
c
c-----if the final control period has ended.  Ready to exit the program.
      if(istep(rve).gt.istepm(rve)) return
c
c-----report the results at the begining of each control period
      lreprt(rve) = ipoint(rve).ne.0
c
c-----initialize the previous control parameters
      if(timer(rve).eq.0) then
        if(istart(rve).ge.3) then
c---------the run begins with a C-file. The previous values are equal to
c         those saved in the C-file
          icontl(rve) = icontr(0,rve)
          icontpl(rve) = icontp(0,rve)
          defratl(1,rve) = defrat(1,0,rve)
          defratl(2,rve) = defrat(2,0,rve)
          defratl(3,rve) = defrat(3,0,rve)
          defratl(4,rve) = defrat(4,0,rve)
          defratl(5,rve) = defrat(5,0,rve)
          defratl(6,rve) = defrat(6,0,rve)
          defratl(7,rve) = defrat(7,0,rve)
          defratl(8,rve) = defrat(8,0,rve)
        else
          icontl(rve) = 0
          icontpl(rve) = 0
          defratl(1,rve) = 0.
          defratl(2,rve) = 0.
          defratl(3,rve) = 0.
          defratl(4,rve) = 0.
          defratl(5,rve) = 0.
          defratl(6,rve) = 0.
          defratl(7,rve) = 0.
          defratl(8,rve) = 0.
        endif
      endif
c
c-----lflag2=true designates a change in the type of stress-strain control
c     lflag2 = icontr(istep(rve),rve).ne.icontr(istep(rve)-1,rve)
c    x         .or. icontr(istep(rve),rve).ne.icontl(rve)
      lflag2 = icontr(istep(rve),rve).ne.icontl(rve)
c
c-----separate igoal into its two digits of information
      i10 = 10
      igoala(rve) = igoal(istep(rve),rve)/10
      igoalb(rve) = mod(igoal(istep(rve),rve),i10)
c
c-----if the new control period is to last a given amount of time,
c     establish the appropriate stopwatch parameters
      if(igoala(rve).eq.7) then
        tclock(rve) = 0.
        tclokm(rve) = finalv(istep(rve),rve)
c
      else
c-------if not, the new control period will last until the given limiting
c       value of stress or deformation is reached
c
c-------the difference between the new goal (the stress/deformation value
c       demarking then end of the new control period) and the condition at the
c       start of the control period.  This will be used to determine when the
c       end of the control period has been reached
c
        if(igoalb(rve).eq.0) then
c---------the goal is a deformation
          dbegin(rve) = finalv(istep(rve),rve)
     x                   - defv(igoala(rve),rve)
        elseif(igoalb(rve).eq.1) then
c---------the goal is an effective stress
          dbegin(rve) = finalv(istep(rve),rve)
     x                   - streff(igoala(rve),rve)
        elseif(igoalb(rve).eq.2) then
c---------the goal is a total stress
          dbegin(rve) = finalv(istep(rve),rve) 
     x                   - strtot(igoala(rve),rve)
        elseif(igoalb(rve).eq.4) then
          if(igoala(rve).eq.1) then
            dbegin(rve) = finalv(istep(rve),rve)
     x               - (stress(1,1,rve)
     x               - max(stress(2,2,rve),stress(3,3,rve)))
            str(1,rve) = str(1,rve) - max(str(2,rve),str(3,rve))
          elseif(igoala(rve).eq.2) then
            dbegin(rve) = finalv(istep(rve),rve)
     x               - (stress(2,2,rve)
     x               - max(stress(1,1,rve),stress(3,3,rve)))
            str(2,rve) = str(2,rve) - max(str(1,rve),str(3,rve))
          elseif(igoala(rve).eq.3) then
            dbegin(rve) = finalv(istep(rve),rve)
     x               - (stress(3,3,rve)
     x               - max(stress(1,1,rve),stress(2,2,rve)))
            str(3,rve) = str(3,rve) - max(str(1,rve),str(2,rve))
          endif
        endif
      endif
c
c-----the number of (servo-controlled) stress components.  The corresponding
c     unknown deformation must be solved with each time step.
      nsolve(rve) = 0
c
c-----the number of deformation components that are specified by input.
c-----These components will not need to be solved. 
      nknown(rve) = 0
c
c-----will the particles be allowed to rotate or move during this
c     stress-deformation control segment?  
c                   movements   rotations
c                   allowed ?   allowed ?
c       krotat = 0     yes        yes
c       krotat = 1     yes         no
c       krotat = 2      no        yes
c       krotat = 3      no         no
c
c     lrotat(rve) = krotat(istep(rve),rve).eq.0
c    x               .or. krotat(istep(rve),rve).eq.2
c     lmove(rve) =  krotat(istep(rve),rve).eq.0
c    x               .or. krotat(istep(rve),rve).eq.1
c
c-----set up variables for the servo-control of stresses
c
c-----control the mean stress?
      liso(rve) = .false.
c
c-----control the assembly volume?
      lvctrl(rve) = .false.
c
c-----control a deviator stress?
      lqcntr(rve) = .false.
c
c-----control total stress?
      ltotal(7,rve) = .false.
      ltotal(8,rve) = .false.
c
c-----the number of deformation components (11, 22, 33) that will be 
c     adjusted to maintain a constant mean stress
      niso(rve) = 0
c
c-----determine whether components have servo-controlled stresses or
c     prescribed strain rates
      do 20 i = 1,6
c-------parse the input value of icontr()
        icont(i,rve) = mod(icontr(istep(rve),rve),10**(7-i))
     x                  / 10**(6-i)
c
c-------whether to use this component to control the assembly volume
c       This option is implemented by assigning a "3" to the corresponding
c       digits of icontr(i) (first three digits only)
        ivctrl(i,rve) = 0
c
c-------proportional control of stress rates
        ip1cnt(i,rve) = 0
        ip2cnt(i,rve) = 0
c
c-------initialize whether total stress is being controlled
        ltotal(i,rve) = .false.
c
        if(icont(i,rve).eq.1) then
c---------servo-controlled of this stress component.  The effective stress
c         is controlled
          nsolve(rve) = nsolve(rve) + 1
          isolve(nsolve(rve),rve) = i
        elseif(i.le.ndim1 .and. icont(i,rve).eq.3) then
c---------the deformation corresponding to this component will be controlled
c         so that the total assembly volume changes at the rate defrat(i)
c
c---------the number of deformation components that are specified by input.
          nknown(rve) = nknown(rve) + 1
          iknown(nknown(rve),rve) = i
          ivctrl(i,rve) = 1
          lvctrl(rve) = .true.
        elseif(i.le.ndim1 .and. icont(i,rve).eq.2) then
c---------the mean stress will be conrolled, in part, by adjusting this
c         deformation
          niso(rve) = niso(rve) + 1
          iiso(niso(rve),rve) = i
c
          if(.not.liso(rve)) then
c-----------with more than one "2" in icontr(), solve only one component,
c           since the others will be adjusted by the same amount
            nsolve(rve) = nsolve(rve) + 1
            isolve(nsolve(rve),rve) = 7
            defrat(7,istep(rve),rve) = defrat(i,istep(rve),rve)
          endif
c
c---------the mean stress is being controlled
          liso(rve) = .true.
        elseif(i.le.ndim1 .and. icont(i,rve).eq.4) then
c---------the deviator stress will be conrolled.  When the "4" is placed 
c         in position "i", then we control 
c         (stress_ii - min(other_normal_stresses))
          iqcntr(rve) = i
c
          if(.not.lqcntr(rve)) then
c-----------with more than one "4" in icontr(), solve only one component.
            nsolve(rve) = nsolve(rve) + 1
            isolve(nsolve(rve),rve) = i
c           defrat(7,istep(rve)) = defrat(i,istep(rve))
          endif
c
c---------the mean stress is being controlled
          lqcntr(rve) = .true.
        elseif(ndim1.eq.3 .and. icont(i,rve).eq.5) then
c---------This componenent of stress will be controlled so that its rate
c         is proportional to the rate of a companion component of stress.
c         The companion component would normally advance under deformation
c         control.
c
c---------the component whose stress rate is being controlled to be 
c         proportional to a companion component's stress rate
          ip1cnt(i,rve) = i
c
c---------the companion component to which the proportional rate corresponds
          ip2cnt(i,rve) = ipts2(istep(rve),rve)
c
c---------the number of deformation components that are specified by input
          nsolve(rve) = nsolve(rve) + 1
          isolve(nsolve(rve),rve) = i
c
        elseif(icont(i,rve).eq.6 .and. lporo(rve)) then
c---------servo-controlled of this stress component.  The total stress
c         is controlled
          nsolve(rve) = nsolve(rve) + 1
          isolve(nsolve(rve),rve) = i
          if(i.le.3) then
            ltotal(i,rve) = .true.
          endif
        else
c---------a strain-controlled deformation component
c
c---------the number of deformation components that are specified by input.
          nknown(rve) = nknown(rve) + 1
          iknown(nknown(rve),rve) = i
        endif
   20 continue
c
c-----drained condition
      ldrain(rve) = .false.
c
c-----control parameters when pore fluid pressure is included with a
c     poroelastic analysis
      if(lporo(rve)) then
        if(icontp(istep(rve),rve).eq.0) then
c---------pore fluid inflow is controlled
c
c---------the number of deformation components that are specified by input.
          nknown(rve) = nknown(rve) + 1
          iknown(nknown(rve),rve) = 8
        elseif(icontp(istep(rve),rve).eq.1) then
c---------the pore pressure is being controlled.  This is a
c         drained condition, and the pore fluid inflow can be directly
c         computed, as this inflow does not affect the intergranular stress.
          ldrain(rve) = .true.
        endif
      else
        icontp(istep(rve),rve) = 0
      endif
c
c-----lflag2=true designates a change in the type of stress-strain control
c     relative to the previous control period
      if(lflag2) then
        lanch(rve) = .false.
c
        do 21 i = 1,3
          if(ndim1.eq.2
     x       .and. (icont(i,rve).eq.4 .or. icont(i,rve).eq.5)) then
            if(icont(i,rve).eq.5) then
              liso2(rve) = .true.
            endif
c
            lanch(rve) = .true.
c
            if(i.eq.1) then
              ianch(3,rve) = 1
              srint(rve) = defrat(1,istep(rve),rve)
              if(icont(2,rve).eq.0) then
                ianch(1,rve) = 2
                ianch(2,rve) = 3
              else
                ianch(1,rve) = 3
                ianch(2,rve) = 2
              endif
            elseif(i.eq.2) then
              ianch(3,rve) = 2
              srint(rve) = defrat(2,istep(rve),rve)
              if(icont(1,rve).eq.0) then
                ianch(1,rve) = 1
                ianch(2,rve) = 3
              else
                ianch(1,rve) = 3
                ianch(2,rve) = 1
              endif
            else
              ianch(3,rve) = 3
              srint(rve) = defrat(3,istep(rve),rve)
              if(icont(1,rve).eq.0) then
                ianch(1,rve) = 1
                ianch(2,rve) = 2
              else
                ianch(1,rve) = 2
                ianch(2,rve) = 1
              endif
            endif
c
            stranc(1,rve) = stress(ianch(1,rve),ianch(1,rve),rve)
            stranc(2,rve) = stress(ianch(2,rve),ianch(2,rve),rve)
            stranc(3,rve) = stress(ianch(3,rve),ianch(3,rve),rve)
c
            goto 22
          endif
   21   continue
      endif
c
   22 continue
c
c-----for purposes of stress control, select an approximate (servo) stiffness
c     of the controlled components
      do 30 i = 1,nsolve(rve)
c-------sift the particular controlled components from the entire 
c       approximate stiffness matrix "q"
        is = isolve(i,rve)
        do 50 j = 1,nsolve(rve)
          if(lporo(rve) .and. .not.ldrain(rve) 
     x       .and. ltotal(isolve(j,rve),rve)) then
            a(i,j) = q_alt(is,isolve(j,rve),rve)
          else
            a(i,j) = q(is,isolve(j,rve),rve)
          endif
   50   continue
   30 continue
c
      if(nsolve(rve).gt.0) then
        irve = 0
        imrve = 0
        call matinv(a,qis,nsolve(rve),ier,irve,imrve)
c
c-------place qis into the matrix qi
c       matrix from "qi"
        do 32 i = 1,8
          do 34 j = 1,8
            qi(i,j,rve) = qis(i,j)
  34      continue
  32    continue
c
        if(ier.eq.1) then
         write(ScrUnit(rve),*) 'Matrix is singular in subroutin contrl'
         write(ErrUnit(rve),*) 'Matrix is singular in subroutin contrl'
          stop
        endif
      endif
c
      nfacts(rve) = nsolve(rve)
c
c-----the number of historical (most recent) stress-strain results that
c     will be used to estimate the next servo-controlled 
c     deformation increment
      npnts = 2 + (nfacts(rve)*5)/4 + npnts_xtra
      xpnts(rve) = npnts
      np1(rve) = npnts + 1
c
      lnew(rve) = .false.
c
      if(lflag1(rve).or.lflag2) then
c-------t=0 and this run is not being started with a restart file
c       .or. the control type (icontr) has changed
        lflag1(rve) = .false.
        lprop = .false.
        lnew(rve) = .true.
c
      elseif(.not.lflag1(rve) .and. .not.lflag2) then
c-------the run is being started from a restart file
c       .and. the control type (icontr) has not changed
        lprop = .true.
        factor = 0.
c
c       if(icontr(istep(rve),rve) .ne. icontr(istep(rve)-1,rve)
c    x     .or. icontr(istep(rve),rve) .ne. icontl(rve)) then
        if(icontr(istep(rve),rve) .ne. icontl(rve)) then
          lprop = .false.
        endif
c
        do 120 i = 1,7
          if(defrat(i,istep(rve),rve).ne.0.) then
            if(factor.ne.0.) then
              if(abs(defrat(i,istep(rve),rve)
     x               - factor*defratl(i,rve)) .gt.
     x           abs(0.2d0 * defrat(i,istep(rve),rve))) then
                lprop = .false.
              endif
            else
              if(defratl(i,rve).ne.0.) then
                factor = defrat(i,istep(rve),rve)
     x                   / defratl(i,rve)
              else
                lprop = .false.
              endif
            endif
          elseif(defratl(i,rve).ne.0.) then
            lprop = .false.
          endif
  120   continue
c
        if(lprop .and. factor.eq.0.) then
          factor = 1.d0
        endif
      endif
c
      if(factor.lt.-1.0d-6) then
        lprop = .false.
      endif
c
      if(.not.lprop .and. .not.lovrid) then
c-------not a proportional control of stress components
        pn(rve) = -1.d0
        do 60 i = 1,nsolve(rve)
          do 70 j = 1,mstack
            dsreal(i,j,rve) = 0.
   70     continue
   60   continue
c
        do 75 i = 1,nfacts(rve)+1
          do 76 j = 1,mstack
            dsfals(i,j,rve) = 0.
   76     continue
   75   continue
c
        do 80 i = 1,nfacts(rve)+1
          do 93 j = 1,nsolve(rve)
            yi(i,j,rve) = 0.
   93     continue
c
          do 90 j = 1,nfacts(rve)+1
            xi(i,j,rve) = 0.
   90     continue
   80   continue
c
c-------a new type of control is being used
        lnew(rve) = .true.
c
        do 100 i = 1,nsolve(rve)
          is = isolve(i,rve)
          if(ltotal(is,rve)) then
c-----------total stress is being controlled
            if(is.le.3) then
c-------------the previous type of control. We uses ihelp2, to be compatible
c             with dempla, since dempla can have a control period with zero
c             dem cyles but with the same type of control
c             ihelp = mod(icontr(istep(rve)-1,rve),10**(7-is)) 
c    x                / 10**(6-is)
              ihelp2 = mod(icontl(rve),10**(7-is)) 
     x                / 10**(6-is)
c             if(ihelp.ne.6 .or. ihelp2.ne.6) then
              if(ihelp2.ne.6) then
c---------------effective stress was previously controlled. Change
c               the previous reference stress to a total stress
                streso(is,rve) = streso(is,rve) - pfluido(rve)
              endif
            endif
          else
c-----------effective stress is being controlled
            if(is.le.3) then
c-------------the previous type of control. We uses ihelp2, to be compatible
c             with dempla, since dempla can have a control period with zero
c             dem cyles but with the same type of control
c             ihelp = mod(icontr(istep(rve)-1,rve),10**(7-is))
c    x                / 10**(6-is)
              ihelp2 = mod(icontl(rve),10**(7-is))
     x                / 10**(6-is)
c             if(ihelp.eq.6 .or. ihelp2.eq.6) then
              if(ihelp2.eq.6) then
c---------------total stress was previously controlled.  Change
c               the previous reference stress to an effective stress
                streso(is,rve) = streso(is,rve) + pfluido(rve)
              endif
            endif
          endif
  100   continue
c
        if(lporo(rve) .and. .not.ldrain(rve)) then
c---------determine new bulk stiffness for use with stress servo-control
          call quez(rve)
        endif
      endif
c
c-----ouput plots for deformation within void circuits
      lplotd(rve) = iplot(istep(rve),rve) .ge. 1
c
c-----force all graphics files to be the long variety
      lcirc1(rve) = .true.
      lcirc2(rve) = .true.
      lcirc3(rve) = .true.
c
      return
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine deldf1(rve)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c-----This subroutin performs the first step in adjusting the deformation 
c     for the next time step.  This subroutin adjusts all of the deformation 
c     components that are explicitly specified by input.  Later, in subroutin 
c     deldf2, we adjust the deformation components that correspond
c     to controlled stress components (the next subroutin, deldf2, uses
c     a servo-control algorithm).
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 igrain,inorm
      integer*2 ihelp,ihelp2,rve
c
      double precision ddefht,ddefm,defi,dw,Qp_old,Qp_new,sum,
     x                 vfactr,vnow,vtargt
c
      dimension ddefm(3,3),defi(3,3,0:mrve),dw(3),Qp_old(4),Qp_new(4)
c
c     CALL OMP_SET_NUM_THREADS(mTHREADS)
c
c-----initialize the incremental Eulerian deformation components, "ddefme()"
      do 10 i = 1,3
c-------initialize the increments of mean-field rotations
        ddefho(i,rve) = 0.
        do 12 j = 1,3
          ddefme(i,j,rve) = 0.
   12   continue
   10 continue
c
c-----effective (intergranular) stresses
      streff(1,rve) = stress(1,1,rve)
      streff(2,rve) = stress(2,2,rve)
      streff(3,rve) = stress(3,3,rve)
c
c-----effective mean stress
      if(ndim1.eq.3) then
        streff(7,rve) = (stress(1,1,rve) + stress(2,2,rve) 
     x                    + stress(3,3,rve)) / 3.d0
      else
        streff(7,rve) = (stress(1,1,rve) + stress(2,2,rve)) / 2.d0
      endif
c
c-----total stresses (intergranular stress and pore fluid pressure)
      strtot(1,rve) = streff(1,rve) - pfluid(rve)
      strtot(2,rve) = streff(2,rve) - pfluid(rve)
      strtot(3,rve) = streff(3,rve) - pfluid(rve)
      strtot(7,rve) = streff(7,rve) - pfluid(rve)
c
c-----the current stress values, stored as a vector "str" rather than
c     as a matrix
c
c-----initialize this stress as the effective stress
      str(1,rve) = streff(1,rve)
      str(2,rve) = streff(2,rve)
      str(3,rve) = streff(3,rve)
      str(7,rve) = streff(7,rve)
c
c-----shear stresses (note, there is no distinction between effective
c     and total stress stress)
      str(4,rve) = (stress(1,2,rve) + stress(2,1,rve)) / 2.d0
      str(5,rve) = (stress(1,3,rve) + stress(3,1,rve)) / 2.d0
      str(6,rve) = (stress(2,3,rve) + stress(3,2,rve)) / 2.d0
c
c-----no distinction between effective and total stress stress
      strtot(4,rve) = str(4,rve)
      strtot(5,rve) = str(5,rve)
      strtot(6,rve) = str(6,rve)
c
      streff(4,rve) = str(4,rve)
      streff(5,rve) = str(5,rve)
      streff(6,rve) = str(6,rve)
c
c-----fluid pressure
      str(8,rve) = pfluid(rve)
c
c-----for use in functio switch
      strtot(8,rve) = pfluid(rve)
c
c-----the deviator stress, which is used with come types of stress control
      if(lqcntr(rve)) then
        if(iqcntr(rve).eq.1) then
          str(1,rve) = str(1,rve) - max(str(2,rve),str(3,rve))
        elseif(iqcntr(rve).eq.2) then
          str(2,rve) = str(2,rve) - max(str(1,rve),str(3,rve))
        elseif(iqcntr(rve).eq.3) then
          str(3,rve) = str(3,rve) - max(str(1,rve),str(2,rve))
        endif
      endif
c
c-----select either total or effective stress as the controlled stress
      do 14 i = 1,nsolve(rve)
        is = isolve(i,rve)
        if((is.le.3 .or. is.eq.7) .and. ltotal(is,rve)) then
c---------the total stress is being controlled
          str(is,rve) = strtot(is,rve)
        endif
  14  continue
c
      if(lnew(rve)) then
        lnew(rve) = .false.
        do 40 i = 1,nsolve(rve)
          is = isolve(i,rve)
c
c---------establish the target stress
          if(istep(rve).gt.1 .and. is.le.6) then
c-----------the previous type of control. We uses ihelp2, to be compatible
c           with dempla, since dempla can have a control period with zero
c           dem cyles but with the same type of control
c           ihelp = mod(icontr(istep(rve)-1,rve),10**(7-is))
c    x              / 10**(6-is)
            ihelp2 = mod(icontl(rve),10**(7-is))
     x              / 10**(6-is)
c           if(ihelp.eq.icont(is,rve) 
c    x         .and. ihelp2.eq.icont(is,rve)) then
            if(ihelp2.eq.icont(is,rve)) then
c-------------the component of stress is being controlled in
c             the same manner as during the previous conrol period.
c             Continue with the same target stress
              s(is,rve) = s(is,rve)
            else
              s(is,rve) = str(is,rve)
            endif
          else
c-----------the component of stress was not controlled or
c           was not controlled in the same manner during the
c           previous control period.  Set the new target stress
            s(is,rve) = str(is,rve)
          endif
c
c         s(is) = str(is)
          if(ip1cnt(is,rve).eq.is) then
            stro(ip2cnt(is,rve),rve) = str(ip2cnt(is,rve),rve)
          endif
  40    continue
      endif
c
c-----the previous type of control
      icontl(rve) = icontr(istep(rve),rve)
      icontpl(rve) = icontp(istep(rve),rve)
      defratl(1,rve) = defrat(1,istep(rve),rve)
      defratl(2,rve) = defrat(2,istep(rve),rve)
      defratl(3,rve) = defrat(3,istep(rve),rve)
      defratl(4,rve) = defrat(4,istep(rve),rve)
      defratl(5,rve) = defrat(5,istep(rve),rve)
      defratl(6,rve) = defrat(6,istep(rve),rve)
      defratl(7,rve) = defrat(7,istep(rve),rve)
      defratl(8,rve) = defrat(8,istep(rve),rve)
c
      sum = 0.
      psi(rve) = 0.
c
c-----the deformation increments ddef(), as computed from the 
c     deformation rates.  These increments will be strored as a vector.
      do 20 i = 1,nknown(rve)
c-------the vector "iknown" stores the indices of known deformation increments.
c       There are a total of "nknown" known deformation increments.
        ik = iknown(i,rve)
        if(lvctrl(rve) .and. ivctrl(ik,rve).eq.1) then
c---------we are controlling this deformation so that the assembly volume
c         advances at a given rate
          ddef(ik,rve) = 0.
          dvctrl(rve) = defrat(ik,istep(rve),rve)*dt(rve)
        else
c---------we use the input deformation rate for this component
          ddef(ik,rve) = defrat(ik,istep(rve),rve)*dt(rve)
        endif
   20 continue
c
c-----"nsolve" is the number of unsolved deformation components, which
c     are the stress-controlled components
      if(nsolve(rve).gt.0) then
        pn(rve) = pn(rve) + 1.d0
c
        do 50 i = 1,nsolve(rve)
          is = isolve(i,rve)
c
c---------this sum will be used to monitor conformance of the targeted
c         and actual stresses
          sum = sum + abs(str(is,rve))
c
c---------"psi" is a performance paramter that is used for measuring
c         the difference between the targeted stress ("s") and the actual
c         stress)
          psi(rve) = psi(rve) + abs(s(is,rve) - str(is,rve))
c
          if(pn(rve).ge.0.01d0) then
            dsreal(i,1,rve) = str(is,rve) - streso(is,rve)
     x                         - qdef(is,rve)
          endif
   50   continue
c
c-------compute "psi", a measure of how successfully the controlled stresses
c       are being maintained at their target values.  A small value of psi
c       is desired
        if(stravg(rve).ne.0.) then
c---------quotient of (the sum of deviations of components from their
c         target stresses) / (the sum of all stresses)
          psi(rve) = abs(psi(rve)/stravg(rve))
        else
          psi(rve) = 0.
        endif
c
        if(liso2(rve)) then
          stargt = stranc(2,rve)
     x               - (1.d0 + srint(rve)) / (2.d0 - srint(rve)) * 
     x                  (str(ianch(1,rve),rve) - stranc(1,rve))
          s(ianch(2,rve),rve) = str(ianch(2,rve),rve)
          dstres(ianch(2,rve),rve) = stargt - str(ianch(2,rve),rve)
c
          stargt = stranc(3,rve)
     x               + (2.d0*srint(rve) - 1.d0) / (2.d0 -srint(rve))*
     x                  (str(ianch(1,rve),rve) - stranc(1,rve))
          s(ianch(3,rve),rve) = str(ianch(3,rve),rve)
          dstres(ianch(3,rve),rve) = stargt - str(ianch(3,rve),rve)
c
          do 23 i = 1,nsolve(rve)
            is = isolve(i,rve)
            if(is.gt.3) then
              dstres(is,rve) = defrat(is,istep(rve),rve)*dtreal(rve)
            endif
   23     continue
c
          qdef(is,rve) = 0.
          do 25 j = 1,nknown(rve)
            ik = iknown(j,rve)
            qdef(is,rve) = qdef(is,rve) + q(is,ik,rve)*ddef(ik,rve)
            if(lporo(rve) .and. .not.ldrain(rve) 
     x         .and. ltotal(is,rve)) then
              qdef(is,rve) = qdef(is,rve) 
     x                        + q_alt(is,ik,rve)*ddef(ik,rve)
            else
              qdef(is,rve) = qdef(is,rve) 
     x                        + q(is,ik,rve)*ddef(ik,rve)
            endif
   25     continue
        else
          do 22 i = 1,nsolve(rve)
            is = isolve(i,rve)
            if(lanch(rve) .and. is.eq.ianch(3,rve)) then
c-------------the target value of the controlled stress for this time increment
              stargt = stranc(3,rve) 
     x                 + srint(rve)
     x                   *((str(ianch(1,rve),rve) - stranc(1,rve))
     x                     - (str(ianch(2,rve),rve) - stranc(2,rve)))
              s(is,rve) = str(is,rve)
c
              dstres(is,rve) = stargt - str(ianch(3,rve),rve)
            elseif(ip1cnt(is,rve).eq.is) then
              dstres(is,rve) = defrat(is,istep(rve),rve)
     x                     * (str(ip2cnt(is,rve),rve)
     x                        - stro(ip2cnt(is,rve),rve))
            else
c-------------the change in the controlled stress for this time increment
              dstres(is,rve) = defrat(is,istep(rve),rve)*dtreal(rve)
            endif
c
            qdef(is,rve) = 0.
            do 24 j = 1,nknown(rve)
              ik = iknown(j,rve)
              if(lporo(rve) .and. .not.ldrain(rve) 
     x           .and. ltotal(is,rve)) then
                qdef(is,rve) = qdef(is,rve) 
     x                          + q_alt(is,ik,rve)*ddef(ik,rve)
              else
                qdef(is,rve) = qdef(is,rve) 
     x                          + q(is,ik,rve)*ddef(ik,rve)
              endif
   24       continue
   22     continue
c
        endif
      endif
c
      if(lporo(rve) .and. ldrain(rve) .and. .not.liso2(rve)) then
c-------pore fluid pressure is being controlled, but stress control
c       is being applied to effective stresses.  This is a drained
c       condition.
c
c-------pore fluid increment
        dpfluid(rve) = defrat(8,istep(rve),rve)*dtreal(rve)
      endif
c
      do 60 i = 1,3
        do 62 j = 1,3
c---------save the previous components of the deformation gradient tensor
          defold(i,j,rve) = def(i,j,rve)
c
c---------the matrix of (Lagrangian) deformation increments
          ddefm(i,j) = 0.
c
c---------save the previous cell dimensions
          xcello(i,j,rve) = xcell(i,j,rve)
   62   continue
   60 continue
c
      if(lporo(rve)) then
c-------when pore fluid pressure is being considered...
        defwold(rve) = defw(rve)
      else
        defwold(rve) = 0.
      endif
c
      do 64 i = 1,nsolve(rve)
        ddef(isolve(i,rve),rve) = 0.
   64 continue
c
c-----change in incremental pore fluid inflow
      ddefwm(rve) = ddef(8,rve)
c
      if(.not.liso2(rve)) then
c-------incremental changes in the deformation gradient.  Move values stored
c       in the vector "ddef" into the tensor "ddefm"
        ddefm(1,1) = ddef(1,rve)
        ddefm(2,2) = ddef(2,rve)
        ddefm(3,3) = ddef(3,rve)
        ddefm(1,2) = ddef(4,rve)
        ddefm(1,3) = ddef(5,rve)
        ddefm(2,3) = ddef(6,rve)
        ddefm(2,1) = 0.
        ddefm(3,1) = 0.
        ddefm(3,2) = 0.
c 
c-------the rotation increment of the mean-field
        ddefh(3,rve) = (ddefm(2,1) - ddefm(1,2)) / spin
        ddefht = abs(ddefh(3,rve))
        if(ndim1.eq.3) then
          ddefh(2,rve) = (ddefm(1,3) - ddefm(3,1)) / spin
          ddefh(1,rve) = (ddefm(3,2) - ddefm(2,3)) / spin
          ddefht = ddefht + abs(ddefh(1,rve)) + abs(ddefh(2,rve))
        endif
c 
c-------update the deformation gradient
        do 70 i = 1,3
          do 72 j = 1,3
            def(i,j,rve) = defold(i,j,rve) + ddefm(i,j)
   72     continue
   70   continue
c
        if(lporo(rve) .and. .not.ldrain(rve)) then
c---------undrained conditions, in which we are controlling the pore fluid 
c         intake (we are not controlling the pore fluid pressure).
c         Advance the pore fluid deformation
          defw(rve) = defwold(rve) + ddefwm(rve)
        endif
c
c-------when the assembly volume is being controlled...
        if(lvctrl(rve)) then
c---------the target volume relative to the previous volume
          vtargt = (1.d0 + dvctrl(rve))
     x             *defold(1,1,rve)*defold(2,2,rve)*defold(3,3,rve)
c---------number of deformation components that are being adjusted to
c         control the volume
          if(ndim1.eq.3) then
            nvctrl = ivctrl(1,rve) + ivctrl(2,rve) + ivctrl(3,rve)
          else
            nvctrl = ivctrl(1,rve) + ivctrl(2,rve)
          endif
c---------the volume without the adjustment
          vnow = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c---------adjustment factor for each component that is being adjusted to
c         control the volume
          vfactr = (vtargt / vnow)**(1.d0/nvctrl)
c
          do 200 i = 1,ndim1
            if(ivctrl(i,rve).eq.1) then
c-------------this deformation component is being adjusted to control
c             the assembly volume
c-------------adjust the deformation component
              def(i,i,rve) = def(i,i,rve)*vfactr
              ddefm(i,i) = def(i,i,rve) - defold(i,i,rve)
              ddef(i,rve) = ddefm(i,i)
            endif
  200     continue
        endif
c 
c-------find the inverse of the deformation gradient
        n = 3
        call definv(defold,defi,n,rve,mrve)
c 
c-------find the Eulerian deformation rate.  "ddefme" is equivalent to the
c       product of the velocity gradient and dt:
        do 80 i = 1,3
          do 82 j = 1,3
            ddefme(i,j,rve) = 0.
            do 84 k = 1,3
              ddefme(i,j,rve) = ddefme(i,j,rve) 
     x                           + ddefm(i,k)*defi(k,j,rve)
   84       continue
c 
c-----------the incremental change in the cell dimensions (we use the
c           the Eulerian deformation rate times the previous cell dimensions.
            dxcell(i,j,rve) = 0.
            do 86 k = 1,3
              dxcell(i,j,rve) = dxcell(i,j,rve)
     x                           + ddefme(i,k,rve)*xcello(k,j,rve)
   86       continue
c 
c-----------update the matrix of cell dimensions
            xcell(i,j,rve) = xcello(i,j,rve) + dxcell(i,j,rve)
   82     continue
   80   continue
c 
c-------find the inverse of the cell dimension matrix
        n = 3
        call definv(xcell,xcelli,n,rve,mrve)
c 
c-------for all of the (np) particles, change their positions due to
c       the change in the dimensions of the periodic cell.
        do 100 igrain = 1,np(rve)
          do 102 j = 1,ndim1
            dxdef = 0.
            do 104  k = 1,ndim1
              dxdef = dxdef + ddefme(j,k,rve)*xp(k,igrain,rve)
  104       continue
c
c-----------the change in the particle's position since the last update
c           of the contact conditions.
            dx(j,igrain,rve) = dx(j,igrain,rve) + dxdef
c
c-----------the new particle location
            xp(j,igrain,rve) = xp(j,igrain,rve) + dxdef
  102     continue
c
c---------rotations due to any unsymmetric deformation gradient
          do 103 j = ndim2,3
c-----------the change in the particle's orientation since the last update
c           of the contact conditions.
            dth(j,igrain,rve) = dth(j,igrain,rve) + ddefh(j,rve)
c
c-----------the new orientation angle
            theta(j,igrain,rve) = theta(j,igrain,rve) + ddefh(j,rve)
            ddth(j,igrain,rve) = ddefh(j,rve)
  103     continue
  100   continue
c
c-------With composite "bumpy" particles...
        if(lbumpy(rve) .and. 
     x     (    ddefh(1,rve).ne.0.
     x      .or.ddefh(2,rve).ne.0. .or.ddefh(3,rve).ne.0.)) then
c---------having computed the incremental rotation of the particle, we
c         must apply this increment to the quaternions that give the
c         particles' orientations
c
c---------normalize the revised quaternion by dividing by the square root
c         of its norm
          inorm = 2
c
c---------the incremental rotation in the global frame (for either 
c         algori=1 or algori=2)
          dw(1) = ddefh(1,rve)
          dw(2) = ddefh(2,rve)
          dw(3) = ddefh(3,rve)
c
          do 121 igrain=1,np(rve)
c-----------the current orientation quaternion
            Qp_old(1) = Qp(1,igrain,rve)
            Qp_old(2) = Qp(2,igrain,rve)
            Qp_old(3) = Qp(3,igrain,rve)
            Qp_old(4) = Qp(4,igrain,rve)
c
c-----------apply the incremental rotation to the orientation quaternion
            call QIncRotate(Qp_old, Qp_new, dw, inorm)
c
c-----------the revised orientation quaternion
            Qp(1,igrain,rve) = Qp_new(1)
            Qp(2,igrain,rve) = Qp_new(2)
            Qp(3,igrain,rve) = Qp_new(3)
            Qp(4,igrain,rve) = Qp_new(4)
  121     continue
        endif
c
        ltheta(rve) = .false.
c
c-------do we need to compute the sines and cosines of the particle
c       orientation angles theta()?  ltheta is passed to subroutin locate
        ltheta(rve) = ddefht.ne.0. .or. ltheta(rve)
c
c-------compute the locations of the component pieces of ovals and ovoids.
c       Also recompute the sines and cosines of the particle orientation
c       angles theta()
        call locate(rve)
      endif
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine deldf2(rve)
c
c-----The second step in adjusting the deformation for the next time
c     step (see subroutin deldf1).  In this step the servo-controlled 
c     deformation components will be adjusted to maintain the stresses
c     that have been specified for the control step in the input file
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 igrain,inorm,int4,nq
      integer*2 irve,imrve,itask,kiso,rve
c
      double precision C_w,Dcurnt,ddefht,dw,dxdef,epsv,J_f,J_w,
     x                 Qp_old,Qp_new,xddef
      double precision a(8,8),ai(8,8),
     x                 b(8,8),bi(8,8),
     x                 ddefhd(3),
     x                 ddefm(3,3),ddefmd(3,3),ddefmo(3,3),
     x                 defi(3,3,0:mrve),dm_stress,
     x                 dsfalm(6+mdiff),dsprim(6),
     x                 ufactr(mdiff)
      dimension dw(3),Qp_old(4),Qp_new(4)
c
c     CALL OMP_SET_NUM_THREADS(mTHREADS)
c
      do 10 i = 1,8
        do 12 j = 1,8
          a(i,j) = 0.
          ai(i,j) = 0.
          b(i,j) = 0.
          bi(i,j) = 0.
   12   continue
   10 continue
c
      ndiff = nfacts(rve) - nsolve(rve)
c
      if(ndiff.gt.mdiff) then
        write(ScrUnit(rve),*) 'ndiff greater than mdiff in deldf2'
        write(ErrUnit(rve),*) 'ndiff greater than mdiff in deldf2'
        stop
      elseif(mdiff .gt. 1) then
        write(ScrUnit(rve),*)
     x    'nfacts creates a problem with dimension 8 of arrays',
     x    ' a,ai,b,bi in deldf2 and matinv'
      endif
c
c-----effective (intergranular) stresses
      streff(1,rve) = stress(1,1,rve)
      streff(2,rve) = stress(2,2,rve)
      streff(3,rve) = stress(3,3,rve)
c
c-----effective mean stress
      if(ndim1.eq.3) then
        streff(7,rve) = (stress(1,1,rve) + stress(2,2,rve) 
     x                    + stress(3,3,rve)) / 3.d0
      else
        streff(7,rve) = (stress(1,1,rve) + stress(2,2,rve)) / 2.d0
      endif
c
c-----total stresses (intergranular stress and pore fluid pressure)
      strtot(1,rve) = streff(1,rve) - pfluid(rve)
      strtot(2,rve) = streff(2,rve) - pfluid(rve)
      strtot(3,rve) = streff(3,rve) - pfluid(rve)
      strtot(7,rve) = streff(7,rve) - pfluid(rve)
c
c-----the current stress values, stored as a vector "str" rather than
c     as a matrix
      str(1,rve) = streff(1,rve)
      str(2,rve) = streff(2,rve)
      str(3,rve) = streff(3,rve)
      str(7,rve) = streff(7,rve)
c
c-----shear stresses (note, there is no distinction between effective
c     and total stress stress)
      str(4,rve) = (stress(1,2,rve) + stress(2,1,rve)) / 2.d0
      str(5,rve) = (stress(1,3,rve) + stress(3,1,rve)) / 2.d0
      str(6,rve) = (stress(2,3,rve) + stress(3,2,rve)) / 2.d0
c
      if(lporo(rve)) then
c-------fluid pressure
        str(8,rve) = pfluid(rve)
      else
        str(8,rve) = 0.
      endif
c
c-----the deviator stress
      if(lqcntr(rve)) then
        if(iqcntr(rve).eq.1) then
          str(1,rve) = str(1,rve) - max(str(2,rve),str(3,rve))
        elseif(iqcntr(rve).eq.2) then
          str(2,rve) = str(2,rve) - max(str(1,rve),str(3,rve))
        elseif(iqcntr(rve).eq.3) then
          str(3,rve) = str(3,rve) - max(str(1,rve),str(2,rve))
        endif
      endif
c
c-----select either total or effective stress as the controlled stress
      do 14 i = 1,nsolve(rve)
        is = isolve(i,rve)
        if((is.le.3 .or. is.eq.7) .and. ltotal(is,rve)) then
c---------the total stress is being controlled
          str(is,rve) = strtot(is,rve)
        endif
  14  continue
c
c-----save the current effective stress so that the stress-work can be
c     calculated
      do 40 i = 1,3
        do 42 j = 1,3
          strold(i,j,rve) = stress(i,j,rve)
   42   continue
   40 continue
c
      if(lporo(rve)) then
c-------will be used for computing the volumetric work done by the
c       pore fluid pressure
        strwold(rve) = pfluid(rve)
      endif
c
c-----store the current fluid pressure, in case it is needed with the next
c     control step
      pfluido(rve) = pfluid(rve)
c
      if(nsolve(rve).gt.0) then
        nq = nint(pn(rve))
c
        do 50 i = 1,nsolve(rve)
          is = isolve(i,rve)
c
c---------the target stress
          s(is,rve) = s(is,rve) + dstres(is,rve)
c
c---------the target stress increment
          ds(is,rve) = s(is,rve) - str(is,rve)
c
c---------will be used for computing actual change in stress
          streso(is,rve) = str(is,rve)
c
          if(ip1cnt(is,rve).eq.is) then
            stro(ip2cnt(is,rve),rve) = str(ip2cnt(is,rve),rve)
          endif
   50   continue
c
        if(pn(rve).ge..01) then
          xi(1,1,rve) = min(xpnts(rve),pn(rve))
          do 60 i = 1,nfacts(rve)
            xi(1,i+1,rve) = xi(1,i+1,rve)
     x                       + dsfals(i,1,rve) 
     x                       - dsfals(i,np1(rve),rve)
            do 70 j = i,nfacts(rve)
              xi(i+1,j+1,rve) = xi(i+1,j+1,rve) 
     x               + dsfals(i,1,rve)*dsfals(j,1,rve)
     x               - dsfals(i,np1(rve),rve)*dsfals(j,np1(rve),rve)
   70       continue
   60     continue
c
          do 62 i = 1,nsolve(rve)
            yi(1,i,rve) = yi(1,i,rve) 
     x                     + dsreal(i,1,rve) - dsreal(i,np1(rve),rve)
            do 72 j = 1,nfacts(rve)
              yi(j+1,i,rve) = yi(j+1,i,rve) 
     x            + dsfals(j,1,rve)*dsreal(i,1,rve)
     x            - dsfals(j,np1(rve),rve)*dsreal(i,np1(rve),rve)
   72       continue
   62     continue
c
          do 90 i = 2,nfacts(rve)+1
            do 100 j = 1,i-1
              xi(i,j,rve) = xi(j,i,rve)
  100       continue
   90     continue
c
        endif
c
        do 105 i = 1,nsolve(rve)
          do 106 j = 1,nfacts(rve)+1
            a(i,j) = 0.
  106     continue
  105   continue
c
        if(nq.gt.int4(nfacts(rve))) then
c
          ns1 = nfacts(rve) + 1
          call matinv(xi,ai,ns1,ier,rve,mrve)
c
          do 110 i = 1,nsolve(rve)
            if(ier.ne.1) then
              do 120 j = 1,nfacts(rve)+1
                a(i,j) = 0.
                do 125 k = 1,nfacts(rve)+1
                  a(i,j) = a(i,j) + ai(j,k)*yi(k,i,rve)
  125           continue
  120         continue
            elseif(dsfals(i,1,rve).ne.0) then
              a(i,i+1) = dsreal(i,1,rve)/dsfals(i,1,rve)
            else
              a(i,i+1) = 1.d0
            endif
  110     continue
c
        elseif(nq.eq.0) then
          do 140 i = 1,nsolve(rve)
            a(i,i+1) = 1.d0
  140     continue
c
        elseif(nq.eq.1) then
          do 160 i = 1,nsolve(rve)
            if(dsreal(i,1,rve)*dsfals(i,1,rve).ne.0.) then
              a(i,i+1) = dsreal(i,1,rve)/dsfals(i,1,rve)
            else
              a(i,i+1) = 1.d0
            endif
  160     continue
c
        elseif(nq.gt.1) then
          do 170 i = 1,nsolve(rve)
            b(1,1) = pn(rve)
            b(1,2) = xi(1,i+1,rve)
            b(2,1) = b(1,2)
            b(2,2) = xi(i+1,i+1,rve)
c
            ns1 = 2
            irve = 0
            imrve = 0
            call matinv(b,ai,ns1,ier,irve,imrve)
c
            if(ier.ne.1) then
              a(i,1) = ai(1,1)*yi(1,i,rve) + ai(1,2)*yi(i+1,i,rve)
              a(i,i+1) = ai(2,1)*yi(1,i,rve) + ai(2,2)*yi(i+1,i,rve)
            elseif(dsfals(i,1,rve)*dsreal(i,1,rve).ne.0) then
              a(i,i+1) = dsreal(i,1,rve)/dsfals(i,1,rve)
            else
              a(i,i+1) = 1.d0
            endif
  170     continue
        endif
c
        do 224 j = 1,nsolve(rve)
          do 226 k = 1,nsolve(rve)
            b(j,k) = a(j,k+1)
  226     continue
  224   continue
c
        irve = 0
        imrve = 0
        call matinv(b,bi,nsolve(rve),ier,irve,imrve)
c
        do 220 j = 1,nsolve(rve)
          js = isolve(j,rve)
          dsprim(j) = ds(js,rve) - qdef(js,rve) - a(j,1)
  220   continue
c
        do 202 i = 1,nfacts(rve)
          dsfalm(i) = 0.
          do 204 j = mstack,2,-1
            dsfals(i,j,rve) = dsfals(i,j-1,rve)
            if(i.le.nsolve(rve)) then
              dsfalm(i) = max(dsfalm(i),abs(dsfals(i,j,rve)))
            endif
  204     continue
  202   continue
c
        do 209 i = 1,ndiff
          dsfals(nsolve(rve)+i,1,rve) = ufactr(i)
  209   continue
c
        do 206 i = 1,nsolve(rve)
          do 208 j = mstack,2,-1
            dsreal(i,j,rve) = dsreal(i,j-1,rve)
  208     continue
  206   continue
c
        do 200 i = 1,nsolve(rve)
          dsfals(i,1,rve) = 0.
          do 228 j = 1,nsolve(rve)
            dsfals(i,1,rve) = dsfals(i,1,rve) + bi(i,j)*dsprim(j)
  228     continue
c
          if(abs(dsreal(i,1,rve))
     x       .lt. 0.2d0*abs(ds(isolve(i,rve),rve))) then
            countr(i,rve) = countr(i,rve) + 1
          else
            countr(i,rve) = 0
          endif
c
          if(countr(i,rve).eq.5) then
            dsfals(i,1,rve) = dsreal(i,1,rve)
            countr(i,rve) = 0
          elseif(abs(dsfals(i,1,rve))
     x           .gt.dsfm*dsfalm(i).and.nq.gt.1) then
            dsfals(i,1,rve) = sign(dsfalm(i),dsfals(i,1,rve))*dsfm
          endif
  200   continue
c
        do 230 i = 1,nsolve(rve)
          xddef = 0.
          do 240 j = 1,nsolve(rve)
            xddef = xddef + qi(i,j,rve)*dsfals(j,1,rve)
  240     continue
          is = isolve(i,rve)
          if(is.eq.7) then
c-----------when isolve==7, then the deformations are servo-controlled in 
c           a manner that produces constant mean stress
            if(niso(rve).gt.0) then
c-------------if two or three deformations are servo-controlled to produce
c             a constant mean stress (for example icontr = 220000 or 202000,
c             then their two (or three) increments should all be the same.
c             But make their Eulerian increments equal
              do 241 kiso = 1,niso(rve)
                ddef(iiso(kiso,rve),rve) 
     x            = xddef*def(iiso(kiso,rve),iiso(kiso,rve),rve)
  241         continue
            endif
          else
            ddef(is,rve) = xddef
          endif
  230   continue
      endif
c
c-----incremental changes in the deformation gradient.  Move values stored
c     in the vector "ddef" into the tensor "ddefm"
      ddefm(1,1) = ddef(1,rve)
      ddefm(2,2) = ddef(2,rve)
      ddefm(3,3) = ddef(3,rve)
      ddefm(1,2) = ddef(4,rve)
      ddefm(1,3) = ddef(5,rve)
      ddefm(2,3) = ddef(6,rve)
      ddefm(2,1) = 0.
      ddefm(3,1) = 0.
      ddefm(3,2) = 0.
c
      if(lporo(rve)) then
        ddefwm(rve) = ddef(8,rve)
      endif
c
      ddefho(1,rve) = ddefh(1,rve)
      ddefho(2,rve) = ddefh(2,rve)
      ddefho(3,rve) = ddefh(3,rve)
c
c-----the rotation increment of the mean-field
      ddefh(3,rve) = (ddefm(2,1) - ddefm(1,2)) / spin
      ddefh(2,rve) = (ddefm(1,3) - ddefm(3,1)) / spin
      ddefh(1,rve) = (ddefm(3,2) - ddefm(2,3)) / spin
c
      do 250 i = 1,3
        ddefhd(i) = ddefh(i,rve) - ddefho(i,rve)
        do 260 j = i,3
          def(i,j,rve) = defold(i,j,rve) + ddefm(i,j)
  260   continue
  250 continue
c
      ddefht = abs(ddefhd(3))
      if(ndim1.eq.3) then
        ddefht = ddefht + abs(ddefhd(1)) + abs(ddefhd(2))
      endif
c
c-----when the assembly volume is being controlled...
      if(lvctrl(rve)) then
c-------the target volume relative to the previous volume
        vtargt = (1.d0 + dvctrl(rve))
     x           *defold(1,1,rve)*defold(2,2,rve)*defold(3,3,rve)
c-------number of deformation components that are being adjusted to
c       control the volume
        if(ndim1.eq.3) then
          nvctrl = ivctrl(1,rve) + ivctrl(2,rve) + ivctrl(3,rve)
        else
          nvctrl = ivctrl(1,rve) + ivctrl(2,rve)
        endif
c-------the volume without the adjustment
        vnow = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c-------adjustment factor for each component that is being adjusted to
c       control the volume
        vfactr = (vtargt / vnow)**(1.d0/nvctrl)

        do 201 i = 1,ndim1
          if(ivctrl(i,rve).eq.1) then
c-----------this deformation component is being adjusted to control
c             the assembly volume
c---------adjust the deformation component
            def(i,i,rve) = def(i,i,rve)*vfactr
            ddefm(i,i) = def(i,i,rve) - defold(i,i,rve)
            ddef(i,rve) = ddefm(i,i)
          endif
  201   continue
      endif
c
      n = 3
      call definv(defold,defi,n,rve,mrve)
c
      do 270 i = 1,3
        do 272 j = 1,3
          ddefmo(i,j) = ddefme(i,j,rve)
          ddefme(i,j,rve) = 0.
          do 274 k = 1,3
            ddefme(i,j,rve) = ddefme(i,j,rve) 
     x                         + ddefm(i,k)*defi(k,j,rve)
  274     continue
c
          dxcell(i,j,rve) = 0.
          do 275 k = 1,3
            dxcell(i,j,rve) = dxcell(i,j,rve)
     x                         + ddefme(i,k,rve)*xcello(k,j,rve)
  275     continue
          xcell(i,j,rve) = xcello(i,j,rve) + dxcell(i,j,rve)
          ddefmd(i,j) = ddefme(i,j,rve) - ddefmo(i,j)
  272   continue
  270 continue
c
      if(lporo(rve) .and. ldrain(rve)) then
c-------pore fluid pressure is being controlled, and any stresses that
c       are being controlled are effective stresses.  In this case,
c       pore fluid is free to enter or leave the assembly (drained
c       conditions)
c
c-------Jacobian of the bulk deformation gradient
        J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c-------the new pore fluid pressure
        pfluid(rve) = pfluid(rve) + dpfluid(rve)
c
c       the net inflow of pore water fluid.  "defw" is the difference
c       between the Jacobian of the bulk (skeleton) deformation gradient
c       and the Jacobian of the deformation gradient of the pore fluid.
c       When multiplied by the original porosity, "defw" is the volumetric
c       inflow of fluid per unit of original volume.  That is, it is a
c       "discharge" inflow (instead of a "seepage" inflow), referenced
c       to the original volume.  For undrained conditions, "defw" is zero.
        if(iporo(rve).eq.1) then
          defw(rve) = 
     x    (1.d0 / poros0(rve))
     x    * (  ((1.d0 - poros0(rve))/K_s(rve) 
     x          + poros0(rve)/K_f(rve)) * (pfluid(rve) - p_o(rve))
     x       + (J_f - 1.d0) 
     x       - (1.d0 - poros0(rve))
     x          *( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x           -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve))) 
     x            / (3.d0*K_s(rve)))
c
        elseif(iporo(rve).eq.3) then
c---------a model of pore fluid compressibility that includes dissolution
c         of pore gas and includes surface tension of gas bubbles.
c         Besides the parameters listed above, these other parameters are
c         involved in computing the water pressure.  Note that "pfluid"
c         is the liquid-phase pore pressure, measured relative to 
c         atmospheric pressure
c
c         * gamm is the bubble surface tension
c         * p_atm is the reference atmospheric pressure
c         * Hcc is the dimensionless Henrys coefficient
c         * S_o is the initial saturation of the pore fluid with liquid
c         * D_o is the initial bubble size
c         * N_o is the initial number/density of bubbles
c
c---------compressibility of pore liquid
          C_w = 1.d0 / K_f(rve)
c
c---------change in mean effective stress from the original (reference)
c         condition
          dm_stress = 
     x      ( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x       -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve)))
     x      /3.d0
c
c---------whether to compute (1) water pressure with a given strain, or
c         (2) fluid strain with a given water pressure
          itask = 2
c
c---------small number that is used to find the threshold
c         volumetric strain (or water pressure) of the pore
          epsv = 1d-10
c
          call bubble(gamm(rve), p_atm(rve), p_o(rve), Hcc(rve),
     x                C_w, S_o(rve), D_o(rve), N_o(rve),
     x                J_f, pfluid(rve), p_vap(rve), p_wcav(rve),
     x                Dcurnt, S_now(rve),
     x                K_s(rve), poros0(rve), defw(rve), dm_stress,
     x                Dlast(rve), itask)
c
c---------save current bubble diameter, to expedite the next time step
          Dlast(rve) = Dcurnt
c
        elseif(iporo(rve).eq.4) then
c---------for a dry granular material.  Poroelastic effects account for the
c         changes in air pressure within the material
c
c-----------Jacobian of the fluid deformation gradient
            J_w = (p_o(rve) + p_atm(rve)) / (pfluid(rve) + p_atm(rve))
     x            * (1.d0
     x               - (1.d0 - poros0(rve))
     x                 * ( (  (  stress(1,1,rve) + stress(2,2,rve)
     x                         + stress(3,3,rve))
     x                      - (stres0(1,1,rve) + stres0(2,2,rve)
     x                         + stres0(3,3,rve)))
     x                     / (3.d0*K_s(rve))
     x                      - (pfluid(rve) - p_o(rve)) / K_s(rve)
     x                   )
     x              )
c
c-----------net influx of air
            defw(rve) = J_f - J_w
        endif
      endif
c
c-----find the inverse of the matrix xcell
      n = 3
      call definv(xcell,xcelli,n,rve,mrve)
c
      if(algori.eq.2) then
c-------for all of the (np) particles
        do 280 igrain = 1,np(rve)
          do 282 j = 1,ndim1
            dxdef = 0.
            do 284  k = 1,ndim1
              dxdef = dxdef + ddefmd(j,k)*xp(k,igrain,rve)
  284       continue
c
            if(algori.eq.2) then
              dx(j,igrain,rve) = dx(j,igrain,rve) + dxdef
              xp(j,igrain,rve) = xp(j,igrain,rve) + dxdef
            endif
  282     continue
c
          do 285 j = ndim2,3
            dth(j,igrain,rve) = dth(j,igrain,rve) + ddefhd(j)
            theta(j,igrain,rve) = theta(j,igrain,rve) + ddefhd(j)
            ddth(j,igrain,rve) = ddefhd(j)
  285     continue
  280   continue
c
      elseif(algori.eq.1) then
c-------for all of the (np) particles
        do 281 igrain = 1,np(rve)
          do 283 j = 1,ndim1
            dxdef = 0.
            do 289  k = 1,ndim1
              dxdef = dxdef + ddefmd(j,k)*xp(k,igrain,rve)
  289       continue
            dx(j,igrain,rve) = dx(j,igrain,rve) + dxdef
            xp(j,igrain,rve) = xp(j,igrain,rve) + dxdef
  283     continue
c
          do 286 j = ndim2,3
            dth(j,igrain,rve) = dth(j,igrain,rve) + ddefhd(j)
            theta(j,igrain,rve) = theta(j,igrain,rve) + ddefhd(j)
            ddth(j,igrain,rve) = ddefhd(j)
  286     continue
  281   continue
      endif
c
c-----With composite "bumpy" particles...
      if(lbumpy(rve) .and.
     x   (ddefhd(1).ne.0. .or.ddefhd(2).ne.0. .or.ddefhd(3).ne.0.)) then
c-------having computed the incremental rotation of the particle, we
c       must apply this increment to the quaternions that give the
c       particles' orientations
c
c-------normalize the revised quaternion by dividing by the square root
c       of its norm
        inorm = 2
c
c-------the incremental rotation in the global frame (for either 
c       algori=1 or algori=2)
        dw(1) = ddefhd(1)
        dw(2) = ddefhd(2)
        dw(3) = ddefhd(3)
c
        do 121 igrain=1,np(rve)
c---------the current orientation quaternion
          Qp_old(1) = Qp(1,igrain,rve)
          Qp_old(2) = Qp(2,igrain,rve)
          Qp_old(3) = Qp(3,igrain,rve)
          Qp_old(4) = Qp(4,igrain,rve)
c
c---------apply the incremental rotation to the orientation quaternion
          call QIncRotate(Qp_old, Qp_new, dw, inorm)
c
c---------the revised orientation quaternion
          Qp(1,igrain,rve) = Qp_new(1)
          Qp(2,igrain,rve) = Qp_new(2)
          Qp(3,igrain,rve) = Qp_new(3)
          Qp(4,igrain,rve) = Qp_new(4)
  121   continue
      endif
c
c-----do we need to compute the sines and cosines of the particle
c     orientation angles theta()?  ltheta is passed to subroutin locate
      ltheta(rve) = ddefht.ne.0.
c
c-----compute the locations of the component pieces ovals and ovoids.
c     Also recompute the sines and cosines of the particle orientation
c     angles theta()
      call locate(rve)
c
      defv(1,rve) = def(1,1,rve)
      defv(2,rve) = def(2,2,rve)
      defv(3,rve) = def(3,3,rve)
      defv(4,rve) = def(1,2,rve)
      defv(5,rve) = def(1,3,rve)
      defv(6,rve) = def(2,3,rve)
      defv(8,rve) = defw(rve)
c
c-----void ratio
      voidn(rve) = (vcell(rve) - vs(rve))/vs(rve)
c
c-----solids fraction
      solidr(rve) = 1.d0/(1.d0 + voidn(rve))
c
      if(igoalb(rve).eq.4) then
        if(igoala(rve).eq.1) then
          str(1,rve) = stress(1,1,rve)
     x                  - max(stress(2,2,rve),stress(3,3,rve))
        elseif(igoala(rve).eq.2) then
          str(2,rve) = stress(2,2,rve)
     x                  - max(stress(1,1,rve),stress(3,3,rve))
        elseif(igoala(rve).eq.3) then
          str(3,rve) = stress(3,3,rve)
     x                  - max(stress(1,1,rve),stress(2,2,rve))
        endif
      endif
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine integ1(rve)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 jp,rve
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 ibaltm,igrain,igranm,inorm
c
      double precision a,a12len,ddx,dw,
     x                 f3damp,fbalsq_c,fdamp,fdampa_c,fjmax,fjtmax,
     x                 fmag,fth3dp,fthmag,fths,
     x                 knrgy1,knrgy2,
     x                 mntdif,omega1,psi1,Qp_old,Qp_new,
     x                 rfact1_c,rfact2_c,thblsq_c,tfact1_c,tfact2_c,
     x                 vavg,vhmag,vho,vhthsa,vhtho,vhthsm,vhthso,
     x                 viscb,vsq,vthmag,vthsq,zeta1
      logical lstabl,lv
c
      dimension a(3,3),ddx(3),dw(3),fmag(mp),fthmag(mp),fths(3),
     x          Qp_old(4),Qp_new(4),
     x          vhmag(mp),vhthsa(3),vhthso(3),vthmag(mp)
      dimension jp(3)
c
c     CALL OMP_SET_NUM_THREADS(mTHREADS)
c
c-----this subroutin integrates the velocities and accelerations.  It 
c     uses one of two integration algorithms, as specified by the input
c     value of algorithm "algori" = 1 or 2
c
c-----variables to characterize the average imbalance of particle forces
      fbalsq(rve) = 0.
      thblsq(rve) = 0.
c
c-----viscous work due to Potyondy/Cundall damping
      f3damp = 0.
      fth3dp = 0.
c
c-----initialize variables for computing the kinetic energy
      vsq = 0.
      vthsq = 0.
c
c-----the total (body, mass) damping forces on all particles within 
c     the assembly
      fdampa(rve) = 0.
c
c-----copies to facilitate parallelization
      fbalsq_c = fbalsq(rve)
      thblsq_c = thblsq(rve)
      fdampa_c = fdampa(rve)
c
c-----for debugging purposes
      fjmax = 0.
      igranm = 0
      fjtmax = 0.
      ibaltm = 0
      lstabl = .true.
c
c----?????????
      jp(1) = 2
      jp(2) = 1
      jp(3) = 1
c
      if(idamp(rve).eq.2) then
        do 100 igrain = 1,np(rve)
          fmag(igrain) = 0.
          vhmag(igrain) = 0.
          fthmag(igrain) = 0.
          vthmag(igrain) = 0.
          do 101 i = 1,ndim1
            fmag(igrain) = fmag(igrain) + f(i,igrain,rve)**2
            vhmag(igrain) = vhmag(igrain) + vh(i,igrain,rve)**2
            fthmag(igrain) = fthmag(igrain) + fth(i,igrain,rve)**2
            vthmag(igrain) = vthmag(igrain) + vhth(i,igrain,rve)**2
  101     continue
          fmag(igrain) = sqrt(fmag(igrain))
          vhmag(igrain) = sqrt(vhmag(igrain))
          fthmag(igrain) = sqrt(fthmag(igrain))
          vthmag(igrain) = sqrt(vthmag(igrain))
  100   continue
      endif
c
      rfact1_c = rfact1(rve)
      rfact2_c = rfact2(rve)
      tfact1_c = tfact1(rve)
      tfact2_c = tfact2(rve)
c
      do 10 igrain = 1,np(rve)
c-------compute the new velocities and positions of each particle
c
c-------the energy expended in viscous damping
        fdamp = 0.
c
c-------if particle movements are allowed...
        do 20 j = 1,ndim1
          ddx(j) = 0.
              lv = .true.
c
              if(lv) then
                if(lexact) then
c-----------------calculate the change in velocity between i-1/2 and i+1/2.
c                 When lexact=.true., we use the actual moments of inertia
c                 for the particle to compute rotations of an ovoid.  When
c                 lexact=.false., we treat the ovoid as a sphere.
                  if(lbody(1,rve) .or. nabors(igrain,rve).eq.0) then
                    vho = vh(j,igrain,rve)
c
c-------------------damping factors, customized for this particle's mass
                    if(idamp(rve).eq.1) then
                      tdampb = abs(pcrit(1,rve)) 
     x                       * sqrt(knmax(rve)/mass(igrain,rve))
     x                       * dt(rve)
                    elseif(idamp(rve).eq.2) then
                      idtyp = 1
                      if(vhmag(igrain).ne.0.) then
                        tdampb = abs(pcrit(1,rve)) * dt(rve)
     x                           * abs(f(j,igrain,rve))
     x                    / (2.d0 * mass(igrain,rve) * vhmag(igrain))
                        if(tdampb.gt.1.d0) then
                          tdampb = tdampa(rve)
                          idtyp = 2
                        endif
                      else
                        tdampb = abs(pcrit(1,rve))
     x                        * sqrt(knmax(rve)/mass(igrain,rve))
     x                        * dt(rve)
                        idtyp = 2
                      endif
                    endif
c
                    tfact1(rve) = 1.d0 - tdampb
                    tfact2(rve) = 1.d0 + tdampb
c
c-------------------calculate the new velocity using implicit integration
                    vh(j,igrain,rve)  =
     x                (tfact1(rve)*vh(j,igrain,rve) + 
     x                 f(j,igrain,rve)*dt(rve)/mass(igrain,rve))
     x                / tfact2(rve)
c
c-------------------the average of the new and old velocities
                    vavg = (vho + vh(j,igrain,rve)) * 0.5d0
                    vsq = vsq + mass(igrain,rve)*(vavg)**2
c
                    if(idamp(rve).eq.1 .or. idamp(rve).eq.3) then
c---------------------for computing the average damping force on a particle,
c                     which will be used in computing the performance
c                     parameter, chi4
                      fdamp = fdamp + (damp1(rve)*vavg)**2
                    elseif(idamp(rve).eq.2) then
                      fdamp = fdamp
     x                        + (pcrit(1,rve)
     x                          *abs(f(j,igrain,rve)))**2
c
c---------------------energy expended with Potyondy/Cundall damping
                      if(idtyp.eq.1) then
                        f3damp = f3damp 
     x                         + abs(f(j,igrain,rve))*vho**2 
     x                           / vhmag(igrain)
                      elseif(idtyp.eq.2) then
                        f3damp = f3damp + damp1(rve) * vavg**2
                      endif
                    endif
                  else
                    dv = f(j,igrain,rve)*dt(rve)/mass(igrain,rve)
                    vavg = vh(j,igrain,rve) + dv*0.5d0
                    vsq = vsq + mass(igrain,rve)*vavg**2
                    vh(j,igrain,rve) = dv + vh(j,igrain,rve)
                  endif
                else
c-----------------calculate the change in velocity between i-1/2 and i+1/2
                  if(lbody(1,rve) .or. nabors(igrain,rve).eq.0) then
                    vho = vh(j,igrain,rve)
c
                    if(idamp(rve).eq.2) then
                      idtyp = 1
                      if(vhmag(igrain).ne.0.) then
                        tdampb = adtm(rve) * abs(f(j,igrain,rve)) 
     x                           / vhmag(igrain)
                        if(tdampb.gt.1.d0) then
                          tdampb = tdampa(rve)
                          idtyp = 2
                        endif
                      else
                        tdampb = tdampa(rve)
                        idtyp = 2
                      endif
                      tfact1(rve) = 1.d0 - tdampb
                      tfact2(rve) = 1.d0 + tdampb
                    endif
c
c-------------------calculate the new velocity using implicit integration
                    if(idamp(rve).ne.3
     x                 .or. nslidc(igrain,rve).lt.2) then
                      vh(j,igrain,rve) = 
     x                     (tfact1(rve)*vh(j,igrain,rve)
     x                      + f(j,igrain,rve)*massit(rve))
     x                     / tfact2(rve)
                    else
c---------------------with idamp=3, if a particles has more than one sliding
c                     neighbor, then we do not apply viscous damping
                      vh(j,igrain,rve) = 
     x                     vh(j,igrain,rve)
     x                     + f(j,igrain,rve)*massit(rve)
                    endif
c
c-------------------the average of the new and old velocities
                    vavg = (vho + vh(j,igrain,rve)) * 0.5d0
                    vsq = vsq + vavg**2
c
                    if(idamp(rve).eq.1 .or. idamp(rve).eq.3) then
c---------------------for computing the average damping force on a particle,
c                     which will be used in computing the performance 
c                     parameter, chi4
                      fdamp = fdamp + (damp1(rve)*vavg)**2
                    elseif(idamp(rve).eq.2) then
                      fdamp = fdamp
     x                        + (pcrit(1,rve)
     x                           *abs(f(j,igrain,rve)))**2
c
c---------------------energy expended with Potyondy/Cundall damping
                      if(idtyp.eq.1) then
                        f3damp = f3damp
     x                      + pcrit(1,rve)
     x                        * abs(f(j,igrain,rve))*vho**2 
     x                        / vhmag(igrain)
                      elseif(idtyp.eq.2) then
                        f3damp = f3damp + damp1(rve) * vavg**2
                      endif
                    endif
                  else
                    dv = f(j,igrain,rve)*massit(rve)
                    vavg = vh(j,igrain,rve) + dv*0.5d0
                    vsq = vsq + vavg**2
                    vh(j,igrain,rve) = dv + vh(j,igrain,rve)
                  endif
                endif
c
c---------------factor used to evaluate if the deformation is pseudo-static
                fbalsq_c = fbalsq_c + f(j,igrain,rve)**2
c
c---------------useful for debugging purposes
                if(abs(f(j,igrain,rve)) .gt. fjmax) then
                  fjmax = abs(f(j,igrain,rve))
                  igranm = igrain
                endif
c
c---------------the movement produced by the mean velocity
                ddx(j) = vh(j,igrain,rve)*dt(rve)
              endif
c           else
c-------------when a boundary particle is restrained from moving in the
c             "j" direction
c             vh(j,igrain,rve) = 0.
c           endif
c         endif
c
          if(algori.eq.1) then
            dx(j,igrain,rve) = ddx(j)
            xp(j,igrain,rve) = xp(j,igrain,rve) + dx(j,igrain,rve)
            xmove(j,igrain,rve) = xmove(j,igrain,rve)
     x                             + dx(j,igrain,rve)
          elseif(algori.eq.2 .and. .not.lreset(rve)) then
            dx(j,igrain,rve) = dx(j,igrain,rve) + ddx(j)
            xp(j,igrain,rve) = xp(j,igrain,rve) + ddx(j)
            xmove(j,igrain,rve) = xmove(j,igrain,rve) + ddx(j)
          elseif(algori.eq.2 .and. lreset(rve)) then
            dx(j,igrain,rve) = ddx(j)
            xp(j,igrain,rve) = xp(j,igrain,rve) + dx(j,igrain,rve)
            xmove(j,igrain,rve) = xmove(j,igrain,rve)
     x                             + dx(j,igrain,rve)
          endif
c
c---------energy expended in viscous damping
          fdampa_c = fdampa_c + fdamp
   20   continue
c
        if(lexact) then
c
c-------lexact=.true. means that the computations will be faithfull to
c       the individual mass of each particle.  When lexact=.false.,
c       each particle is assigned the same mass.
c
c---------damping factors, customized for this particle's mass
          if(idamp(rve).eq.1) then
            rdampb = abs(pcrit(2,rve))
     x               *rad(igrain,rve)
     x               *sqrt(kt(rve)/mnt(igrain,rve))*dt(rve)
          elseif(idamp(rve).eq.2) then
            idtyp = 1
            if(vthmag(igrain).ne.0.) then
              rdampb = abs(pcrit(2,rve)) * dt(rve)
     x               * abs(fth(j,igrain,rve))
     x               / (2.d0 * mnt(igrain,rve) * vthmag(igrain))
              if(rdampb.gt.1.d0) then
c---------------damping force should oppose the motion
                rdampb = rdampa(rve)
                idtyp = 2
              endif
            else
              rdampb = abs(pcrit(2,rve))*rad(igrain,rve)
     x                 *sqrt(kt(rve)/mnt(igrain,rve))*dt(rve)
              idtyp = 2
            endif
          endif
c
          rfact1(rve) = 1.d0 - rdampb
          rfact2(rve) = 1.d0 + rdampb
c
          if(lovoid(rve)) then
c
c-----------ovoids are non-spherical 3D particles.  With lexact=.true.,
c           we address gyroscopic effects in the kinetic calculations.
c           When lexact=.false., we ignore this effect.
c
c-----------the kinetics of ovoids (a surface of revolution) is based
c           on the Euler equations.  A numerical integration of these
c           equations is in the the work of Lin and Ng, 
c           "A three-dimensional discrete element model using arrays of
c           ellipsoids," Geotechnique, Vol. 47, No. 2, pp 319--329 (1997).
c
c-----------unit vector aligned with the central axis of the ovoid
            a(1,1) = a_vect(1,igrain,rve)
            a(2,1) = a_vect(2,igrain,rve)
            a(3,1) = a_vect(3,igrain,rve)
c
c-----------unit vector in the x1-x2 plane and perpendicular to ovoid axis
            a12len =  sqrt(a(1,1)**2 + a(2,1)**2)
            a(1,2) = -a_vect(2,igrain,rve) / a12len
            a(2,2) =  a_vect(1,igrain,rve) / a12len
            a(3,2) =  0.
c
c-----------third unit vector, forming a right-hand system
            a(1,3) = -a(2,2)*a(3,1)
            a(2,3) =  a(1,2)*a(3,1)
            a(3,3) =  sqrt(1.d0 - a(3,1)**2)
c
c-----------compute the moment in the frame of the ovoid semi-axes
            fths(1) =  a(1,1)*fth(1,igrain,rve)
     x                 + a(2,1)*fth(2,igrain,rve)
     x                 + a(3,1)*fth(3,igrain,rve)
            fths(2) =  a(1,2)*fth(1,igrain,rve)
     x                 + a(2,2)*fth(2,igrain,rve)
     x                 + a(3,2)*fth(3,igrain,rve)
            fths(3) =  a(1,3)*fth(1,igrain,rve)
     x                 + a(2,3)*fth(2,igrain,rve)
     x                 + a(3,3)*fth(3,igrain,rve)
c
c-----------compute the previous rotational velocity in the frame of
c           the ovoid semi-axes
            vhthso(1) =  a(1,1)*vhth(1,igrain,rve)
     x                 + a(2,1)*vhth(2,igrain,rve)
     x                 + a(3,1)*vhth(3,igrain,rve)
            vhthso(2) =  a(1,2)*vhth(1,igrain,rve)
     x                 + a(2,2)*vhth(2,igrain,rve)
     x                 + a(3,2)*vhth(3,igrain,rve)
            vhthso(3) =  a(1,3)*vhth(1,igrain,rve)
     x                 + a(2,3)*vhth(2,igrain,rve)
     x                 + a(3,3)*vhth(3,igrain,rve)
c
c-----------This is the negative of the I_t of Lin and Ng.  I think there
c           is an error in their paper.
            mntdif = -(mnt(igrain,rve) - mnt2(igrain,rve))
c
c-----------change in angular velocity about the ovoid axis.  Lin and Ng
c           Eq. (22)
            vhthsa(1) = (rfact1(rve)*vhthso(1)
     x                    + fths(1)*dt(rve)/mnt(igrain,rve))
     x                  / rfact2(rve)
c
c-----------the average of the old and new angular velocities
            vhthsm = 0.5d0*(vhthso(1) + vhthsa(1))
c
c-----------Lin and Ng Eqs. (26)-(28)
            omega1 = (mnt2(igrain,rve)*rfact2(rve))**2
     x               + (mntdif * vhthsm * dt(rve) / 2.d0)**2
            psi1 = mnt2(igrain,rve)*rfact1(rve)*vhthso(2)
     x             + mntdif*vhthsm*dt(rve)/2.d0*vhthso(3)
     x             + fths(2)*dt(rve)
            zeta1 = mnt2(igrain,rve)*rfact1(rve)*vhthso(3)
     x              - mntdif*vhthsm*dt(rve)/2.d0*vhthso(2)
     x              + fths(3)*dt(rve)
c
c-----------Lin and Ng Eqs. (24) and (25)
            vhthsa(2) = (mnt2(igrain,rve)*rfact2(rve)*psi1
     x                  + mntdif*vhthsm*dt(rve)*zeta1/2.d0) / omega1
            vhthsa(3) = (mnt2(igrain,rve)*rfact2(rve)*zeta1
     x                  - mntdif*vhthsm*dt(rve)*psi1/2.d0) / omega1
c
c-----------now, convert back to the global x1-x2-x3 coordinate system
            vhth(1,igrain,rve) = a(1,1)*vhthsa(1) + a(1,2)*vhthsa(2) 
     x                            + a(1,3)*vhthsa(3)
            vhth(2,igrain,rve) = a(2,1)*vhthsa(1) + a(2,2)*vhthsa(2)
     x                            + a(2,3)*vhthsa(3)
            vhth(3,igrain,rve) = a(3,1)*vhthsa(1) + a(3,2)*vhthsa(2)
     x                            + a(3,3)*vhthsa(3)
c
            vthsq = vthsq + 0.25d0*
     x        (  mnt(igrain,rve)*     (vhthso(1) + vhthsa(1))**2
     x         + mnt2(igrain,rve)*(   (vhthso(2) + vhthsa(2))**2
     x                          + (vhthso(3) + vhthsa(3))**2))
c
            if(idamp(rve).eq.2) then
              if(idtyp.eq.1) then
                fth3dp = fth3dp 
     x                 + abs(fth(j,igrain,rve))
     x                   * (vhthso(1)**2 +vhthso(2)**2 +vhthso(3)**2)
     x                     / vthmag(igrain)
              elseif(idtyp.eq.2) then
                fth3dp = fth3dp + damp2(rve) * vhtho**2
              endif
            endif
c
            thblsq_c = thblsq_c + fth(1,igrain,rve)**2
     x                          + fth(2,igrain,rve)**2
     x                          + fth(3,igrain,rve)**2
c
          else
c-----------for non-ovoid shapes ...
c
            do 42 j = ndim2,3
              if(lbody(2,rve) .or. nabors(igrain,rve).eq.0) then
                vhtho = vhth(j,igrain,rve)
c
c---------------damping factors
                if(idamp(rve).eq.2) then
                  idtyp = 1
                  if(vthmag(igrain).ne.0.) then
                    rdampb = abs(pcrit(2,rve)) 
     x                       * dt(rve) * abs(fth(j,igrain,rve))
     x                       / (2.d0* mnt(igrain,rve)*vthmag(igrain))
                    if(rdampb.gt.1.d0) then
c---------------------damping force should oppose the motion
                      rdampb = rdampa(rve)
                      idtyp = 2
                    endif
                  else
                    rdampb = rdampa(rve)
                    idtyp = 2
                  endif
                  rfact1(rve) = 1.d0 - rdampb
                  rfact2(rve) = 1.d0 + rdampb
                endif
c
                vhth(j,igrain,rve) = 
     x             (rfact1(rve)*vhth(j,igrain,rve)
     x              + fth(j,igrain,rve)*dt(rve)/mnt(igrain,rve))
     x             / rfact2(rve)
                vthsq = vthsq 
     x                  + 0.25d0*mnt(igrain,rve)
     x                          *(vhtho + vhth(j,igrain,rve))**2
c
                  if(idamp(rve).eq.2) then
                    if(idtyp.eq.1) then
                      fth3dp = fth3dp
     x                         + abs(fth(j,igrain,rve)) * vhtho**2
     x                           / vthmag(igrain)
                  elseif(idtyp.eq.2) then
                    fth3dp = fth3dp + damp2(rve) * vhtho**2
                  endif
                endif
c
c---------------factor to evaluate whether the deformation is pseudo-static
                thblsq_c = thblsq_c + fth(j,igrain,rve)**2
c
              else
c---------------the change in rotational velocity
                dvth = fth(j,igrain,rve) * dt(rve) /mnt(igrain,rve)
c
c---------------the average of the new and old rotational velocities
                vthavg = vhth(j,igrain,rve) + dvth*0.5d0
c
c---------------for use in computing the rotational kinetic energy
                vthsq = vthsq + mnt(igrain,rve)*vthavg**2
c
c---------------the new rotational velocity
                vhth(j,igrain,rve) = vhth(j,igrain,rve) + dvth
c
c---------------factor to evaluate whether the deformation is pseudo-static
                thblsq_c = thblsq_c + fth(j,igrain,rve)**2
              endif
c
c-------------for debugging
              if(abs(fth(j,igrain,rve)) .gt. fjtmax) then
                fjtmax = abs(fth(j,igrain,rve))
                ibaltm = igrain
              endif
   42       continue
          endif
        else
          do 22 j = ndim2,3
            if(lbody(2,rve) .or. nabors(igrain,rve).eq.0) then
              vhtho = vhth(j,igrain,rve)
c
              if(idamp(rve).eq.2) then
                idtyp = 1
                if(vthmag(igrain).ne.0.) then
                  rdampb = athdtm(rve) * abs(fth(j,igrain,rve))
     x                            / vthmag(igrain)
                  if(rdampb.gt.1.d0) then
c-------------------damping force should oppose the motion
                    rdampb = rdampa(rve)
                    idtyp = 2
                  endif
                else
                  rdampb = rdampa(rve)
                  idtyp = 2
                endif
                rfact1(rve) = 1.d0 - rdampb
                rfact2(rve) = 1.d0 + rdampb
              endif
c
              if(idamp(rve).ne.3 .or. nslidc(igrain,rve).lt.2) then
                vhth(j,igrain,rve) = 
     x            (rfact1(rve)*vhth(j,igrain,rve)
     x             + fth(j,igrain,rve)*mntit(rve)) 
     x            / rfact2(rve)
              else
c---------------with idamp=3, if a particles has more than one sliding
c               neighbor, we do not apply viscous damping
                vhth(j,igrain,rve) = vhth(j,igrain,rve)
     x                                + fth(j,igrain,rve)*mntit(rve)
              endif
c
c-------------for use in computing the rotational kinetic energy
              vthsq = vthsq + 0.25d0*(vhtho + vhth(j,igrain,rve))**2
c
              if(idamp(rve).eq.2) then
                if(idtyp.eq.1) then
                  fth3dp = fth3dp
     x                     + pcrit(2,rve)
     x                       * abs(fth(j,igrain,rve))*vhtho**2
     x                       / vthmag(igrain)
                elseif(idtyp.eq.2) then
                  fth3dp = fth3dp + damp2(rve) * vhtho**2
                endif
              endif
c
c-------------factor to evaluate whether the deformation is pseudo-static
              thblsq_c = thblsq_c + fth(j,igrain,rve)**2
c
            else
c-------------the change in rotational velocity
              dvth = fth(j,igrain,rve)*mntit(rve)
c
c-------------the average of the new and old rotational velocities
              vthavg = vhth(j,igrain,rve) + dvth*0.5d0
c
c-------------for use in computing the rotational kinetic energy
              vthsq = vthsq + vthavg**2
c
c-------------the new rotational velocity
              vhth(j,igrain,rve) = vhth(j,igrain,rve) + dvth
c
c-------------factor used to evaluate whether the deformation is pseudo-static
              thblsq_c = thblsq_c + fth(j,igrain,rve)**2
            endif
c
c-----------for debugging
            if(abs(fth(j,igrain,rve)) .gt. fjtmax) then
              fjtmax = abs(fth(j,igrain,rve))
              ibaltm = igrain
            endif
   22     continue
        endif
c
        do 23 j = ndim2,3
c---------when advancing the orientation angle "theta", we need to make
c         a distinction between two types of increments:
c             ddth() :  the incremental change in angle during this
c                       single pass through subroutin "integ"
c             dth()  :  the incremental change in angle that has occured
c                       since the contact force data was last updated.
c                       dth() will be used by subroutin "forces" to compute
c                       the new contact forces, based upon their stored
c                       values and the particle movements that have occured
c                       since those values were stored.
c
c         with algori=1 (the conventional DEM algorithm) the two increments
c         are equal.  With the relaxation algori=2, the contact force data
c         is not updated with each pass through integ.
c
          if(algori.eq.1) then
            dth(j,igrain,rve) = vhth(j,igrain,rve)*dt(rve)
            theta(j,igrain,rve) = theta(j,igrain,rve)
     x                             + dth(j,igrain,rve)
            thmove(j,igrain,rve) = thmove(j,igrain,rve)
     x                              + dth(j,igrain,rve)
            ddth(j,igrain,rve) = dth(j,igrain,rve)
          elseif(algori.eq.2 .and. .not.lreset(rve)) then
            ddth(j,igrain,rve) = vhth(j,igrain,rve)*dt(rve)
            theta(j,igrain,rve) = 
     x        theta(j,igrain,rve) + ddth(j,igrain,rve)
            dth(j,igrain,rve) = dth(j,igrain,rve)
     x                          + ddth(j,igrain,rve)
            thmove(j,igrain,rve) = thmove(j,igrain,rve)
     x                              + ddth(j,igrain,rve)
          elseif(algori.eq.2 .and. lreset(rve)) then
            dth(j,igrain,rve) = vhth(j,igrain,rve)*dt(rve)
            theta(j,igrain,rve) = 
     x        theta(j,igrain,rve) + dth(j,igrain,rve)
            thmove(j,igrain,rve) = thmove(j,igrain,rve)
     x                              + dth(j,igrain,rve)
            ddth(j,igrain,rve) = dth(j,igrain,rve)
          endif
   23   continue
   10 continue
c
c-----copies to facilitate parallelization
      fbalsq(rve) = fbalsq_c
      thblsq(rve) = thblsq_c
      fdampa(rve) = fdampa_c
c
c-----copies to facilitate parallelization
      rfact1(rve) = rfact1_c
      rfact2(rve) = rfact2_c
      tfact1(rve) = tfact1_c
      tfact2(rve) = tfact2_c
c
c-----do we need to compute the sines and cosines of the particle
c     orientation angles theta()?  ltheta is passed to subroutin locate
      ltheta(rve) = .true.
c
c-----compute the locations of the component pieces ovals and ovoids.
c     Also recompute the sines and cosines of the particle orientation
c     angles theta()
      call locate(rve)
c
c-----With composite "bumpy" particles...
      if(lbumpy(rve)) then
c-------having computed the incremental rotation of the particle, we
c       must apply this increment to the quaternions that give the
c       particles' orientations
c
c-------normalize the revised quaternion by dividing by the square root
c       of its norm
        inorm = 2
        do 121 igrain=1,np(rve)
c---------the current orientation quaternion
          Qp_old(1) = Qp(1,igrain,rve)
          Qp_old(2) = Qp(2,igrain,rve)
          Qp_old(3) = Qp(3,igrain,rve)
          Qp_old(4) = Qp(4,igrain,rve)
c
c---------the incremental rotation in the global frame (for either 
c         algori=1 or algori=2)
          dw(1) = vhth(1,igrain,rve)*dt(rve)
          dw(2) = vhth(2,igrain,rve)*dt(rve)
          dw(3) = vhth(3,igrain,rve)*dt(rve)
c
c---------apply the incremental rotation to the orientation quaternion
          call QIncRotate(Qp_old, Qp_new, dw, inorm)
c
c---------the revised orientation quaternion
          Qp(1,igrain,rve) = Qp_new(1)
          Qp(2,igrain,rve) = Qp_new(2)
          Qp(3,igrain,rve) = Qp_new(3)
          Qp(4,igrain,rve) = Qp_new(4)
  121   continue
      endif
c
c-----the kinetic energy per unit of original volume.  The kinetic energy due
c     to translational and rotational velocities are computed separately
      if(lexact) then
        knrgy1 = 0.5d0*vsq / vcellt(rve)
        knrgy2 = 0.5d0*vthsq / vcellt(rve)
      else
        knrgy1 = (massav(rve)*vsq)*0.5d0 / vcellt(rve)
        knrgy2 = (mntav(rve)*vthsq)*0.5d0 / vcellt(rve)
      endif
c
      knrgy(rve) = knrgy1 + knrgy2
      knrgyo(rve) = knrgy(rve)
c
c-----the energy expended by the viscous force, per unit of original volume
      if(idamp(rve).eq.1 .or. idamp(rve).eq.3) then
        viscb = 0.
        if(lbody(1,rve)) then
          viscb = viscb + damp1(rve)*vsq*dt(rve)/vcellt(rve)
        endif
c
        if(lbody(2,rve)) then
          viscb = viscb + damp2(rve)*vthsq*dt(rve)/vcellt(rve)
        endif
      elseif(idamp(rve).eq.2) then
         viscb = dt(rve) * (f3damp + fth3dp)/vcellt(rve)
      endif
c
c-----the accumulated energy expended by the viscous force since the start
c     of the simulation run
      viscbt(rve) = viscbt(rve) + viscb
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine output(rve)
c
c-----This subroutin reports the simulation results by appending information
c     to the "A*.txt" and "B*" files.  The information includes deformation, 
c     stress, energies, performance diagnostics, etc.
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 rve
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 igrain,ntact2,ntact3,ntacsb
c
      double precision chia2,chia3,chia4,
     x                 defout(3,3),dpoint,
     x                 e_eff,fab1(3,3),fab2(3,3),fabsub(3,3),
     x                 pnrgy_alt,pnrgy2_alt,
     x                 tempav,vfab,
     x                 znrgy1,znrgy2
      logical openedq
      character*1 tab
      character*800 name_of_file
c
      tab = achar(9)
c
c-----several factors are used for monitoring the performance of the
c     simulation.  Typically, these factors are averaged between output
c     cycles.  "ipoint" is the number of time steps between output cycles.
      if(ipoint(rve).ne.0) then
        dpoint = dble(ipoint(rve))
c
        chia1(rve) = chi1t(rve) / dble(ipoint(rve))
        chia2 = chi2t(rve) / dble(ipoint(rve))
        chia3 = chi3t(rve) / dble(ipoint(rve))
        chia4 = chi4t(rve) / dble(ipoint(rve))
        xcded = dble(lpsxcd(rve)) / dble(ipoint(rve))
        xloops = dble(loopst(rve)) / dble(ipoint(rve))
        picap1 = picpt1(rve) / dble(ipoint(rve))
        picap2 = picpt2(rve) / dble(ipoint(rve))
      else
        chia1(rve) = 0.
        chia2 = 0.
        chia3 = 0.
        chia4 = 0.
        xcded = 0.
        xloops = 0.
        picap1 = 0.
        picap2 = 0.
      endif
c
c-----reset the totals
      chi1t(rve) = 0.
      chi2t(rve) = 0.
      chi3t(rve) = 0.
      chi4t(rve) = 0.
      lpsxcd(rve) = 0
      loopst(rve) = 0
      picpt1(rve) = 0.
      picpt2(rve) = 0.
c
c-----the number of output writes to the A-files, B-files, and H-files
      iouti(rve) = iouti(rve) + 1
c
c-----print current status to the screen:
c
      if(iouti(rve).eq.0) then
c-------at the beginning of the simulation, write some information to
c       the screen.  "ntacts" is the number of contacts withing the
c       assembly.  "ovravg/(2.d0*ravg)" is the average overlap at
c       the contacts divided by the average particle diameter.
c       for the screen
        write(ScrUnit(rve),302)
     x    ntacts(rve), ovravg(rve)/(2.d0*ravg(rve))
c-------create some column headings for screen diagnostics
        write(ScrUnit(rve),303)
      endif
c
c-----print status and diagnotics to the screen
      if(.not.(lJager(rve) .or. lJagr2(rve)
     x         .or. lJagr3(rve) .or. lJagr4(rve))) then
        write(ScrUnit(rve),300)
     x               iouti(rve),timer(rve),istep2(rve),nupdat4(rve),
     x               ipt2,xloops,
     x               chia1(rve),chia2,
     x               psi(rve),sweep(rve)
      else
        if(frict(rve).gt.0.) then
          xfill = real(nfilled(rve)) / real(mlistJ)
        else
          xfill = 0.
        endif
c
c-------here, Dempla departs from the Oval code, allowing more digits for
c       iouti, timer, and istep2.  The output will be 87 characters, instead of 
c       80 characters
        write(ScrUnit(rve),304)
     x               iouti(rve),timer(rve),istep2(rve),nupdat4(rve),
     x               ipt2,xloops,
     x               chia1(rve),chia2,
     x               psi(rve),xfill
c
c-------for debugging purposes, find the name of the output file
        inquire(unit=ScrUnit(rve), opened=openedq, name=name_of_file)
      endif
c
      if(.false.) then
      if(lJager(rve) .or. lJagr2(rve)
     x   .or. lJagr3(rve) .or. lJagr4(rve)) then
c-------find the total tangential elastic energy in Jager contacts
        call wrkJag(znrgy1,znrgy2,rve)
        pnrgy2_alt = znrgy2
c
        if(timer(rve).eq.0. .and. pnrgy2o(rve).eq.0.) then
          pnrgy2o_alt(rve) = pnrgy2_alt
        endif
c
c-------inelastic energy expended in sliding
        if(.not.(timer(rve).eq.0.
     x       .and. istart(rve).gt.2 .and. idef(rve).eq.1)) then
          dslid2 = workc(rve) - (pnrgy2_alt - pnrgy2o_alt(rve))
        else
          dslid2 = 0.
        endif
c
        if(timer(rve).eq.0.) then
          dslidet(rve) = 0.
        endif
c
c-------there is a glitch in the algorithm for computing the elastic
c       energy in the contacts (pnrgy2_alt), which causes abrupt changes
c       in the frictional dissipation.  If the dissipation dslid2 is negative,
c       then use an alternative estimation of the dissipation
        if(dslid2.lt.0.) then
          if(dslidet(rve).lt.0.) then
            dslid2 = dslidet(rve)
          else
            dslid2 = 0.
          endif
        endif
c
        dslidet(rve) = 0.
c
c-------total expended since the start of the simulation
        slidet_alt(rve) = slidet_alt(rve) + dslid2 / vcellt(rve)
c
        workc(rve) = 0.
        pnrgy2o_alt(rve) = pnrgy2_alt
c
        pnrgy2_alt = pnrgy2_alt / vcellt(rve)
c
c-------total contact elastic energy of all contacts
        pnrgy_alt = pnrgy1(rve) + pnrgy2_alt
c
        pnrgy(rve) = pnrgy_alt
        slidet(rve) = slidet_alt(rve)
      endif
      endif
c
      if(lout(1)) then
c-------Print results to a Type 2 ("B" prefix) output file - an abbreviated
c       listing of stresses, strains and diagnostics
c-------Compute the "strain".  Here, the strain is equal to the deformation
c       gradient (defp) minus the Kroneker delta, = F - I.
        do 10 i = 1,3
          do 11 j = i,3
            if(i.eq.j) then
              defout(i,j) = (def(i,j,rve) / defo(i,j,rve)) - 1.d0
            else
              defout(i,j) = def(i,j,rve) - defo(i,j,rve)
            endif
   11     continue
   10   continue
c
c-------we will print some information about the particle graph for 2D
c       assemblies.  We need to call the subroutins that produces the
c       particle graph (but only if this has not already been done
c       elsewhere in this time step).
        if(ndim1.eq.2) then
          call circuit(rve)
        endif
c
c-----when a temperature-dependent model is being used, report the
c     average temperature of the particles
      if(iheat(rve).eq.1 .and. hmodel(rve).eq.1) then
        tempav = 0.
        do 772 igrain=1,np(rve)
          tempav = tempav + tempr(igrain,rve)
  772   continue
        tempav = tempav / np(rve)
      endif
c
c-----now that we have produced the particle graph (for 2D assemblies), 
c     compute various quantities from the particle graph, such
c     as the effective void ratio, fabric tensor, effective coordination
c     number, valences, etc.
      call fabrik(fab1,fab2,fabsub,vfab,e_eff,ntact2,ntact3,ntacsb,rve)
c
      if(lporo(rve)) then
c-------when pore fluid pressures are included, write information about the
c       fluid pressure (pfluid), the fluid inflow (the difference of the
c       Jacobian of the bulk, skeletal deformation tensor and the Jacobian
c       of the pore fluid deformation), the elastic energy of the
c       pore fluid (fpnrgy), and the elastic energy of the grains due 
c       to the pore (spnrgy)
c       fluid pressure
c
c-------placeholder for later code
        fpnrgy(rve) = 0.
        spnrgy(rve) = 0.
c
        if(iporo(rve).ne.4) then
          fpnrgy(rve) = poros0(rve) * 0.5d0 / K_f(rve)
     x                   * (pfluid(rve) - p_o(rve))
     x                   * (pfluid(rve) + p_o(rve))
        endif
c
        spnrgy(rve) = (1.d0 - poros0(rve)) * 0.5d0 / K_s(rve)
     x                 * (pfluid(rve) - p_o(rve))
     x                 * (pfluid(rve) + p_o(rve))
      endif
c
c-----Output information
      if(ndim1.eq.3.and.lABfile) then
c-----Output for 3D assemblies
c
c-------Output information written to the "A*.txt" file.  Note that tabs
c       are inserted so that the files can be imported into most
c       spreadsheet programs.
c
c-------the tab character.  In the past, I used "h" format (Hollerith format)
c       to create the tab character in ouput.  This worked fine with most
c       compilers, but then I discovered that the gcc/g77 compiler
c       did not correctly produce the tab characters.  So now I must use
c       this rather stupid, cumbersome approach to inserting tabs.
c       I know it is ridiculous, but this was the only way I could think to
c       reliably produce the tabs
c
        if(.not.(iheat(rve).eq.1 .and. hmodel(rve).eq.1)) then
          if(.not.lporo(rve)) then
            write(AUnit(rve),600) timer(rve),tab,
     x               defout(1,1),tab,defout(2,2),tab,defout(3,3),tab,
     x               defout(1,2),tab,defout(1,3),tab,defout(2,3),tab,
     x               stress(1,1,rve),tab,stress(2,2,rve),tab,
     x               stress(3,3,rve),tab,
     x               (stress(1,2,rve) + stress(2,1,rve))/2.d0,tab,
     x               (stress(1,3,rve) + stress(3,1,rve))/2.d0,tab,
     x               (stress(2,3,rve) + stress(3,2,rve))/2.d0,tab,
     x               chia1(rve),tab,chia2,tab,psi(rve),tab,
     x               ntacts(rve),tab,
     x               fab1(1,1),tab,fab1(2,2),tab,fab1(3,3),tab,
     x               fab1(1,2),tab,fab1(1,3),tab,fab1(2,3),tab,
     x               fab2(1,1),tab,fab2(2,2),tab,fab2(3,3),tab,
     x               fab2(1,2),tab,fab2(1,3),tab,fab2(2,3),tab,
     x               vfab,tab,voidn(rve),tab,e_eff,tab,
     x               knrgy(rve),tab,pnrgy(rve),tab,
     x               slidet(rve),tab,viscbt(rve),tab,
     x               viscct(rve),tab,work1t(rve),tab,
     x               nslide(rve),tab,nnear(rve),tab,
     x               solidr(rve),tab,ntactz(rve)
          else
            write(AUnit(rve),610) timer(rve),tab,
     x               defout(1,1),tab,defout(2,2),tab,defout(3,3),tab,
     x               defout(1,2),tab,defout(1,3),tab,defout(2,3),tab,
     x               stress(1,1,rve),tab,stress(2,2,rve),tab,
     x               stress(3,3,rve),tab,
     x               (stress(1,2,rve) + stress(2,1,rve))/2.d0,tab,
     x               (stress(1,3,rve) + stress(3,1,rve))/2.d0,tab,
     x               (stress(2,3,rve) + stress(3,2,rve))/2.d0,tab,
     x               chia1(rve),tab,chia2,tab,psi(rve),tab,
     x               ntacts(rve),tab,
     x               fab1(1,1),tab,fab1(2,2),tab,fab1(3,3),tab,
     x               fab1(1,2),tab,fab1(1,3),tab,fab1(2,3),tab,
     x               fab2(1,1),tab,fab2(2,2),tab,fab2(3,3),tab,
     x               fab2(1,2),tab,fab2(1,3),tab,fab2(2,3),tab,
     x               vfab,tab,voidn(rve),tab,e_eff,tab,
     x               knrgy(rve),tab,pnrgy(rve),tab,
     x               slidet(rve),tab,viscbt(rve),tab,
     x               viscct(rve),tab,work1t(rve),tab,
     x               nslide(rve),tab,nnear(rve),tab,
     x               solidr(rve),tab,ntactz(rve),tab,
     x               pfluid(rve),tab,defw(rve),tab,
     x               fpnrgy(rve),tab,spnrgy(rve),tab,S_now(rve)
          endif
        elseif(iheat(rve).eq.1 .and. hmodel(rve).eq.1) then
          if(.not.lporo(rve)) then
            write(AUnit(rve),603) timer(rve),tab,
     x                defout(1,1),tab,defout(2,2),tab,defout(3,3),tab,
     x                defout(1,2),tab,defout(1,3),tab,defout(2,3),tab,
     x                stress(1,1,rve),tab,stress(2,2,rve),tab,
     x                stress(3,3,rve),tab,
     x               (stress(1,2,rve) + stress(2,1,rve))/2.d0,tab,
     x               (stress(1,3,rve) + stress(3,1,rve))/2.d0,tab,
     x               (stress(2,3,rve) + stress(3,2,rve))/2.d0,tab,
     x               chia1(rve),tab,chia2,tab,psi(rve),tab,
     x               ntacts(rve),tab,
     x               fab1(1,1),tab,fab1(2,2),tab,fab1(3,3),tab,
     x               fab1(1,2),tab,fab1(1,3),tab,fab1(2,3),tab,
     x               fab2(1,1),tab,fab2(2,2),tab,fab2(3,3),tab,
     x               fab2(1,2),tab,fab2(1,3),tab,fab2(2,3),tab,
     x               vfab,tab,voidn(rve),tab,e_eff,tab,
     x               knrgy(rve),tab,pnrgy(rve),tab,slidet(rve),tab,
     x               viscbt(rve),tab,
     x               viscct(rve),tab,work1t(rve),tab,
     x               nslide(rve),tab,nnear(rve),tab,
     x               solidr(rve),tab,tempav,tab,ntactz(rve)
          else
            write(AUnit(rve),613) timer(rve),tab,
     x              defout(1,1),tab,defout(2,2),tab,defout(3,3),tab,
     x              defout(1,2),tab,defout(1,3),tab,defout(2,3),tab,
     x              stress(1,1,rve),tab,stress(2,2,rve),tab,
     x              stress(3,3,rve),tab,
     x              (stress(1,2,rve) + stress(2,1,rve))/2.d0,tab,
     x              (stress(1,3,rve) + stress(3,1,rve))/2.d0,tab,
     x              (stress(2,3,rve) + stress(3,2,rve))/2.d0,tab,
     x              chia1(rve),tab,chia2,tab,psi(rve),tab,
     x              ntacts(rve),tab,
     x              fab1(1,1),tab,fab1(2,2),tab,fab1(3,3),tab,
     x              fab1(1,2),tab,fab1(1,3),tab,fab1(2,3),tab,
     x              fab2(1,1),tab,fab2(2,2),tab,fab2(3,3),tab,
     x              fab2(1,2),tab,fab2(1,3),tab,fab2(2,3),tab,
     x              vfab,tab,voidn(rve),tab,e_eff,tab,
     x              knrgy(rve),tab,pnrgy(rve),tab,slidet(rve),tab,
     x              viscbt(rve),tab,
     x              viscct(rve),tab,work1t(rve),tab,nslide(rve),tab,
     x              nnear(rve),tab,solidr(rve),tab,
     x              tempav,tab,ntactz(rve),tab,
     x              pfluid(rve),tab,defw(rve),tab,fpnrgy(rve),
     x              tab,spnrgy(rve),tab,S_now(rve)
          endif
        endif
c
c-------Output information written to the "B*" file
        write(BUnit(rve),500) 
     1  timer(rve),defout(1,1),defout(2,2),defout(3,3),
     1    knrgy(rve),ntacts(rve),
     2  chia1(rve),defout(1,2),defout(1,3),defout(2,3),pnrgy(rve),
     3  chia2,stress(1,1,rve),stress(2,2,rve),stress(3,3,rve),
     3    slidet(rve),
     4  chia3,(stress(1,2,rve) + stress(2,1,rve))/2.d0,
     4    (stress(1,3,rve) + stress(3,1,rve))/2.d0,
     4    (stress(2,3,rve) + stress(3,2,rve))/2.d0,
     4    work1t(rve),
     5  chia4,psi(rve),viscbt(rve),viscct(rve),xloops
      elseif(ndim1.eq.2.and.lABfile) then
c-----Output for 2D assemblies
c
c-------Output information written to the "A*.txt" file
        write(AUnit(rve),601) timer(rve),tab,
     x            defout(1,1),tab,defout(2,2),tab,defout(1,2),tab,
     x            stress(1,1,rve),tab,stress(2,2,rve),tab,
     x            (stress(1,2,rve) + stress(2,1,rve))/2.d0,tab,
     x            chia1(rve),tab,chia2,tab,psi(rve),tab,
     x            ntacts(rve),tab,
     x            fab1(1,1),tab,fab1(1,2),tab,fab1(2,2),tab,
     x            fab2(1,1),tab,fab2(1,2),tab,fab2(2,2),tab,vfab,tab,
     x            lfaces(rve),tab,medges(rve),tab,nverts(rve),tab,
     x            voidn(rve),tab,e_eff,tab,
     x            knrgy(rve),tab,pnrgy(rve),tab,
     x            slidet(rve),tab,viscbt(rve),tab,
     x            viscct(rve),tab,work1t(rve),tab,
     x            nslide(rve),tab,nnear(rve),
     x            tab,solidr(rve),tab,ntactz(rve)
c
c-------Output information written to the "B*" file
          write(BUnit(rve),510)
     1    timer(rve),defout(1,1),defout(2,2),defout(1,2),
     1      knrgy(rve),ntacts(rve),
     2    chia1(rve),stress(1,1,rve),stress(2,2,rve),
     2      (stress(1,2,rve) + stress(2,1,rve))/2.d0,
     2      pnrgy(rve),psi(rve),
     3    chia2,chia3,chia4,viscbt(rve),
     x      slidet(rve),work1t(rve),xloops
        endif
      endif
c
      if(lporo(rve).and.lABfile) then
c-------when pore fluid pressures are included, write information about the
c       fluid pressure (pfluid), the fluid inflow (the difference of the
c       Jacobian of the bulk, skeletal deformation tensor and the Jacobian
c       of the pore fluid deformation), the elastic energy of the
c       pore fluid (fpnrgy), the elastic energy of the grains due 
c       to the pore (spnrgy), and the current saturation (S_now)
c       fluid pressure
c
        write(BUnit(rve),514) 
     x    pfluid(rve), defw(rve), fpnrgy(rve), spnrgy(rve),
     x    S_now(rve)
      endif
c
c-----reset parameters for determining when to report results again
      if(ipoint(rve).ge.ipts(istep(rve),rve)
     x  .or. timer(rve).le.0.) then
        ipoint(rve) = 0
      endif
c
      lreprt(rve) = .false.
c
      return
c
  300 format(i5,1pe11.4,i5,i6,i8,0pf6.1,3(1pe10.2),0pf6.2)
  301 format(i5,1pe11.4,i5,i6,i8,0pf6.1,3(1pe10.2),0pf7.3)
  302 format(/,'  Initial number of contacts       =',i8,
     x       /,'  Average ratio of ovrlap/diameter =',1pe11.3)
  303 format(/,'Some diagnostic information during this simulation:',
     x       /,' iout     timer  istep nupd   ipt2',
     x         '  xloops   chi1  ','    chi2   ','    psi    sweep')
  304 format(i7,1pe13.6,i8,i6,i8,0pf6.1,3(1pe10.2),0pf7.3)
c
  500 format(1pe14.7,1x,4(1pe14.6),i7
     2 ,/,1pe15.2,3(1pe14.6),1pe19.11
     3 ,/,1pe15.2,3(1pe14.6),1pe19.11
     4 ,/,1pe15.2,3(1pe14.6),1pe19.11
     5 ,/,1pe15.2,1pe14.2,2(1pe14.6),0pf14.2)
  510 format(
     1       1pe14.7,1x,4(1pe14.6),i9
     2 ,/,2x,1pe9.2,4x,4(1pe14.6),1pe9.2
     3 ,/,2x,3(1pe9.2),3(1pe14.6),0pf9.2)
c 512 format(1pe14.7,1x,3(1pe14.6),i9
c    2 ,/,1x,4(1pe14.6),1x,a4
c    3 ,/,1x,4(1pe14.6),1x,a4
c    4 ,/,1x,4(1pe14.6),1x,a4
c    5 ,/,1x,4(1pe14.6),1x,a4
c    6 ,/,1x,4(1pe14.6),1x,a4
c    7 ,/,1x,4(1pe14.6),1x,a4
c    8 ,/,1x,4(1pe14.6),1x,a4
c    9 ,/,1x,4(1pe14.6),1x,a4
c    x ,/,1x,4(1pe14.6),1x,a4
c    1 ,/,1x,4(1pe14.6),1x,a4
c    2 ,/,1x,4(1pe14.6),1x,a4
c    3 ,/,1x,4(1pe14.6),1x,a4
c    4 ,/,1x,4(1pe14.6),1x,a4
c    5 ,/,1x,4(1pe14.6),1x,a4
c    6 ,/,1x,4(1pe14.6),1x,a4
c    7 ,/,1x,4(1pe14.6),1x,a4
c    8 ,/,1x,4(1pe14.6),1x,a4
c    9 ,/,1x,4(1pe14.6),1x,a4
c    x ,/,1x,4(1pe14.6),1x,a4
c    1 ,/,1x,4(1pe14.6),1x,a4
c    2 ,/,1x,4(1pe10.2),i9
c    3 ,/,1x,4(1pe14.6)
c    4 ,/,1x,2(1pe14.6))
  514 format(5x,2(1pe14.6),2(1pe15.7),1pe16.9)
c
c 520 format(1pe14.7,1x,4(1pe14.6),i7
c    2 ,/,1pe15.7,4(1pe14.6),0pf8.1
c    3 ,/,1pe15.2,4(1pe14.6),0pf6.2
c    4 ,/,1pe15.2,4(1pe14.6),0pf6.1
c    5 ,/,1x,3(1pe14.2),2(1pe14.6),1pe9.1)
c 521 format(
c    6    1x,3(1pe14.6)
c    7 ,/,1x,3(1pe14.6)
c    8 ,/,1x,3(1pe14.6)
c    9 ,/,1x,3(1pe14.6)
c    x ,/,1x,3(1pe14.6)
c    1 ,/,1x,3(1pe14.6))
c 522 format(
c    2    1x,3(1pe14.6)
c    3 ,/,1x,3(1pe14.6)
c    4 ,/,1x,3(1pe14.6)
c    5 ,/,1x,3(1pe14.6)
c    6 ,/,1x,3(1pe14.6)
c    7 ,/,1x,3(1pe14.6))
c 523 format(1pe14.7,1x,i8,1x,i8)
c
c-----note that I have embedded a tab character behind the '1h' Hollerith
c     specifier
c
c-----forget that last comment.  Now tab characters are inserted with
c     with the "tab" variable in "a1" format
  600 format(1pe15.8,15(a1,1pe19.11),
     x               1(a1,i7),
     x               21(a1,1pe19.11),
     x               2(a1,i7),
     x               1(a1,1pe19.11),
     x               1(a1,i7))
  601 format(1pe15.8,9(a1,1pe14.6),
     x               1(a1,i7),
     x               7(a1,1pe14.6),
     x               3(a1,i7),
     x               8(a1,1pe14.6),
     x               2(a1,i7),
     x               1(a1,1pe15.7),
     x               1(a1,i7))
c 602 format(1pe15.8,15(a1,1pe19.11),
c    x               1(a1,i7),
c    x               21(a1,1pe19.11),
c    x               2(a1,i7),
c    x               1(a1,1pe19.11),
c    x               12(a1,1pe19.11),
c    x               1(a1,i7),2(a1,1pe19.11),
c    x               1(a1,i7))
  603 format(1pe15.8,15(a1,1pe19.11),
     x               1(a1,i7),
     x               21(a1,1pe19.11),
     x               2(a1,i7),
     x               2(a1,1pe19.11),
     x               1(a1,i7))
  610 format(1pe15.8,15(a1,1pe19.11),
     x               1(a1,i7),
     x               21(a1,1pe19.11),
     x               2(a1,i7),
     x               1(a1,1pe19.11),
     x               1(a1,i7),
     x               5(a1,1pe19.11))
c 612 format(1pe15.8,15(a1,1pe19.11),
c    x               1(a1,i7),
c    x               21(a1,1pe19.11),
c    x               2(a1,i7),
c    x               1(a1,1pe19.11),
c    x               12(a1,1pe19.11),
c    x               1(a1,i7),2(a1,1pe19.11),
c    x               1(a1,i7),
c    x               5(a1,1pe19.11))
  613 format(1pe15.8,15(a1,1pe19.11),
     x               1(a1,i7),
     x               21(a1,1pe19.11),
     x               2(a1,i7),
     x               2(a1,1pe19.11),
     x               1(a1,i7),
     x               4(a1,1pe19.11))
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine fabrik(fab1,fab2,fabsub,vfab,e_eff,
     x                  ntact2,ntact3,ntacsb,rve)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain,ipt1,ipt3,jgrain,min1,ntacsb,ntact2,ntact3
c
        double precision e_eff,fab1,fab2,fabsub,favg,fmag,fsq,
     x                   lensq,rxcntr,
     x                   v_eff,vfab,xcellq,xp1,xp2
c
        dimension fab1(3,3),fab2(3,3),fabsub(3,3),
     x            rxcntr(3),
     x            xcellq(3,3),xcellqi(3,3),xp1(3),xp2(3)
c
c-------initialize the number of contacts in the assembly that have met
c       a certain stability requirement
        ntact2 = 0
c
c-------the number of contacts that have more than the average contact force
        ntact3 = 0
c
c-------the number of contacts on submerged particle(s)
        ntacsb = 0
c
c-------initialize the fabric tensors
        do 10 i=1,3
          do 12 j=1,3
            fab1(i,j) = 0.
            fab2(i,j) = 0.
            fabsub(i,j) = 0.
            xcellq(i,j) = xcell(i,j,rve)
            xcellqi(i,j) = xcelli(i,j,rve)
   12     continue
   10   continue
c
        if(ndim1.eq.2) then
          fab1(3,3) = 1.d0
          fab2(3,3) = 1.d0
          fabsub(3,3) = 1.d0
        endif
c
c-------the minimum number of contacts on a particle for the contact
c       to be included as an effective contacts
        if(ndim1.eq.2) then
          min1 = 2
        elseif(ndim1.eq.3) then
          min1 = 3
        endif
c
c-------the mean (root mean square) contact force
        favg = sqrt(ftsq(rve) / ntacts(rve))
c
c-------the volume of stress-carrying network of particles
        v_eff = 0.
c
c-------compute the fabric tensor by searching through the linked list
c       of near neighbors for all of the contacts
        do 400 igrain = 1,np(rve)
c
c---------to calculate the "effective void ratio", we must identify those
c         particles that are part of the stress-carrying network, and then
c         find their combined volume
          if(nabors(igrain,rve).ge.min1) then
            v_eff = v_eff + v_p(igrain,rve)
          endif 
c
          ipt1 = igrain
          do 410 while (list2(ipt1,rve).ne.0)
            ipt1 = list2(ipt1,rve)
            if(liste(ipt1,rve).ne.0) then
              ipt3 = liste(ipt1,rve)
              jgrain = list1(ipt1,rve)
c
c-------------now that we have identified the contact 'ipt3', check each
c             of the two particles ('igrain' and 'jgrain') to see if
c             each particle has a minimum number of contacts (at least
c             2 contacts for 2D; at least 3 contacts for 3D).
              if(nabors(igrain,rve).ge.min1 .and.
     x           nabors(jgrain,rve).ge.min1      ) then
c
                ntact2 = ntact2 + 1
c---------------we have a legitimate contact.  So include it in the
c               fabric tensor
c
c---------------find the branch vector that joins the centers of the two
c               particles
                xp1(1) = xp(1,igrain,rve)
                xp1(2) = xp(2,igrain,rve)
                xp1(3) = xp(3,igrain,rve)
                xp2(1) = xp(1,jgrain,rve)
                xp2(2) = xp(2,jgrain,rve)
                xp2(3) = xp(3,jgrain,rve)
c
c---------------determine the components of the branch vector
                call bran(xp1,xp2,xcellq,xcellqi,ndim1,rxcntr)
c
c---------------the length of the branch vector.  Use this length to
c               compute the components of the unit vector aligned with
c               the branch vector.
                lensq = rxcntr(1)**2 + rxcntr(2)**2 + rxcntr(3)**2
c
c---------------compute the fabric tensor
                do  420 i = 1,ndim1
                  do 422 j = 1,ndim1
                    fab1(i,j) = fab1(i,j) + rxcntr(i)*rxcntr(j)/lensq
  422             continue
  420           continue
c
c---------------we now determine whether this contact force is greater
c               than the mean contact force.  We define the mean
c               as the square root of the mean squared contact force

c---------------for non-convex particles, a pair of touching particles can
c               have more than one contact.  We will not compute the second
c               fabric measure (fab2) for non-convex particles.  Only for
c               convex particles ...
                if(lconvx(rve)) then
                  fsq = fnold1(ipt3,rve)**2 +
     x                  ftold(1,ipt3,rve)**2 + ftold(2,ipt3,rve)**2
                  if(ndim1.eq.3) then
                    fsq = fsq + ftold(3,ipt3,rve)**2
                  endif
                  fmag = sqrt(fsq)
c
c-----------------does this contact have more than the average contact force?
                  if(fmag .gt. favg) then
                    ntact3 = ntact3 + 1
c
                    do  440 i = 1,ndim1
                      do 442 j = 1,ndim1
                        fab2(i,j) = fab2(i,j) +rxcntr(i)*rxcntr(j)/lensq
  442                 continue
  440               continue
                  endif
                endif
              endif
            endif
  410     continue
  400   continue
c
        do 450 i = 1,ndim1
          do 452 j = 1,ndim1
            if(ntact2.gt.0) then
c-------------the Satake fabric tensor, where we divide by the total number
c             of contacts in the assembly
              fab1(i,j) = fab1(i,j) / ntact2
c
c-------------the Antony "strong" fabric tensor, where we divide the sum of
c             tensors for the heavily loaded (strong) contacts by the total
c             number of contacts
              fab2(i,j) = fab2(i,j) / ntact2
            endif
c
            if(ntacsb.gt.0) then
c-------------the fabric tensor of the submerged particle(s)
              fabsub(i,j) = fabsub(i,j) / ntacsb
            endif
  452     continue
  450   continue
c
        if(ntact2.gt.0) then
          vfab = dble(ntact3) / dble(ntact2)
        else
          vfab = 0.
        endif
c
c
c-------the void ratio
        voidn(rve) = (vcell(rve) - vso(rve))/vso(rve)
c
c-------solids fraction
        solidr(rve) = 1.d0/(1.d0 + voidn(rve))
c
c-------the effective void ratio
        if(v_eff.gt.0.) then
          e_eff = (vcell(rve) - v_eff) / v_eff
        else
          e_eff = 0.
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine bran(xp1,xp2,xcell,xcelli,ndim1,rxcntr)
c
c-------find the branch vector that joins the centers of two particles
c
        double precision rcells,rxcntr,xp1,xp2,xcell,xcelli
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 ndim1,nintx
c
        dimension nintx(3),rcells(3),rxcntr(3),
     x            xp1(3),xp2(3),xcell(3,3),xcelli(3,3)
c
        rcells(1) = 0.
        rcells(2) = 0.
        rcells(3) = 0.
c
        rxcntr(3) = 0.
        do 30 k = 1,ndim1
c---------the relative positions of the two spheres
          rxcntr(k) = xp2(k) - xp1(k)
c
c---------the number of periodic cell boundaries between the
c         particle pair (for example, when the pair straddles a
c         periodic boundary)
          do 31 l = 1,ndim1
            rcells(l) = rcells(l) + xcelli(l,k)*rxcntr(k)
   31     continue
   30   continue
c
        do 137 k = 1,ndim1
          nintx(k) = nint(rcells(k))
  137   continue
c
        do 33 k = 1,ndim1
          do 34 l = 1,ndim1
            rxcntr(k) = rxcntr(k) - xcell(k,l)*nintx(l)
   34     continue
   33   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine dumpin(rve,filename,extent)
c
c-----this subroutin reads a restart file, so that the initial condition
c     will be the same as that at the end of a previous run
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,i4hold,igrain,k4,lim1,lim2,lim3,
     x          mfirso,mpi,mlisto,njlist,nlistJ
      integer*4 ishort, listk, listJ
c
      integer*2 extent,ilists,iremov,ishape,islip2,rve,TempUnit
c
      logical lhold
      double precision dhold
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 pnrgy1o,RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
      character*800 filename
c
      parameter(mhold=10)
c
c-----these arays are just "place holders" in the input file, for use
c     as future flags
      dimension i2hold(mhold),i4hold(mhold),lhold(mhold),dhold(mhold),
     x          rhold(mhold)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      TempUnit = 10 + 5*rve + 0
c
c     open(unit=TempUnit,file=file2(rve),
c    x     form='unformatted',status='old')
c
      open(unit=TempUnit,file=filename,form='unformatted',status='old')
c
      read(unit=TempUnit)
     x   np(rve),np2,ndim1,ndim2,ntacts(rve)
     x  ,icontr(0,rve),mpi,mfirso,mlisto
     x  ,iupdat(rve),ipt2,ipt4(rve),ihole(mrve),nupdat(rve)
     x  ,nsolve(rve),nfacts(rve),ioutd
     x  ,ilpavg
     x  ,ilpxcd,nsplin,nfit,ncells(rve)
     x  ,lbodyf,ldefrm,lanch(rve),ltrick,(ianch(i,rve),i=1,3)
     x  ,nbound(1),nbound(2),lcircl(rve),loval(rve),lelips(rve)
     x  ,lspher(rve),lovoid(rve)
     x  ,(i2hold(i),i=1,mhold),(i4hold(i),i=1,mhold)
     x  ,(lhold(i),i=1,mhold)
     x  ,(rhold(i),i=1,mhold),(dhold(i),i=1,mhold)
c
      lplatn = lhold(1)
      lwalls = lhold(2)
      lHertz(rve) = lhold(3)
      lJager(rve) = lhold(5)
c     lhold(6) is used to read 'workc'
c     lhold(7) is used to read 'lporo'
c
      imodel(rve) = i2hold(1)
      ishape = i2hold(2)
c-----older/newer versions of linked lists: ilists = 0/1/2
      ilists = i2hold(4)
c     i2hold(5) is used to read 'iporo'
c
c-----various contact force models
      lJagr2(rve) = imodel(rve) .eq. 7
      lJagr3(rve) = imodel(rve) .eq. 8
      lJagr4(rve) = imodel(rve) .eq. 9
      lsinh(rve) =  imodel(rve) .eq. 10
c
c-----unlike OVAL, the program DEMPLA only uses periodic boundaries
      if(nbound(1).ne.0 .or. nbound(2).ne.0) then
        print *,'  DEMPLA only allows periodic boundaries.'
        print *,
     x    '  The StartFile was created with non-periodic boundaries.'
        print *,'  Exiting DEMPLA now.'
        stop
      endif
c
c-----length of the Jager lists
      ishort = i4hold(1)
c
      if(i4hold(1).gt.mlistJ
     x   .and. (lJager(rve) .or. lJagr2(rve)
     x          .or. lJagr3(rve) .or. lJagr4(rve))) then
        write(ScrUnit(rve),901) i4hold(1),mlistJ
        write(ErrUnit(rve),901) i4hold(1),mlistJ
  901   format('Length of Jager lists in C-file (', i10, 
     x         ') exceeds mlistJ (', i10,').  Change mlistJ in the '
     x         'param-dempla-0.2.2.f file and in subroutin Jager3D.')
        stop
      endif
c
c-----check whether the parent run included pore fluid pressure,
c     but the current file has iporo=1.  This can lead to control
c     problems
      if(lhold(7) .and. iporo(rve).eq.0) then
          print *,' '
          print *,'**** Error in RunFile ****.'
          print *,'* The previous run had iporo=1, but the current run'
          print *,'* has iporo=0.  This can lead to control problems.'
          print *,'* Your value of iporo:',iporo(rve)
          stop
      endif
c
c-----check whether the parent run used the same pore fluid model.
c     For example if iporo=1 for the parent run and iporo=3 for the
c     current run, this mismatch can cause problems
      if(iporo(rve).ne.0 .and. iporo(rve).ne.i2hold(5)) then
          print *,' '
          print *,'**** Error in RunFile ****.'
          print *,'* The previous run had a different value of iporo'
          print *,'* than the current run.'
          print *,'* Parent value of iporo:',i2hold(5)
          print *,'* Your value for this run:',iporo(rve)
          stop
      endif
c
c-----whether to consolidate the Jager lists
      ishrtn(rve) = 0
c
c-----this code provides backward compatability with older code that did
c     not include non-convex nobby and bumpy shapes, so that the 
c     older C-files can still be read
      if(.not.lcircl(rve) .and. .not.loval(rve)
     x               .and. .not.lelips(rve) 
     x               .and. .not.lspher(rve)
     x               .and. .not.lovoid(rve)) then
        if(ishape.eq.6) then
c---------nobby shape
          lnobby(rve) = .true.
c---------nobby shapes are non-convex
          lconvx(rve) = .false.
        elseif(ishape.eq.7) then
c---------bumpy shape
          lbumpy(rve) = .true.
c---------nobby shapes are non-convex
          lconvx(rve) = .false.
        endif
      else
c-------all of the older shapes are convex
        lconvx(rve) = .true.
      endif
c
c-----check whether the program has been compiled for a sufficient
c     number of particles
      if(np(rve).gt.mp) then
        write(ScrUnit(rve),*) ' np exceeds mp in subroutin dumpin'
        write(ScrUnit(rve),*) '   (and param-dempla-0.2.2.f file)'
        write(ScrUnit(rve),*) ' Too many particles in the input file'
        write(ScrUnit(rve),*) ' Try changing mp and recompiling?'
        stop
      endif
c
c-----check whether the program has been compiled for a sufficient
c     number of particles
      if(np(rve).gt.mp) then
        write(ScrUnit(rve),*)
     x    ' np exceeds mp in the param-dempla-0.2.2.f file.'
        write(ScrUnit(rve),*)
     x    '   There are too many particles in the input file.'
        write(ScrUnit(rve),*)
     x    '   Recompile with a larger mp and try again.'
        stop
      elseif((loval(rve) .or. lovoid(rve))
     x       .and. 4*np(rve).gt.mpiece) then
        write(ScrUnit(rve),*)
     x    ' Ovals or ovoids are being used, but 4*np .gt. mpiece.'
        write(ScrUnit(rve),*)
     x    '   Recompile with a larger mpiece and try again.'
        stop
      endif
c
c-----number of "pieces" in composite particles
      if(lcircl(rve) .or. lspher(rve) .or. lelips(rve)) then
        npiecs(rve) = 1
      elseif(loval(rve)) then
        npiecs(rve) = 4
      elseif(lovoid(rve)) then
        npiecs(rve) = 3
      elseif(lnobby(rve).or.lbumpy(rve)) then
        npiecs(rve) = mlists
      endif
c
      lim1 = ipt2 - 1
      if(lconvx(rve) .and. ilists.eq.0) then
c-------convex particles with the older style of linked lists.
c       A maximum of one contact per particle pair.
c       "lim2" represents the maximum number of contacts.
        lim2 = ipt4(rve)
      else
c-------non-convex particles.  Possibly more than one contact per 
c       particle pair
        lim2 = mlist2
      endif
c
      lim3 = ihole(mrve)
c
      if(lhold(7)) then
        read(unit=TempUnit) icontp(0,rve)
      endif
c
      if(lhold(7)) then
        read(unit=TempUnit) (countr(i,rve),i=1,8)
      else
        read(unit=TempUnit) (countr(i,rve),i=1,6)
      endif
c
c     read(unit=TempUnit) (countr(i,rve),i=1,6)
c
      do 24 k4 = 0,(lim1-mfirso)/1000 - 1
        read(unit=TempUnit) (list1(i4,rve),
     x                i4=k4*1000+mfirso+1,(k4+1)*1000+mfirso)
   24 continue
      read(unit=TempUnit) 
     x       (list1(i4,rve),i4=((lim1-mfirso)/1000)*1000+mfirso+1,lim1)
c
      do 26 k4 = 0,(lim1+1)/1000 - 1
        read(unit=TempUnit) (list2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   26 continue
      read(unit=TempUnit) (list2(i4,rve),i4=((lim1+1)/1000)*1000,lim1)
c
      if(ilists.eq.0) then
        do 31 k4 = 0,(lim1-mfirso-1)/1000 - 1
         read(unit=TempUnit) (listb(i4,rve),
     x                 i4=mfirso+k4*1000+1,mfirso+(k4+1)*1000)
   31   continue
        read(unit=TempUnit) (listb(i4,rve),
     x                i4=mfirso+((lim1-mfirso-1)/1000)*1000+1,lim1)
      endif
c
      if(ilists.eq.0 .or. ilists.eq.1) then
        do 35 k4 = 0,lim3/1000 - 1
          read(unit=TempUnit) (hole(i4),i4=k4*1000+1,(k4+1)*1000)
   35   continue
        read(unit=TempUnit) (hole(i4),i4=(lim3/1000)*1000+1,lim3)
      endif
c
      do 25 j = -1,npiecs(rve)*npiecs(rve)
        do 27 k4 = 0,(lim1-mfirso)/1000 - 1
          read(unit=TempUnit)
     x     (list3(i4,j,rve),i4=k4*1000+mfirso+1,(k4+1)*1000+mfirso)
   27   continue
        read(unit=TempUnit)
     x   (list3(i4,j,rve),i4=((lim1-mfirso)/1000)*1000+mfirso+1,lim1)
   25 continue
c
      if(ilists.eq.1 .or. ilists.eq.2
     x   .or. (ilists.eq.0 .and. .not.lconvx(rve))) then
        do 64 k4 = 0,mlist2/1000 - 1
          read(unit=TempUnit) (liste(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (listf0(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (listf1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (listf2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   64   continue
        read(unit=TempUnit) (liste(i4,rve),
     x                       i4=(mlist2/1000)*1000,mlist2)
        read(unit=TempUnit) (listf0(i4,rve),
     x                       i4=(mlist2/1000)*1000,mlist2)
        read(unit=TempUnit) (listf1(i4,rve),
     x                       i4=(mlist2/1000)*1000,mlist2)
        read(unit=TempUnit) (listf2(i4,rve),
     x                       i4=(mlist2/1000)*1000,mlist2)
      endif
c
      read(unit=TempUnit)
     x  kn(rve),kratio(rve),pn(rve),dxym(rve),
     x  ftsq(rve),knrgyo(rve),
     x  pinit,po,bulkmi,gmod(rve),kbulk(rve),
     x  slidet(rve),work1t(rve),work2t,viscbt(rve),viscct(rve),
     x  treal(rve),dtreal(rve),dtrlo(rve),
     x  dtrl2s,treal1,powerm,chiavt,
     x  doubl2,gamma1,srint(rve),vcell0(rve),vcello(rve),
     x  (defup(i,rve),stranc(i,rve),i=1,3),
     x  (s(i,rve),streso(i,rve),str(i,rve),
     x   defv(i,rve),ddef(i,rve),i=1,8),
     x  ((xcell(i,j,rve),
     x    def(i,j,rve),stress(i,j,rve),strold(i,j,rve),i=1,3),j=1,3),
     x  ((defp(i,j),i=1,3),j=0,3),
     x  ((ddefme(i,j,rve),i=1,3),j=1,3),
     x  (ddefh(i,rve),i=1,3),
     x  ((xi(i,j,rve),i=1,nfacts(rve)+1),j=1,nfacts(rve)+1),
     x  ((yi(i,j,rve),i=1,nfacts(rve)+1),j=1,nsolve(rve)),
     x  ((dsfals(i,j,rve),i=1,nfacts(rve)),j=1,mstack),
     x  ((dsreal(i,j,rve),i=1,nsolve(rve)),j=1,mstack),
     x  (defrat(i,0,rve),i=1,8),(qdef(i,rve),i=1,8),
     x  defdot(0,rve)
c
      if(extent.eq.1) then
        goto 200
      endif
c
      if(lhold(6)) then
        read(unit=TempUnit) workc(rve),pnrgy2(rve),pnrgy1(rve),
     x                      knrgy(rve)
      endif
c
      if(lhold(7)) then
        read(unit=TempUnit) 
     x    p_o(rve), pfluid(rve), pfluido(rve), porosn(rve), 
     x    poros0(rve), defw(rve),
     x    strwold(rve), fpnrgy(rve), spnrgy(rve),
     x    ((stres0(i,j,rve),i=1,3),j=1,3),
     x    (streff(i,rve),strtot(i,rve),i=1,8)
      endif
c
      if(i2hold(5).eq.2) then
        read(unit=TempUnit) S_o(rve), p_atm(rve)
      elseif(i2hold(5).eq.3) then
        read(unit=TempUnit) S_o(rve), p_atm(rve), Hcc(rve), 
     x               gamm(rve), D_o(rve), Dlast(rve),
     x               N_o(rve), p_vap(rve), p_wcav(rve)
      endif
c
      if(i2hold(3).ge.1) then
        read(unit=TempUnit) pnrgy(rve)
        if(i2hold(3).ge.2) then
          read(unit=TempUnit) ovravg(rve)
          if(i2hold(3).ge.3) then
            read(unit=TempUnit) nupdat4(rve)
            if(i2hold(3).ge.4) then
              read(unit=TempUnit) ovrsav(rve),ovravgz(rve),ovrsavz(rve)
              read(unit=TempUnit) ntactz(rve)
            endif
          endif
        endif
      endif
c
      if(lHertz(rve) .or. lJager(rve)
     x   .or. lJagr2(rve) .or. lJagr3(rve) .or. lJagr4(rve)) then
        read(unit=TempUnit) G(rve), nu(rve)
        if(lJager(rve) .or. lJagr2(rve)
     x     .or. lJagr3(rve) .or. lJagr4(rve)) then
          pnrgy1o = pnrgy1(rve)
          pnrgy2o(rve) = pnrgy2(rve)
          pdifsv(rve) = pdif(rve)
          read(unit=TempUnit) pdif(rve), pdif2(rve), lApprox(rve)
        endif
        if(lJagr2(rve) .or. lJagr4(rve)) then
          read(unit=TempUnit) A_1(rve)
        endif
        if(lJagr4(rve)) then
           read(unit=TempUnit) palpha(rve)
        endif
      endif
c
      read(unit=TempUnit)
     x  ((deftot(i,j),defttn(i,j),defttt(i,j),
     x    deftt1(i,j),deftt2(i,j),deftt3(i,j),
     x    defclt(i,j),
     x    dstI(i,j),dstII(i,j),dstIIa(i,j),dstIIb(i,j),
     x    dstIIc(i,j),dstIId(i,j),
     x    dstIII(i,j),dstIIIa(i,j),dstIIIc(i,j),dstIIId(i,j),
     x    dstII1(i,j),dstII2(i,j),dstII3(i,j),dstII4(i,j),
     x    dstIII1(i,j),dstIII2(i,j),dstIII3(i,j),dstIII4(i,j),
     x                                         i=1,3),j=1,3)
c
      do 40 k4 = 0,np(rve)/1000 - 1
        read(unit=TempUnit) (rad(igrain,rve),
     x                       igrain=k4*1000+1,(k4+1)*1000)
   40 continue
      read(unit=TempUnit) (rad(igrain,rve),
     x              igrain=(np(rve)/1000)*1000+1,np(rve))
c
      do 50 j = 1,ndim1
        do 52 k4 = 0,np(rve)/1000 - 1
          read(unit=TempUnit) (xp(j,igrain,rve),
     x                         igrain=k4*1000+1,(k4+1)*1000)
          read(unit=TempUnit) (dx(j,igrain,rve),
     x                         igrain=k4*1000+1,(k4+1)*1000)
          read(unit=TempUnit) (vh(j,igrain,rve),
     x                         igrain=k4*1000+1,(k4+1)*1000)
   52   continue
        read(unit=TempUnit)
     x    (xp(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
        read(unit=TempUnit)
     x    (dx(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
        read(unit=TempUnit)
     x    (vh(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
   50 continue
c
      if(loval(rve) .or. lovoid(rve)) then
        read(unit=TempUnit) beta(rve)
      elseif(lnobby(rve)) then
        read(unit=TempUnit) nobs(rve)
        read(unit=TempUnit) satrad(rve),cenrad(rve)
      elseif(lbumpy(rve)) then
        read(unit=TempUnit) nbumps(rve)
        read(unit=TempUnit) satrad(rve),cenrad(rve),cirrad(rve)
      endif
c
      if(loval(rve) .or. lelips(rve)) then
        do 852 k4 = 0,np(rve)/1000 - 1
          read(unit=TempUnit)(aspect(igrain,rve),
     x                        igrain=k4*1000+1,(k4+1)*1000)
          read(unit=TempUnit)
     x      (theta(3,igrain,rve),igrain=k4*1000+1,(k4+1)*1000)
  852   continue
        read(unit=TempUnit)
     x    (aspect(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
        read(unit=TempUnit)
     x    (theta(3,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
      elseif(lnobby(rve)) then
        do 857 k4 = 0,np(rve)/1000 - 1
          read(unit=TempUnit)
     x      (theta(3,igrain,rve),igrain=k4*1000+1,(k4+1)*1000)
  857   continue
        read(unit=TempUnit)
     x    (theta(3,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
      elseif(lovoid(rve)) then
        do 853 k4 = 0,np(rve)/1000 - 1
          read(unit=TempUnit)(aspect(igrain,rve),
     x                        igrain=k4*1000+1,(k4+1)*1000)
  853   continue
        read(unit=TempUnit)
     x    (aspect(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
c
        do 854 j = 1,3
          do 855 k4 = 0,np(rve)/1000 - 1
            read(unit=TempUnit) (a_vect(j,igrain,rve),
     x                    igrain=k4*1000+1,(k4+1)*1000)
  855     continue
          read(unit=TempUnit)
     x      (a_vect(j,igrain,rve),
     x       igrain=(np(rve)/1000)*1000+1,np(rve))
  854   continue
      elseif(lbumpy(rve)) then
        do 858 j = 1,4
          do 859 k4 = 0,np(rve)/1000 - 1
            read(unit=TempUnit) (Qp(j,igrain,rve),
     x                    igrain=k4*1000+1,(k4+1)*1000)
  859     continue
          read(unit=TempUnit)
     x      (Qp(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
  858   continue
      endif
c
      do 54 j = ndim2,3
        do 56 k4 = 0,np(rve)/1000 - 1
          read(unit=TempUnit) (dth(j,igrain,rve),
     x                         igrain=k4*1000+1,(k4+1)*1000)
          read(unit=TempUnit) (vhth(j,igrain,rve),
     x                  igrain=k4*1000+1,(k4+1)*1000)
   56   continue
        read(unit=TempUnit)
     x      (dth(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
        read(unit=TempUnit)
     x      (vhth(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
   54 continue
c
      do 60 k4 = 0,lim2/1000 - 1
        do 63 i = 1,ndim1
          read(unit=TempUnit) (ftold(i,i4,rve),
     x                         i4=k4*1000,(k4+1)*1000-1)
   63   continue
        read(unit=TempUnit) (fnold1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   60 continue
c
      do 61 i = 1,ndim1
        read(unit=TempUnit) (ftold(i,i4,rve),i4=(lim2/1000)*1000,lim2)
   61 continue
      read(unit=TempUnit) (fnold1(i4,rve),i4=(lim2/1000)*1000,lim2)
c
      if(lsinh(rve)) then
        do 77 k4 = 0,lim2/1000 - 1
          read(unit=TempUnit) (dsold1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   77   continue
        read(unit=TempUnit) (dsold1(i4,rve),i4=(lim2/1000)*1000,lim2)
      endif
c
      if(lHertz(rve)) then
        do 71 k4 = 0,lim2/1000 - 1
          read(unit=TempUnit) (Tstar(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   71   continue
        read(unit=TempUnit) (Tstar(i4,rve),i4=(lim2/1000)*1000,lim2)
      elseif(lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)
     x       .or. lJagr4(rve)) then
        do 80 k4 = 0,lim2/1000 - 1
          read(unit=TempUnit) (listk(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   80   continue
        read(unit=TempUnit) (listk(i4,rve),i4=(lim2/1000)*1000,lim2)
c
        if(i4hold(1).ne.0) then
c---------the Jager lists have been shortened before storing them in
c         a "C" file
          njlist = i4hold(1)
        else
c---------for compatability with older versions of oval, we can read
c         unconsolidate lists
          njlist = mlistJ
        endif
c
        do 81 k4 = 0,njlist/1000 - 1
          read(unit=TempUnit) (listJ(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (zeta_s(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (Fn_s(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (p_s(i4,1,rve),i4=k4*1000,(k4+1)*1000-1)
          read(unit=TempUnit) (p_s(i4,2,rve),i4=k4*1000,(k4+1)*1000-1)
   81   continue
        read(unit=TempUnit) (listJ(i4,rve),
     x                       i4=(njlist/1000)*1000,njlist)
        read(unit=TempUnit) (zeta_s(i4,rve),
     x                       i4=(njlist/1000)*1000,njlist)
        read(unit=TempUnit) (Fn_s(i4,rve),i4=(njlist/1000)*1000,njlist)
        read(unit=TempUnit) (p_s(i4,1,rve),
     x                       i4=(njlist/1000)*1000,njlist)
        read(unit=TempUnit) (p_s(i4,2,rve),
     x                       i4=(njlist/1000)*1000,njlist)
c
        call dummmy(rve)
c
        if(.false.) then
c---------the following code produces segmentation fault failures.
          if(i4hold(1).ne.0) then
c-----------in newer versions, the Jager lists have been shortened.  We must
c           append links to complete the lists
            ishrtn(rve) = 0
c-----------complete the linked lists
            nlistJ = mlistJ
            call consol(rve,nlistJ)
          endif
        endif
c
        if(i4hold(1).ne.0) then
c---------if the lists have been shortened, then we must fill the
c         linked list "listJ" within subroutin consol
          ishrtn(rve) = 0
        endif
c
        if(ndim1.eq.3) then
          do 90 k4 = 0,lim2/1000 - 1
            do 91 i = 1,4
              read(unit=TempUnit) (Qc_old(i,i4,rve),
     x                             i4=k4*1000,(k4+1)*1000-1)
   91       continue
   90     continue
c
          do 92 i = 1,4
            read(unit=TempUnit) (Qc_old(i,i4,rve),
     x                           i4=(lim2/1000)*1000,lim2)
   92     continue
        endif
c
        do 93 k4 = 0,lim2/1000 - 1
          do 96 i = 1,3
            read(unit=TempUnit) (c_etas(i,i4,rve),
     x                           i4=k4*1000,(k4+1)*1000-1)
   96     continue
   93   continue
c
        do 95 i = 1,3
          read(unit=TempUnit) (c_etas(i,i4,rve),
     x                         i4=(lim2/1000)*1000,lim2)
   95   continue
c
        if(i4hold(2).ge.1) then
          lxiold(rve) = .true.
          do 97 k4 = 0,lim2/1000 - 1
            read(unit=TempUnit) (xi_old(1,i4,rve),
     x                           i4=k4*1000,(k4+1)*1000-1)
            read(unit=TempUnit) (xi_old(2,i4,rve),
     x                           i4=k4*1000,(k4+1)*1000-1)
   97     continue
          read(unit=TempUnit) (xi_old(1,i4,rve),
     x                         i4=(lim2/1000)*1000,lim2)
          read(unit=TempUnit) (xi_old(2,i4,rve),
     x                         i4=(lim2/1000)*1000,lim2)
        endif
      endif
c
c-----data for contact models other than the standard linear spring model
      if(imodel(rve).eq.1) then
        read(unit=TempUnit) mvers
        read(unit=TempUnit) nsepf(0)
        read(unit=TempUnit) (psep(i,0),i=0,lc2)
        read(unit=TempUnit) (pforce(i,0),i=0,lc2)
      elseif(imodel(rve).eq.2) then
        read(unit=TempUnit) mvers
        read(unit=TempUnit) ndiams(rve)
        read(unit=TempUnit) (sepdia(i),i=0,ndiams(rve)-1)
        read(unit=TempUnit) (nsepf(i),i=0,ndiams(rve)-1)
        read(unit=TempUnit) ((psep(i,j),i=0,lc2),j=0,ndiams(rve)-1)
        read(unit=TempUnit) ((pforce(i,j),i=0,lc2),j=0,ndiams(rve)-1)
      elseif(imodel(rve).eq.3) then
        read(unit=TempUnit) psep1(rve),psep2(rve),knseph(rve)
        read(unit=TempUnit) (ifn_togl(i4,rve),i4=(lim2/1000)*1000,lim2)
      endif
c
c-----if the input dump file used the older style linked lists,
c     convert from older to newer styles of linked lists.  This
c     is done to maintain backward compatability
      if(ilists.eq.0) then
        call convrt(rve)
      endif
c
  200 continue
c
c-----In general, the file unit=1 is for temporary input or output, and it
c     is closed immediately after its use
      close(unit=TempUnit)
c
c-----oops!  A correction to determine "kshape" from dumpin data
      call findk(kshape(rve), lcircl(rve), loval(rve),lelips(rve),
     x           lspher(rve), 
     x           lovoid(rve), lnobby(rve), lbumpy(rve))
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine dumpot(rve)
c
c-----this subroutin creates a file of the simulation configuration 
c     at the end a run (or even within the middle of a run, using the 
c     input "idump").  
c
c     The file can either be an simple ASCI listing of particle
c     radii and positions, or a complete binary "restart" file.  This
c     binary file permits a new run to continue exactly where this run
c     ended.
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 ilists,iremov,islip2,rve,TempUnit
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,i4hold,igrain,istm,k4,lim1,lim2,lim3,
     x          mf1,mp1,mlist1,njlist
      integer*4 listk, listJ, nlistJ
c
      logical lhold
      double precision degrad,dhold,theto
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
      parameter(mhold=10)
c
c-----these arays are just "place holders" in the output file, for use
c     as future flags
      dimension i2hold(mhold),i4hold(mhold),lhold(mhold),dhold(mhold),
     x          rhold(mhold),theto(3)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----explanation of iend and idump values:
c        1 = D-file output
c        2 = memory clone to another rve
c        3 = C-file output
c        4 = D-file output after calling subroutin stratn
c        5 = memory clone to another rve after calling subroutin stratn
c        6 = C-file output after calling subroutin stratn
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      TempUnit = 10 + 5*rve + 0
c
c-----initialize "place holder" arrays
      do 2 i = 1,mhold
        i2hold(i) = 0
        i4hold(i) = 0
        lhold(i) = .false.
        rhold(i) = 0.
        dhold(i) = 0.d0
    2 continue
c
c-----insert values into the "place holder" arrays
      lhold(1) = lplatn
      lhold(2) = lwalls
      lhold(3) = lHertz(rve)
      lhold(4) = lconvx(rve)
      lhold(5) = lJager(rve)
c-----for backward compatability, to output 'workc'
      lhold(6) = .true.
      lhold(7) = lporo(rve)
c
c-----insert values into the "place holder" arrays
      i2hold(1) = imodel(rve)
      i2hold(2) = kshape(rve)
c-----set this value to 1, 2, 3, 4 to change to newer versions while
c     maintaining backward compatabililty
      i2hold(3) = 4
      i2hold(5) = iporo(rve)
c-----older/newer versions of linked lists: ilists = 0/1/2
      i2hold(4) = 2
      ilists = i2hold(4)
c
c-----for older versions i4hold(1)=0.  For newer version we will consolidate
c     the linked lists used with the Jager contact
      if(lJager(rve) .or. lJagr2(rve)
     x   .or. lJagr3(rve) .or. lJagr4(rve)) then
        ishrtn(rve) = 1
c-------shorten the linked lists
        nlistJ = mlistJ
        call consol(rve,nlistJ)
c
c-------pointer to the last data in the linked list.  The rest of the
c       linked list will point to available locations
        i4hold(1) = listJ(Zero,rve) - 1
c
        njlist = i4hold(1)
      endif
c
c-----a version number for oval
      i4hold(2) = 1
c
      if(iend(rve).eq.3 .or. iend(rve).eq.6 
     x   .or. idumpi(rve).eq.3 .or. idumpi(rve).eq.6) then
c-------create a restart file
c       lstratn = .false.
        ishrtn(rve) = 0
        if((iend(rve).eq.6 .or. idumpi(rve).eq.6)
     x     .and. (     lJager(rve) .or. lJagr2(rve)
     x            .or. lJagr3(rve) .or. lJagr4(rve))) then
c         lstratn = .true.
c---------straighten the Jager equivalent load history
          call stratn(rve)
          ishrtn(rve) = 1
c---------shorten the Jager equivalent load history
          nlistJ = mlistJ
          call consol(rve,nlistJ)
        endif
c
        idumpi(rve) = 0
c
        istm = min(istep(rve),istepm(rve),istepa(rve))
        mp1 = mp
        mf1 = mfirst
        mlist1 = mlist
        ltrick = .false.
        nfit = 0
        treal1 = 0.
c
        open(unit=TempUnit,file=apend(rve),form='unformatted')
c
        write(unit=TempUnit)
     x   np(rve),np2,ndim1,ndim2,ntacts(rve)
     x   ,icontr(istm,rve),mp1,mf1,mlist1
     x   ,iupdat(rve),ipt2,ipt4(rve),ihole(mrve),nupdat(rve)
     x   ,nsolve(rve),nfacts(rve),ioutd
     x   ,ilpavg
     x   ,ilpxcd,nsplin,nfit,ncells(rve)
     x   ,lbodyf,ldefrm,lanch(rve),ltrick,(ianch(i,rve),i=1,3)
     x   ,nbound(1),nbound(2),lcircl(rve),loval(rve),lelips(rve)
     x   ,lspher(rve),lovoid(rve)
     x   ,(i2hold(i),i=1,mhold),(i4hold(i),i=1,mhold)
     x   ,(lhold(i),i=1,mhold)
     x   ,(rhold(i),i=1,mhold),(dhold(i),i=1,mhold)
c
        lim1 = ipt2 - 1
c
        if(lconvx(rve) .and. ilists.eq.0) then
c---------convex particles. A maximum of one contact per particle pair.
c         "lim2" represents the maximum number of contacts.
          lim2 = ipt4(rve)
        else
c---------non-convex particles.  Possibly more than one contact per 
c         particle pair
          lim2 = mlist2
        endif
        lim3 = ihole(mrve)
c
c       write(unit=TempUnit) (countr(i,rve),i=1,6)
cporo
        if(lporo(rve)) then
          write(unit=TempUnit) icontp(istm,rve)
        endif
c
        if(lporo(rve)) then
          write(unit=TempUnit) (countr(i,rve),i=1,8)
        else
          write(unit=TempUnit) (countr(i,rve),i=1,6)
        endif
c
c-------throughout this subroutin, we only write 1000 records at a time,
c       since in some compiled code, writin errors will otherwise occur.
        do 24 k4 = 0,(lim1-mfirst)/1000 - 1
          write(unit=TempUnit) 
     x        (list1(i4,rve),i4=k4*1000+mfirst+1,(k4+1)*1000+mfirst)
   24   continue
        write(unit=TempUnit) 
     x       (list1(i4,rve),i4=((lim1-mfirst)/1000)*1000+mfirst+1,lim1)
c
        do 26 k4 = 0,(lim1+1)/1000 - 1
          write(unit=TempUnit) (list2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   26   continue
        write(unit=TempUnit) (list2(i4,rve),
     x                        i4=((lim1+1)/1000)*1000,lim1)
c
        do 25 j = -1,npiecs(rve)*npiecs(rve)
          do 27 k4 = 0,(lim1-mfirst)/1000 - 1
            write(unit=TempUnit)
     x       (list3(i4,j,rve),i4=k4*1000+mfirst+1,(k4+1)*1000+mfirst)
   27     continue
          write(unit=TempUnit)
     x     (list3(i4,j,rve),i4=((lim1-mfirst)/1000)*1000+mfirst+1,lim1)
   25   continue
c
        do 64 k4 = 0,mlist2/1000 - 1
          write(unit=TempUnit) (liste(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (listf0(i4,rve),
     x                          i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (listf1(i4,rve),
     x                          i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (listf2(i4,rve),
     x                          i4=k4*1000,(k4+1)*1000-1)
   64   continue
        write(unit=TempUnit) (liste(i4,rve),
     x                        i4=(mlist2/1000)*1000,mlist2)
        write(unit=TempUnit) (listf0(i4,rve),
     x                        i4=(mlist2/1000)*1000,mlist2)
        write(unit=TempUnit) (listf1(i4,rve),
     x                        i4=(mlist2/1000)*1000,mlist2)
        write(unit=TempUnit) (listf2(i4,rve),
     x                        i4=(mlist2/1000)*1000,mlist2)
c
        write(unit=TempUnit)
     x   kn(rve),kratio(rve),pn(rve),dxym(rve),
     x   ftsq(rve),knrgy(rve),
     x   pinit,po,bulkmi,gmod(rve),kbulk(rve),
     x   slidet(rve),work1t(rve),work2t,viscbt(rve),viscct(rve),
     x   treal(rve),dtreal(rve),
     x   dtrlo(rve),dtrl2s,treal1,powerm,chiavt,
     x   doubl2,gamma1,srint(rve),vcell0(rve),vcello(rve),
     x   (defup(i,rve),stranc(i,rve),i=1,3),
     x   (s(i,rve),streso(i,rve),str(i,rve),
     x    defv(i,rve),ddef(i,rve),i=1,8),
     x   ((xcell(i,j,rve),
     x     def(i,j,rve),stress(i,j,rve),
     x     strold(i,j,rve),i=1,3),j=1,3),
     x   ((defp(i,j),i=1,3),j=0,3),
     x   ((ddefme(i,j,rve),i=1,3),j=1,3),
     x   (ddefh(i,rve),i=1,3),
     x   ((xi(i,j,rve),i=1,nfacts(rve)+1),j=1,nfacts(rve)+1),
     x   ((yi(i,j,rve),i=1,nfacts(rve)+1),j=1,nsolve(rve)),
     x   ((dsfals(i,j,rve),i=1,nfacts(rve)),j=1,mstack),
     x   ((dsreal(i,j,rve),i=1,nsolve(rve)),j=1,mstack),
     x   (defrat(i,istm,rve),i=1,8),(qdef(i,rve),i=1,8),
     x   defdot(istm,rve)
c
        if(lhold(6)) then
          write(unit=TempUnit) workc(rve),
     x                  pnrgy2(rve),pnrgy1(rve),knrgy(rve)
        endif
c
cporo
        if(lporo(rve)) then
          write(unit=TempUnit) 
     x      p_o(rve), pfluid(rve), pfluido(rve), 
     x      porosn(rve), poros0(rve), defw(rve), 
     x      strwold(rve), fpnrgy(rve), spnrgy(rve),
     x      ((stres0(i,j,rve),i=1,3),j=1,3),
     x      (streff(i,rve),strtot(i,rve),i=1,8)
        endif
c
        if(iporo(rve).eq.2) then
          write(unit=TempUnit) S_o(rve), p_atm(rve)
        elseif(iporo(rve).eq.3) then
          write(unit=TempUnit) S_o(rve), p_atm(rve), Hcc(rve), 
     x                  gamm(rve), D_o(rve), Dlast(rve),
     x                  N_o(rve), p_vap(rve), p_wcav(rve)
        endif
c
        if(i2hold(3).ge.1) then
          write(unit=TempUnit) pnrgy(rve)
          if(i2hold(3).ge.2) then
            write(unit=TempUnit) ovravg(rve)
            if(i2hold(3).ge.3) then
              write(unit=TempUnit) nupdat4(rve)
              if(i2hold(3).ge.4) then
                write(unit=TempUnit) 
     x               ovrsav(rve),ovravgz(rve),ovrsavz(rve)
                write(unit=TempUnit) ntactz(rve)
              endif
            endif
          endif
        endif
c
        if(lHertz(rve) .or. lJager(rve)
     x     .or. lJagr2(rve) .or. lJagr3(rve) .or. lJagr4(rve)) then
          write(unit=TempUnit) G(rve), nu(rve)
          if(lJager(rve) .or. lJagr2(rve)
     x       .or. lJagr3(rve) .or. lJagr4(rve)) then
            write(unit=TempUnit) pdif(rve), pdif2(rve), lApprox(rve)
          endif
          if(lJagr2(rve) .or. lJagr4(rve)) then
            write(unit=TempUnit) A_1(rve)
          endif
          if(lJagr4(rve)) then
            write(unit=TempUnit) palpha(rve)
          endif
        endif
c
        write(unit=TempUnit)
     x    ((deftot(i,j),defttn(i,j),defttt(i,j),
     x      deftt1(i,j),deftt2(i,j),deftt3(i,j),
     x      defclt(i,j),
     x      dstI(i,j),dstII(i,j),dstIIa(i,j),dstIIb(i,j),
     x      dstIIc(i,j),dstIId(i,j),
     x      dstIII(i,j),dstIIIa(i,j),dstIIIc(i,j),dstIIId(i,j),
     x      dstII1(i,j),dstII2(i,j),dstII3(i,j),dstII4(i,j),
     x      dstIII1(i,j),dstIII2(i,j),dstIII3(i,j),dstIII4(i,j),
     x                                           i=1,3),j=1,3)
c
        do 40 k4 = 0,np(rve)/1000 - 1
          write(unit=TempUnit) (rad(igrain,rve),
     x                          igrain=k4*1000+1,(k4+1)*1000)
   40   continue
        write(unit=TempUnit)
     x    (rad(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
c
        do 50 j = 1,ndim1
          do 52 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (xp(j,igrain,rve),
     x                      igrain=k4*1000+1,(k4+1)*1000)
            write(unit=TempUnit) (dx(j,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
            write(unit=TempUnit) (vh(j,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
   52     continue
          write(unit=TempUnit)
     x      (xp(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
          write(unit=TempUnit)
     x      (dx(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
          write(unit=TempUnit)
     x      (vh(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
   50   continue
c
        if(loval(rve) .or. lovoid(rve)) then
          write(unit=TempUnit) beta(rve)
        elseif(lnobby(rve)) then
          write(unit=TempUnit) nobs(rve)
          write(unit=TempUnit) satrad(rve),cenrad(rve)
        elseif(lbumpy(rve)) then
          write(unit=TempUnit) nbumps(rve)
          write(unit=TempUnit) satrad(rve),cenrad(rve),cirrad(rve)
        endif
c
        if(loval(rve) .or. lelips(rve)) then
          do 852 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (aspect(igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
            write(unit=TempUnit) (theta(3,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
  852     continue
          write(unit=TempUnit) (aspect(igrain,rve),
     x                   igrain=(np(rve)/1000)*1000+1,np(rve))
          write(unit=TempUnit) (theta(3,igrain,rve),
     x                   igrain=(np(rve)/1000)*1000+1,np(rve))
        elseif(lnobby(rve)) then
          do 857 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (theta(3,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
  857     continue
          write(unit=TempUnit) (theta(3,igrain,rve),
     x                   igrain=(np(rve)/1000)*1000+1,np(rve))
        elseif(lovoid(rve)) then
          do 853 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (aspect(igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
  853     continue
          write(unit=TempUnit)
     x      (aspect(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
c
          do 854 j = 1,3
            do 855 k4 = 0,np(rve)/1000 - 1
              write(unit=TempUnit) (a_vect(j,igrain,rve),
     x                       igrain=k4*1000+1,(k4+1)*1000)
  855       continue
            write(unit=TempUnit) (a_vect(j,igrain,rve),
     x                     igrain=(np(rve)/1000)*1000+1,np(rve))
  854     continue
        elseif(lbumpy(rve)) then
          do 858 j = 1,4
            do 859 k4 = 0,np(rve)/1000 - 1
              write(unit=TempUnit) (Qp(j,igrain,rve),
     x                       igrain=k4*1000+1,(k4+1)*1000)
  859       continue
            write(unit=TempUnit)
     x        (Qp(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
  858     continue
        endif
c
        do 54 j = ndim2,3
          do 56 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (dth(j,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
            write(unit=TempUnit) (vhth(j,igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
   56     continue
          write(unit=TempUnit)
     x        (dth(j,igrain,rve),
     x         igrain=(np(rve)/1000)*1000+1,np(rve))
          write(unit=TempUnit)
     x        (vhth(j,igrain,rve),
     x         igrain=(np(rve)/1000)*1000+1,np(rve))
   54   continue
c
        do 60 k4 = 0,lim2/1000 - 1
          do 63 i = 1,ndim1
            write(unit=TempUnit) (ftold(i,i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   63     continue
          write(unit=TempUnit) (fnold1(i4,rve),
     x                          i4=k4*1000,(k4+1)*1000-1)
   60   continue
c
        do 61 i = 1,ndim1
          write(unit=TempUnit) (ftold(i,i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
   61   continue
        write(unit=TempUnit) (fnold1(i4,rve),i4=(lim2/1000)*1000,lim2)
c
        if(lsinh(rve)) then
          do 77 k4 = 0,lim2/1000 - 1
            write(unit=TempUnit) (dsold1(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   77     continue
          write(unit=TempUnit) (dsold1(i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
        endif
c
        if(lHertz(rve)) then
          do 71 k4 = 0,lim2/1000 - 1
            write(unit=TempUnit) (Tstar(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   71     continue
          write(unit=TempUnit) (Tstar(i4,rve),i4=(lim2/1000)*1000,lim2)
        elseif(lJager(rve) .or. lJagr2(rve)
     x         .or. lJagr3(rve) .or. lJagr4(rve)) then
          do 80 k4 = 0,lim2/1000 - 1
            write(unit=TempUnit) (listk(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   80     continue
          write(unit=TempUnit) (listk(i4,rve),i4=(lim2/1000)*1000,lim2)
c
          do 81 k4 = 0,njlist/1000 - 1
            write(unit=TempUnit) (listJ(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
            write(unit=TempUnit) (zeta_s(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
            write(unit=TempUnit) (Fn_s(i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
            write(unit=TempUnit) (p_s(i4,1,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
            write(unit=TempUnit) (p_s(i4,2,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   81     continue
          write(unit=TempUnit) (listJ(i4,rve),
     x                          i4=(njlist/1000)*1000,njlist)
          write(unit=TempUnit) (zeta_s(i4,rve),
     x                          i4=(njlist/1000)*1000,njlist)
          write(unit=TempUnit) (Fn_s(i4,rve),
     x                          i4=(njlist/1000)*1000,njlist)
          write(unit=TempUnit) (p_s(i4,1,rve),
     x                          i4=(njlist/1000)*1000,njlist)
          write(unit=TempUnit) (p_s(i4,2,rve),
     x                          i4=(njlist/1000)*1000,njlist)
c
          if(ndim1.eq.3) then
            do 90 k4 = 0,lim2/1000 - 1
              do 91 i = 1,4
                write(unit=TempUnit) (Qc_old(i,i4,rve),
     x                         i4=k4*1000,(k4+1)*1000-1)
   91         continue
   90       continue
c
            do 92 i = 1,4
              write(unit=TempUnit) (Qc_old(i,i4,rve),
     x                              i4=(lim2/1000)*1000,lim2)
   92       continue
          endif
c
          do 93 k4 = 0,lim2/1000 - 1
            do 96 i = 1,3
              write(unit=TempUnit) (c_etas(i,i4,rve),
     x                              i4=k4*1000,(k4+1)*1000-1)
   96       continue
   93     continue
c
          do 95 i = 1,3
            write(unit=TempUnit) (c_etas(i,i4,rve),
     x                            i4=(lim2/1000)*1000,lim2)
   95     continue
c
          do 97 k4 = 0,lim2/1000 - 1
            write(unit=TempUnit) (xi_old(1,i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
            write(unit=TempUnit) (xi_old(2,i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   97     continue
          write(unit=TempUnit) (xi_old(1,i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
          write(unit=TempUnit) (xi_old(2,i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
        endif
c
c-------data for contact models other than the standard linear spring or
c       Hertz models
        if(imodel(rve).eq.1) then
          write(unit=TempUnit) mvers
          write(unit=TempUnit) nsepf(0)
          write(unit=TempUnit) (psep(i,0),i=0,lc2)
          write(unit=TempUnit) (pforce(i,0),i=0,lc2)
        elseif(imodel(rve).eq.2) then
          write(unit=TempUnit) mvers
          write(unit=TempUnit) ndiams(rve)
          write(unit=TempUnit) (sepdia(i),i=0,ndiams(rve)-1)
          write(unit=TempUnit) (nsepf(i),i=0,ndiams(rve)-1)
          write(unit=TempUnit) ((psep(i,j),i=0,lc2),j=0,ndiams(rve)-1)
          write(unit=TempUnit)((pforce(i,j),i=0,lc2),j=0,ndiams(rve)-1)
        elseif(imodel(rve).eq.3) then
          write(unit=TempUnit) psep1(rve),psep2(rve),knseph(rve)
          write(unit=TempUnit) (ifn_togl(i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
        endif
c
c-------In general, the file unit=1 is for temporary input or output, and it
c       is closed immediately after its use
        close(unit=TempUnit)
c
      elseif(     iend(rve).eq.1 .or. iend(rve).eq.4 
     x       .or. idumpi(rve).eq.1 .or. idumpi(rve).eq.4) then
c-------we will create an output ASCI D-file that lists the particle sizes 
c       and positions.  See subroutin readit for a description of the 
c       data fields
c
c-------whether to stratn the Jager equivalent load history
        if((iend(rve).eq.4 .or. idumpi(rve).eq.4)
     x     .and. (     lJager(rve) .or. lJagr2(rve)
     x            .or. lJagr3(rve) .or. lJagr4(rve))) then
c         lstratn = .true.
c---------straighten the Jager equivalent load history
          call stratn(rve)
          ishrtn(rve) = 1
c---------shorten the Jager equivalent load history
          nlistJ = mlistJ
          call consol(rve,nlistJ)
        endif
c
        open(unit=TempUnit,file=apend(rve))
c
        write(TempUnit,300) kshape(rve)
        write(TempUnit,301) np(rve),(xcell(i,i,rve),i=1,3)
        write(TempUnit,303) xcell(1,2,rve),xcell(1,3,rve),
     x                      xcell(2,3,rve)
c
        if(loval(rve) .or. lovoid(rve)) then
          write(TempUnit,302) beta(rve)
        elseif(lnobby(rve)) then
c---------read the number of satellite circles that surround the central circle
          write(TempUnit,306) nobs(rve)
c---------satrad = (radius of satellite circles) / (input radius)
c         cenrad = (radius of central circle) / (input radius)
          write(TempUnit,302) satrad(rve),cenrad(rve)
        elseif(lbumpy(rve)) then
c---------read the number of satellite spheres that surround the central sphere
          write(TempUnit,306) nbumps(rve)
c---------satrad = (radius of satellite spheres) / (input radius)
c         cenrad = (radius of central sphere) / (input radius)
c         cirrad = (radius of circum-sphere) / (input radius)
          write(TempUnit,302) satrad(rve),cenrad(rve),cirrad(rve)
        endif
c
        if(lcircl(rve) .or. lspher(rve)) then
c---------for each of the (np) particles
          do 30 igrain = 1,np(rve)
            write(TempUnit,302) rad(igrain,rve),
     x                          (xp(j,igrain,rve),j=1,ndim1)
   30     continue
        elseif(loval(rve) .or. lelips(rve)) then
c
c---------Now, before writing the angle theta, convert it from
c         radians to degrees.  This will only be done with the "D"-style
c         text files.
c
          degrad = 180.d0/pi
c---------convert to degrees for the output "D" file
          do 46 igrain = 1,np(rve)
            do 48 k = ndim2,3
              theta(k,igrain,rve) = degrad*theta(k,igrain,rve)
   48       continue
   46     continue
c
          do 32 igrain = 1,np(rve)
c-----------in past versions, very small values of "theta" (for example, 
c           3.14e-323) would be improperly represented (as 3.14-323, with the
c           "e".  Now we just round these small values to zero.
            do 102 i = 1,3
              if(abs(theta(i,igrain,rve)) .lt. 1.0d-99) then
                theto(i) = 0.
              else
                theto(i) = theta(i,igrain,rve)
              endif
  102       continue
c
            write(TempUnit,302) rad(igrain,rve),aspect(igrain,rve),
     x                   (xp(j,igrain,rve),j=1,ndim1),
     x                   (theto(j),j=ndim2,3)
   32     continue
        elseif(lnobby(rve)) then
          degrad = 180.d0/pi
          do  37 igrain = 1,np(rve)
c-----------note the use of the range 1:ndim1, where ndim1 is the dimension
c           of the problem (ndim1=2 for 2D problems, ndim1=3 for 3D problems)
c
c-----------convert to degrees for the output "D" file
            do 137 k=ndim2,3
              theta(k,igrain,rve) = degrad*theta(k,igrain,rve)
  137       continue
c
c-----------in past versions, very small values of "theta" (for example, 
c           3.14e-323) would be improperly represented (as 3.14-323, with the
c           "e".  Now we just round these small values to zero.
            do 104 i = 1,3
              if(abs(theta(i,igrain,rve)) .lt. 1.0d-99) then
                theto(i) = 0.
              else
                theto(i) = theta(i,igrain,rve)
              endif
  104       continue
c
            write(TempUnit,302) rad(igrain,rve),
     x                   (xp(j,igrain,rve),j=1,ndim1),
     x                   (theto(j),j=ndim2,3)
   37     continue
        elseif(lovoid(rve)) then
c
c---------calculate the "gamma" orientation angles (in degrees) of the ovoids 
c         from the directions of the orientation vectors, a_vect
          call gammas(rve)
c
          do 69 igrain = 1,np(rve)
            write(TempUnit,305) rad(igrain,rve),aspect(igrain,rve),
     x                   (xp(j,igrain,rve),j=1,ndim1),
     x                   (gamma_(j,igrain,rve),j=1,2)
   69     continue
        elseif(lbumpy(rve)) then
c---------3D bumpy particles
c
c---------for each particle, read the following:
c           - rad, the reference radius, which will be used to scale 
c             the size of the particle
c           - xp, the position of the center of the particle
c           - Qp, quaternion that the gives the orientation of the particle
          do 327 igrain = 1,np(rve)
            write(TempUnit,302) rad(igrain,rve),
     x                   (xp(j,igrain,rve),j=1,3),
     x                   (Qp(j,igrain,rve),j=1,4)
  327     continue
        endif
c
c-------In general, the file unit=1 is for input or output within a
c        a program unit and the file is closed immediately after being used
        close(unit=TempUnit)
      endif
c
      return
c
  300 format(i1)
  301 format(i6,3(1pe25.17))
  302 format(   8(1pe25.17))
  303 format(6x,3(1pe25.17))
  305 format(   7(1pe25.17))
  306 format(i3)
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine locate(rve)
c
c-------This subroutin re-computes the centers of the pieces that comprise
c       a 4-arc oval, ellipse, or 3-piece ovoid.  It also recomputes the 
c       sines and cosines of the orientation angle.
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain
c
        double precision a_mag,adjust,a_temp,da
c
        dimension a_temp(3),da(3)
c
        if(loval(rve)) then
c---------for all of the (np) particles
          do 10 igrain = 1,np(rve)
c
c-----------compute and store the sine and cosine of the particle orientation
c           angle, so that they will not have to be continually recomputed in
c           other subroutins.  In some instances (for example, when the
c           assembly has no mean vorticity) there will be no change in the
c           theta angles and no need to recompute ctheta (ltheta = .false.)
            if(ltheta(rve)) then
c-------------compute the unit vector in the direction of the ovoid axis
              a_vect(1,igrain,rve) = -sin(theta(3,igrain,rve))
              a_vect(2,igrain,rve) =  cos(theta(3,igrain,rve))
            endif
   10     continue
        elseif(lelips(rve)) then
c---------for all of the (np) particles
          if(ltheta(rve)) then
c-----------compute and store the sine and cosine of the 
c           particle orientation angle, so that they will not have to 
c           be continually recomputed in other subroutins.
            do 20 igrain = 1,np(rve)
              ctheta(1,igrain,rve) = cos(theta(3,igrain,rve))
              ctheta(2,igrain,rve) = sin(theta(3,igrain,rve))
   20       continue
          endif
        elseif(lovoid(rve)) then
c
c---------initialize the change in the unit vector of the particle orientation
          da(1) = 0.
          da(2) = 0.
          da(3) = 0.
c
c---------for all of the (np) particles
          do 30 igrain = 1,np(rve)
c-----------compute and store the updated direction cosines of the unit vector
c           oriented in the direction of the ovoid axis.   The updated unit 
c           vector will be computed from the rotations dtheta, 
c           which are rotations with respect to the global x1-x2-x3 
c           coordinate system.
c
c           In some instances (for example, when the assembly has no mean 
c           vorticity) there will be no need to change the unit vectors
c           and no need to recompute the direction cosines ctheta 
c           (ltheta = .false.)
            if(ltheta(rve)) then
c-------------the change in the orientation vector "a" of the ovoid 
c             = dtheta X a (a cross product), where dthetat is the small 
c             rotation of the particle and "a" is a vector attached to 
c             the particle ("a" = "a_vect" is the direction of the ovoid axis)
c
              da(1) = ddth(2,igrain,rve)*a_vect(3,igrain,rve) -
     x                ddth(3,igrain,rve)*a_vect(2,igrain,rve)
              da(2) = ddth(3,igrain,rve)*a_vect(1,igrain,rve) -
     x                ddth(1,igrain,rve)*a_vect(3,igrain,rve)
              da(3) = ddth(1,igrain,rve)*a_vect(2,igrain,rve) -
     x                ddth(2,igrain,rve)*a_vect(1,igrain,rve)
c
c-------------add the change in the unit vector, "da", to the original
c             unit vector "a_vect".  Temporarily store the results as "a_temp"
              a_temp(1) = a_vect(1,igrain,rve) + da(1)
              a_temp(2) = a_vect(2,igrain,rve) + da(2)
              a_temp(3) = a_vect(3,igrain,rve) + da(3)
c
c-------------the length of the new vector "a_temp" will not be exactly 1.
c             Compute the squared length of "a_temp".
              a_mag = a_temp(1)**2 + a_temp(2)**2 + a_temp(3)**2
c
c-------------We will want to re-normalize a_temp = a_temp / sqrt(a_mag).
              adjust = sqrt(a_mag)
c
c-------------now renormalize a_temp = a_vect = a_temp / sqrt(a_mag) to
c             calculate the final value of vector "a"
              a_vect(1,igrain,rve) = a_temp(1) / adjust
              a_vect(2,igrain,rve) = a_temp(2) / adjust
              a_vect(3,igrain,rve) = a_temp(3) / adjust
c
              do 32 k = 1,3
c---------------we now increment the amount of rotational movement of this
c               particle since the last near-neighbor search (subroutin lister).
c               We are not interested in its revolving about its axis, only
c               in the rotation of the axis.  This sort of rotation, for 
c               example, might change some contacts from the torus piece to the 
c               spherical cap.  We will only compute an approximate 
c               rotation angle, which is represented by 
c               the "da" vector:
                thmove(k,igrain,rve) = thmove(k,igrain,rve) + da(k)
   32         continue
            endif
   30     continue
        endif
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine gammas(rve)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain
c
        double precision raddeg
c
c-------this subroutin computes the particle orientation angles, gamma_1 and
c       gamma_2 for ovoids.  The angle gamma_1 is measured from the x_3 axis 
c       to the particle axis (of revolution).  The angle gamma_2 is
c       measure CCW from the x_1 axis to the projection of the particle axis
c       (of revolution) onto the x_1-x_2 plane.
c
c-------the initial values of the angle are supplied with the input
c       StartFiles.  The subroutin "locate" computes the unit vector aligned
c       with the particle axis whenever the global orientation angles
c       theta_1, theta_2, and theta_3 are changed.
c
c-------there is really no need within the program to constantly update
c       the angles gamma_1 and gamma_2, as they are only of possible interest 
c       to the user, not by the DEM algorithm.  So this subroutin is 
c       only called prior to the creation of output data files.
c
c-------Note that the unit vector aligned with the particle axis is related
c       to the angles gamma_1 and gamma_2 as follows.
c
c                 sin(gamma_1) * cos(gamma_2)
c          [a] =  sin(gamma_1) * sin(gamma_2)
c                 cos(gamma_1)
c
c       This subroutin does the inverse mapping
c
c-------for converting from radians to degrees
        raddeg = 180.d0 / pi
c
c-------for all particles
        do 10 igrain = 1,np(rve)
c---------the angle from the x_3 axis to the particle axis (of revolution).
          gamma_(1,igrain,rve) = acos(a_vect(3,igrain,rve))
c
c---------the angle measured CCW from the x_1 axis to the projection 
c         of the particle axis (of revolution) onto the x_1-x_2 plane.
          gamma_(2,igrain,rve) =
     x      atan2(a_vect(2,igrain,rve),a_vect(1,igrain,rve))
c
c---------we will output the angles in degrees
          gamma_(1,igrain,rve) = raddeg * gamma_(1,igrain,rve)
          gamma_(2,igrain,rve) = raddeg * gamma_(2,igrain,rve)
   10   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer*2 function int2(i)
c-----This function converts a 4-byte integer to a 2-byte integer
        int2 = i
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer*4 function int4(i)
c-----This function converts a 2-byte integer to a 4-byte integer
        integer*2 i
        int4 = i
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine lister(rve,nnnear,nlist,nlist2,nlist3,nboxs)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      double precision a_i,a_j,betah,betahi,betal,betalo,
     x                 betar1,betar3,
     x                 c_eta,carea,cosbi,cosbj,cosx,ctheti,cthetj,
     x                 l_i,l_j,ovrlap,
     x                 p1_i,p1_j,p2_i,p2_j,pih,pi2,Qpi,
     x                 r1_i,r1_j,r2_i,r2_j,r_i,r_j,rad_i,rad_j,
     x                 ratioi,ratioj,rcells,rij,rijsq,rnear2,
     x                 Rot_i,Rot_j,
     x                 rradi,rradj,rsum,rx,rxcntr,
     x                 seprat,thetai,thetaj,tol,
     x                 x8,xbox,xboxi,
     x                 xcelp,xcelpi
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 box1,box2,box2k,i4,ibend,ibox,ibx,
     x          iflg,igrain,ilist1,ilist2,
     x          ipt1,ipt1a,ipt1b,ipt3,ipt5,iptbx,isweep,
     x          j4,jgrain,jlist1,jlist2,jpt1,jptbx,
     x          k4,kbox,kgrain,kpt1,list1o,list2o,listeo,
     x          m_i,m_j,
     x          nboxc,nboxs,nintx,
     x          nlist,nlist2,nlist3,nlistJ,nnlistj,
     x          nwmod4
      integer*4 listk, listJ, nvacant
c
      integer*2 irve,imrve,iremov,islip2,rve,nnnear
c
      logical lcatch,lcheck,ldbg,lexep,lgeom,lheadr,llist,
     x        lnear,lnr,lprev,lstrad,ltact,ltouch
c
      dimension a_i(3),a_j(3),
     x          betah(2),betahi(2),betal(2),betalo(2),
     x          cosbi(3),cosbj(3),cosx(3),c_eta(3),ctheti(3),cthetj(3),
     x          l_i(3),l_j(3),Qpi(4),
     x          Rot_i(3,3),Rot_j(3,3),
     x          xbox(3,3),xboxi(3,3),rcells(3),rxcntr(3),xcelp(3,3,1),
     x          xcelpi(3,3,1),rx(3)
c
      dimension box2(nboxs),ibend(nboxs),
     x          ibox(3),ilist1(nnnear),ilist2(nnnear),jlist1(nnnear),
     x          jlist2(nnnear),list1o(mfirst+1:nlist),list2o(0:nlist),
     x          list3o(mfirst+1:nlist,-1:nlist3),
     x          listeo(0:nlist2),
     x          nintx(3)
      dimension kmax(3),kmin(3)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----for debugging
      lcatch = .false.
c
      lexep = .false.
      lstrad = .false.
c
      pih = 0.5d0*pi
      pi2 = 2.0d0*pi
c
c-----initialize a few variables that will be passed to the subroutins 
c     ovals, ellips, and ovoids
c
c-----look for near-neighbors, just contacts
      lnr = .true.
c
c-----don't extract the contact geometry (subroutins ovoids, 
c     ellips, sphere, oval)
      lgeom = .false.
c
c-----the critical separation is non-zero (a near-neighbor search)
      seprat = sep(rve)
c
c-----initialize other variables that will be passed to and from
c     subroutins ovals, ellips, and ovoids
      lnear = .false.
      ltact = .false.
      ldbg = .false.
      do 1 i = 1,3
        a_i(i) = 0.
        a_j(i) = 0.
        cosx(i) = 0.
        ctheti(i) = 0.
        cthetj(i) = 0.
        c_eta(i) = 0.
        rx(i) = 0.
        l_i(i) = 0.
        l_j(i) = 0.
    1 continue
      rij = 0.
      rradi = 0.
      rradj = 0.
      p1_i = 0.
      p1_j = 0.
      p2_i = 0.
      p2_j = 0.
      r1_i = 0.
      r1_j = 0.
      r2_i = 0.
      r2_j = 0.
      isweep = 0
      tol = tolrnc(2,rve)
      m_i = 0
      m_j = 0
c
c-----the number of times the linked list has been updated
      nupdat4(rve) = nupdat4(rve) + 1
c
c-----has the linked list already been updated?
      lprev = nupdat4(rve).gt.1
c
c-----the first position in the linked list of near neighbors
      ipt2 = np(rve) + 1
c
c-----if the simulation has just begun, then empty all of the linked lists
      if(nupdat4(rve).le.1) then
        do 20 i4 = 1,mholes
          hole(i4) = 0
   20   continue
c
        do 22 i4 = mfirst+1,mlist
          list1(i4,rve) = 0
   22   continue
c
        do 24 i4 = 0,mlist
          list2(i4,rve) = 0
   24   continue
c
        do 28 i4 = 0,mlist2
          do 29 i = 1,ndim1
            ftold(i,i4,rve) = 0.
            l_i_old(i,i4,rve) = 0.
   29     continue
          fnold1(i4,rve) = 0.
          lplold(i4,rve) = .false.
c
          islip(i4,rve) = 0
c
          if(imodel(rve).eq.3) then
            ifn_togl(i4,rve) = 0
          elseif(lHertz(rve)) then
            Tstar(i4,rve) = 0.
          endif
c
          if(lsinh(rve)) then
            dsold1(i4,rve) = 0.
          endif
c
c---------store these values for use in output to F-files
          if(ndim1.eq.2) then
            branch(1,i4,rve) = 0.
            branch(2,i4,rve) = 0.
            c_etas(1,i4,rve) = 0.
            c_etas(2,i4,rve) = 0.
            cosxl(1,i4,rve) = 0.
            cosxl(2,i4,rve) = 0.
            f1(i4,rve) = 0
            f2(i4,rve) = 0
            p1(i4,rve) = 0
            p2(i4,rve) = 0
            v1(i4,rve) = 0
            v2(i4,rve) = 0
          endif
c
c---------store information for use in the Jager algorithm for contact force
          if(lJager(rve) .or. lJagr2(rve)
     x       .or. lJagr3(rve) .or. lJagr4(rve)) then
            c_etas(1,i4,rve) = 0.
            c_etas(2,i4,rve) = 0.
            c_etas(3,i4,rve) = 0.
            if(l3d) then
              Qc_old(1,i4,rve) = 0.
              Qc_old(2,i4,rve) = 0.
              Qc_old(3,i4,rve) = 0.
              Qc_old(4,i4,rve) = 0.
            endif
            xi_old(1,i4,rve) = 0.
            xi_old(2,i4,rve) = 0.
          endif
c
c---------with 4-arc ovals, initialize the particular arcs that are
c         touching.  This "quad" matrix is not actually used within the
c         program Oval, but is passed to a G-file for input to OvalPlot
          if(loval(rve)) then
            quad(1,i4,rve) = 0
            quad(2,i4,rve) = 0
          endif
   28   continue
c
        if(lJager(rve) .or. lJagr2(rve)
     x     .or. lJagr3(rve) .or. lJagr4(rve)) then
c---------with a generalized Hertz-Mindlin contact, we must track the 
c         loading history as an equivalent load path.  Initialize the arrays
c         that hold this history
c
          do 53 i4 = 0,mlist2
c-----------array of pointers to the locations within the link-list,
c           listJ, for the load path informatio of individual contacts
            listk(i4,rve) = Zero
c
c-----------information about recent updates that are passed between
c           subroutins forces and Jager_3d
            iremov(i4,rve) = 0
            RJag(i4,rve) = 0.
            zeta_o(i4,rve) = 0.
            zeta_s0(i4,rve) = 0.
            zeta_s1(i4,rve) = 0.
            Fn_o(i4,rve) = 0.
            Fn_s0(i4,rve) = 0.
            Fn_s1(i4,rve) = 0.
            p_s0(i4,1,rve) = 0.
            p_s0(i4,2,rve) = 0.
            islip(i4,rve) = 0
   53     continue
c
          do 55 i4 = 0,mlistJ
c-----------contact properties along the load paths
            zeta_s(i4,rve) = 0.
            Fn_s(i4,rve) = 0.
            p_s(i4,1,rve) = 0.
            p_s(i4,2,rve) = 0.
   55     continue
c
          do 57 i4 = 1,mlistJ
c-  --------link-list for the load path
            listJ(i4-1,rve) = i4
   57     continue
c
c---------a flag on the last available space
          listJ(mlistJ,rve) = -1
        endif
c
c-------for a given pair of touching particles, this list "liste" points
c       the header location within "listf0" that gives the positions of
c       contact information within fnold1, listf1, ftold, listJ, etc.
        do 31 i4 = 0,mlist2
          liste(i4,rve) = 0
          listf1(i4,rve) = 0
          listf2(i4,rve) = 0
   31   continue
c
        do 43 i4 = 1,mlist2
          listf0(i4-1,rve) = i4
   43   continue
        listf0(mlist2,rve) = -1
      elseif(.false.) then
c-------consolidate the linked lists used with the Jager contact
        if(lJager(rve) .or. lJagr2(rve)
     x     .or. lJagr3(rve) .or. lJagr4(rve)) then
          ishrtn(rve) = 1
c---------shorten the linked lists
          nlistJ = mlistJ
          call consol(rve,nlistJ)
c
c---------check whether the cumulative contact movement have been input
c         with a C-file
          if(.not.lxiold(rve)) then
c-----------initialize the cumulative contact movement
            do 743 i4 = 1,mlist2
              xi_old(1,i4,rve) = 0.
              xi_old(2,i4,rve) = 0.
  743       continue
          endif
        endif
      endif
c
c-----since the linked list of near-neighbors will be rearranged, 
c     store the original contents of the lists, so that the list of 
c     contact force can be be referenced to the new linked list of 
c     near-neighbors
      do 70 i4 = 0,mlist
        list2o(i4) = list2(i4,rve)
        list2(i4,rve) = 0
   70 continue
c
c-----store other values in the original linked lists, as these values
c     will need to be restored after newly rearranging the lists.
      do 80 i4 = mfirst+1,mlist
        list1o(i4) = list1(i4,rve)
        list1(i4,rve) = 0
        do 89 i = -1,mlist3
          list3o(i4,i) = list3(i4,i,rve)
   89   continue
c
        list3(i4,0,rve) = 0
        list3(i4,-1,rve) = 1
c
        do 87 i = 1,mlist3
          list3(i4,i,rve) = 0
   87   continue
   80 continue
c
c-----pointers to contact information
      do 83 i4 = 0,mlist2
        listeo(i4) = liste(i4,rve)
        liste(i4,rve) = 0
   83 continue
c
      do 81 i = 1,3
        do 82 j = 1,3
          xcelp(i,j,1) = xcell(i,j,rve)
   82   continue
   81 continue
c
c-----some basic housekeeping:  with periodic boundaries, place particles 
c     back inside the main periodic cell.  Note that this is a "false" 
c     choice, since resetting the particle locations will cause problems
c     in the porgram OvalPlot when trying to plot the change in position
c     between two states
      if(.false.) then
        do 35 igrain = 1,np(rve)
          do 33 k = 1,ndim1
            rcells(k) = 0.
   33     continue
c
          do 36 k = 1,ndim1
c---------the number of periodic cell boundaries to the particle
c           (for example, when the pair straddles a periodic boundary)
            do 37 l = 1,ndim1
              rcells(l) = rcells(l) + xcelli(l,k,rve)*xp(k,igrain,rve)
   37       continue
   36     continue
c
          do 38 k = 1,ndim1
            if(rcells(k).ge.0.) then
              nintx(k) = int(rcells(k))
            else
              nintx(k) = int(rcells(k)) - 1.d0
            endif
   38     continue
c
          do 39 k = 1,ndim1
            do 47 l = 1,ndim1
              x8 = xcell(k,l,rve)*nintx(l)
              xp(k,igrain,rve) = xp(k,igrain,rve) - x8
   47       continue
   39     continue
   35   continue
      endif
c
      n = 3
      irve = 0
      imrve = 0
      call definv(xcelp,xcelpi,n,irve,imrve)
c
c-----partition the entire assembly into a grid of boxes
c
c-----in subroutin lister, the assembly is divided into gridded
c     system of "cells" (boxes).  The time to search for near-neighbors 
c     (i.e. potentially contacting particles) is greatly reduced by 
c     searching for near-neighbors only among neighboring cells.
c
c-----initialize the number of cells in each coordinate direction.
c     We use two criteria for establishing the number of cells in each
c     direction:
c       1) placing about "nperb" particles within each cell
c       2) not having two particles (separated by the threshold search
c          distance) straddle more than two cells
c
c-----criteria (1): placing about "nperb" particles within each cell
      nperb = 5
c
c-----criteria (2): not having the distance "rserch" straddle 
c     more than two cells
      rserch = 2.d0*rmax2(rve) + sep(rve)
c
c-----roughly the total number of cells
      xboxes = nint(dble(np(rve)) / nperb)
c
      volum = 1.d0
      do 30 i = 1,ndim1
        volum = volum * xcelp(i,i,1)
   30 continue
c
      do 32 i = 1,ndim1
c-------criteria (1): the number of cells in each coordinate direction
        nbox(i,rve) = nint(xcelp(i,i,1)*
     x                 (dble(xboxes) / volum)**(1.d0/dble(ndim1)))
c
c-------criteria (2):
        nbox(i,rve) = min(nbox(i,rve),int(xcelp(i,i,1)/rserch))
c
        if(nbox(i,rve).eq.0) then
          write(ScrUnit(rve),*)
     x      'There are too few particles in this assembly for ',
     x      'a near-neighbor search strategy to work.'
          write(ScrUnit(rve),*) 'See subroutin lister.'
          stop
        endif
   32 continue
c
      if(ndim1.eq.2) then
c-------initialize for 2D assemblies
        nbox(3,rve) = 1
        ibox(3) = 0
      endif
c
c-----determine the number of neighboring cells that will be searched in
c     each coordinate direction.  For very small assemblies, with just
c     one or two cells in any direction, we must be sure that we don't
c     "wrap" around the periodic boundary to search in the identical cell
      do 49 i = 1,3
        if(nbox(i,rve).le.2) then
          kmin(i) = 0
        else
          kmin(i) = -1
        endif
c
        if(nbox(i,rve).le.1) then
          kmax(i) = 0
          if(nbox(i,rve).eq.0) then
            write(ScrUnit(rve),*)
     x        'Oops! What happened here? Zero grids in the ',
     x              'near-neighbor search?!'
            stop
          endif
        else
          kmax(i) = 1
        endif
   49 continue
c
      nboxes(rve) = nbox(1,rve)*nbox(2,rve)*nbox(3,rve)
      if(nboxes(rve).gt.mboxes) then
        write(ScrUnit(rve),*)
     x    ' nboxes exceeds mboxes in subroutin lister'
        write(ScrUnit(rve),*)
     x    ' nboxes =',nboxes(rve),'  mboxes =',mboxes
        write(ScrUnit(rve),*)
     x    ' Try increasing mboxes and recompiling?'
        stop
      endif
c
c-----check whether the parameters mobx* have been exceeded.  These parameters
c     are used in the 'common' file to dimension certain arrays.
      if(nbox(1,rve).gt.mbox1) then
        write(ScrUnit(rve),*)
     x    ' nbox(1) is greater than mbox1 in subroutin lister'
        write(ScrUnit(rve),*)
     x    ' Try increasing mbox1 in param-dempla-0.2.2.f and'
        write(ScrUnit(rve),*) ' recompiling?'
        write(ScrUnit(rve),*) ' nbox(1) =',nbox(1,rve)
        write(ScrUnit(rve),*) ' mbox1   =',mbox1
        stop
      elseif(nbox(2,rve).gt.mbox2) then
        write(ScrUnit(rve),*)
     x    ' nbox(2) is greater than mbox2 in subroutin lister'
        write(ScrUnit(rve),*)
     x    ' Try increasing mbox2 in param-dempla-0.2.2.f and'
        write(ScrUnit(rve),*) ' recompiling?'
        write(ScrUnit(rve),*) ' nbox(2) =',nbox(2,rve)
        write(ScrUnit(rve),*) ' mbox2   =',mbox2
        stop
      elseif(nbox(3,rve).gt.mbox3) then
        write(ScrUnit(rve),*)
     x    ' nbox(3) is greater than mbox3 in subroutin lister'
        write(ScrUnit(rve),*)
     x    ' Try increasing mbox3 in param-dempla-0.2.2.f and'
        write(ScrUnit(rve),*)
     x    ' recompiling?'
        write(ScrUnit(rve),*)
     x    ' nbox(3) =',nbox(3,rve)
        write(ScrUnit(rve),*)
     x    ' mbox3   =',mbox3
        stop
      endif
c
c-----the dimensions of the boxes
      do 90 i = 1,3
        do 92 j = 1,3
          xbox(i,j) = xcelp(i,j,1) / nbox(j,rve)
          xboxi(i,j) = xcelpi(i,j,1) * nbox(i,rve)
   92   continue
   90 continue
c
      nboxes(rve) = 0
c
c-----deterrmine the total number of cells (boxes) and assign invertible
c     mappings between the box number and the box coordinates
      do 100 i = 0,nbox(1,rve)-1
        do 110 j = 0,nbox(2,rve)-1
          do 120 k = 0,nbox(3,rve)-1
            nboxes(rve) = nboxes(rve) + 1
c
c-----------assign indices to each cell along the x, y, and z axes
            box(i,j,k,rve) = nboxes(rve)
c
c-----------assign inverse indices to each cell along the x, y, and z axes
            boxi(nboxes(rve),1,rve) = i
            boxi(nboxes(rve),2,rve) = j
            boxi(nboxes(rve),3,rve) = k
  120     continue
  110   continue
  100 continue
c
c-----now, place each particle (and its component pieces) into a cell.
c
c-----initialize the linked lists that will be used to keep track of
c     which balls are in each box.  Empty the linked list.
      ibx = mboxes
      do 300 i4 = 1,mbx
        iptbx1(i4,rve) = 0
  300 continue
c
      do 302 i4 = mboxes+1,mbx
        iptbx2(14,rve) = 0
  302 continue
c
c-----a pointer to the tail of the list for each cell
      do 304 i4 = 1,nboxes(rve)
        ibend(i4) = i4
  304 continue
c
c-----place each particle within a cell along with its place in the
c     linked list
      do 150 igrain = 1,np(rve)
c-------use integer and modulo arithmetic to find which cell the particle
c       "igrain" belongs to
        do 160 i = 1,ndim1
          rcells(i) = 0.
          do 162 j = 1,ndim1
            rcells(i) = rcells(i) + xboxi(i,j)*xp(j,igrain,rve)
  162     continue
  160   continue
c
c-------compute the integer coordinates of particle "igrain" within
c       the grid system
        do 170 i = 1,ndim1
          if(rcells(i) .lt. 0.) then
c-----------a correction to the manner in which the fortran 77 intrinsic
c           function "int" works
            ibox(i) = int(rcells(i)) - 1
          else
            ibox(i) = int(rcells(i))
          endif
c
c         ibox(i) = modulo(ibox(i),nbox(i,rve))
          ibox(i) = nwmod4(ibox(i),nbox(i,rve))
  170   continue
c
c-------the cell to which "igrain" belongs.  ibox(1),ibox(2),ibox(3) are
c       x1, x2, and x3 integer coordinates of the grid system
        box1 = box(ibox(1),ibox(2),ibox(3),rve)
c
c-------now we know that particle "igrain" belongs to box1.  Place igrain 
c       into the linked list of box1.
c
c-------append the list pointer
        ibx = ibx + 1
        iptbx1(ibend(box1),rve) = ibx
        ibend(box1) = ibx
c
c-------link to the particle
        iptbx2(ibend(box1),rve) = igrain
  150 continue
c
      if(ibx.gt.mbx) then
        write(ScrUnit(rve),*) 'ibx exceeded mbx in subroutin lister'
        stop
      endif
c
c-----an angle used for computing whether the overlap between two
c     component pieces actually occurs within the span of the pieces
      if(loval(rve) .or. lovoid(rve)) then
        betar1 = min(pih,betar(rve)+sep(rve)/rpcmin(rve))
        betar3 = max(0.d0,betar(rve)-sep(rve)/rpcmin(rve))
        betah(1) = cos(betar1)
        betah(2) = sin(betar1)
        betal(1) = cos(betar3)
        betal(2) = sin(betar3)
      endif
c
c-----with Hertz-type contacts, we may need to gather
c     information about overlaps at the beginning of a
c     simulation
      if(linitc(rve)) then
        ntacts(rve) = 0
        ovravg(rve) = 0.
      endif
c
c-----now investigate the contents of each box, and search for near-neighbors
c     with the other particles in that cell and also with particles in the
c     surrounding boxes
      do 200 box1 = 1,nboxes(rve)
        kbox = 0
        nboxc = 0
c
c-------determine which boxes surround "box1"
        do 210 i4 = kmin(1),kmax(1)
          do 212 j4 = kmin(2),kmax(2)
            do 214 k4 = kmin(3),kmax(3)
              kbox = kbox + 1
              nboxc = nboxc + 1
              box2(kbox) =box(nwmod4(boxi(box1,1,rve)+i4,nbox(1,rve)),
     x                        nwmod4(boxi(box1,2,rve)+j4,nbox(2,rve)),
     x                        nwmod4(boxi(box1,3,rve)+k4,nbox(3,rve)),
     x                        rve)
  214       continue
  212     continue
  210   continue
c
c-------look at each particle in the "box1"
        iptbx = iptbx1(box1,rve)
        do 220 while(iptbx.ne.0)
          igrain = iptbx2(iptbx,rve)
          iptbx = iptbx1(iptbx,rve)
c
          ipt1 = igrain
c
c---------with 3D bumpy particles, use their orientation quaternions to
c         find the particles' rotation matrices.  These matrices will be
c         be used to convert local coordinates of the particle components
c         into the global system coordinates.  This will be required 
c         during contact detection.
          if(lbumpy(rve)) then
            Qpi(1) = Qp(1,igrain,rve)
            Qpi(2) = Qp(2,igrain,rve)
            Qpi(3) = Qp(3,igrain,rve)
            Qpi(4) = Qp(4,igrain,rve)
c
c-----------this subroutin uses the quaternion "Qp" to find the corresponding
c           rotation 3x3 matrix
            call QRotationMatrix(Qpi,Rot_i)
          endif
c
c---------look at each of the surrounding boxes
          do 222 kbox = 1,nboxc
c-----------the second box
            box2k = box2(kbox)
c
c-----------look at each particle within a surrounding box
            jptbx = iptbx1(box2k,rve)
            do 230 while(jptbx.ne.0)
              jgrain = iptbx2(jptbx,rve)
              jptbx = iptbx1(jptbx,rve)
c
c-------------check whether the two particles are in proximity (near-neighbors)
c
c-------------we are producing a SINGLY connected link list, so we only
c             consider the case of igrain < jgrain
c
              if(igrain .lt. jgrain) then
c
c-------------do not look for near neighbors with a flat wall, unless
c             the 1st particle (igrain) lies in the same box as the wall
              if(.true.) then
c---------------the list of near-neighbor component pieces (for ovals and
c               ovoids) has not yet been added for this particle pair.
                lheadr = .true.
c
c---------------now check whether the two particles are in proximity
                do 251 k = 1,ndim1
                  rxcntr(k) = xp(k,jgrain,rve) - xp(k,igrain,rve)
  251           continue
c
c---------------if the particles are in two cells that straddle a 
c               periodic boundary, then find the nearest image
                do 258 k = 1,ndim1
                  rcells(k) = 0.
  258           continue
c
c---------------find the distance between image particles, in the event
c               that the two particles lie on opposite sides of a
c               periodic boundary
                do 260 k = 1,ndim1
                  do 262 l = 1,ndim1
                    rcells(l) = rcells(l) + xcelli(l,k,rve)*rxcntr(k)
  262             continue
  260           continue
c
                do 264 k = 1,ndim1
                  nintx(k) = nint(rcells(k))
  264           continue
c
                do 270 k = 1,ndim1
                  do 272 l = 1,ndim1
                    rxcntr(k) = rxcntr(k) - xcell(k,l,rve)*nintx(l)
  272             continue
  270           continue
c
                rijsq = 0.
                do 271 k = 1,ndim1
c-----------------square of the distance between particle centers
                  rijsq = rijsq + rxcntr(k)**2
  271           continue
c
c---------------the sum of the radii of the two particles.  We will later use
c               this sum to check whether the two particles should be checked
c               more closely for whether they are near neighbors
                if(lcircl(rve).or.lspher(rve)) then
                  rsum = rad(igrain,rve) + rad(jgrain,rve)
                elseif(lelips(rve)) then
c-----------------the sum of the maximum dimensions of the two particles
                  rsum = rad(igrain,rve)*max(1.d0,aspect(igrain,rve))+
     x                   rad(jgrain,rve)*max(1.d0,aspect(jgrain,rve))
                elseif(loval(rve).or.lovoid(rve)) then
c-----------------dimensions of the component pieces of the two particles
                  r1_i = r_piec(1,igrain,rve)
                  r1_j = r_piec(1,jgrain,rve)
                  r2_i = r_piec(2,igrain,rve)
                  r2_j = r_piec(2,jgrain,rve)
                  p1_i = r_piec(3,igrain,rve)
                  p1_j = r_piec(3,jgrain,rve)
                  p2_i = r_piec(4,igrain,rve)
                  p2_j = r_piec(4,jgrain,rve)
c
c-----------------the sum of the maximum dimensions of the two particles
                  rsum = max(r1_i + p1_i, r2_i + p2_i) +
     x                   max(r1_j + p1_j, r2_j + p2_j)
                elseif(lnobby(rve) .or. lbumpy(rve)) then
c-----------------sum of the maximum radii of the two particles
                  rsum = rout(rve)*(rad(igrain,rve) +rad(jgrain,rve))
                endif
c
c---------------we will check whether the two particles are within the
c               separation distance "sep" from each other.  If so,
c               they may be added to the linked list of near-neighbors
                rnear2 =(rsum + sep(rve))**2
c
c---------------first, just a rough check to see if the larger dimensions
c               of each particle could be within distance "sep"
                if(rijsq.lt.rnear2) then
c-----------------these particles are possibly near-neighbors
c
                  if(loval(rve) .or. lovoid(rve)) then
c-------------------with composite particles (such as ovals and ovoids), we must
c                   identify certain geometric parameters for the several 
c                   component pieces of each particle
c
c-------------------prepare data to pass to subroutins "ovals" or "ovoids",
c                   which will check whether the particles are contacting.
c                   The array a_vect( , ) contains the unit orientation vectors
c                   for all particles.  Just pass the 4 or 6 values that 
c                   are needed for the two particles:
                    a_i(1) = a_vect(1,igrain,rve)
                    a_i(2) = a_vect(2,igrain,rve)
                    a_j(1) = a_vect(1,jgrain,rve)
                    a_j(2) = a_vect(2,jgrain,rve)
c
c-------------------an extra component for 3D particles
                    if(lovoid(rve)) then
                      a_i(3) = a_vect(3,igrain,rve)
                      a_j(3) = a_vect(3,jgrain,rve)
                    endif
c
c-------------------sines and cosines of limiting "beta" angles for the
c                   near-neighbor search
                    betahi(1) = betah(1)
                    betalo(1) = betal(1)
                    betahi(2) = betah(2)
                    betalo(2) = betal(2)
                  elseif(lnobby(rve)) then
c-------------------radii of the two particles
                    r_i = rad(igrain,rve)
                    r_j = rad(jgrain,rve)
c
c-------------------orientation cosines of the two particles
                    cosbi(1) = cos(theta(3,igrain,rve))
                    cosbi(2) = sin(theta(3,igrain,rve))
                    cosbj(1) = cos(theta(3,jgrain,rve))
                    cosbj(2) = sin(theta(3,jgrain,rve))
                  elseif(lbumpy(rve)) then
c-------------------radii of the two particles
                    r_i = rad(igrain,rve)
                    r_j = rad(jgrain,rve)
c
c-------------------with 3D bumpy particles, use their orientation quaternions
c                   to find the particles' rotation matrices.  These matrices
c                   will be be used to convert local coordinates of the 
c                   particle components into the global system coordinates.
c                   This will be required during contact detection.
                    Qpi(1) = Qp(1,jgrain,rve)
                    Qpi(2) = Qp(2,jgrain,rve)
                    Qpi(3) = Qp(3,jgrain,rve)
                    Qpi(4) = Qp(4,jgrain,rve)
c
c-------------------this subroutin uses the quaternion "Qp" to find the 
c                   corresponding rotation 3x3 matrix
                    call QRotationMatrix(Qpi,Rot_j)
                  endif
c
c-----------------now check all of the component pieces of each particle
c                 to see which pairs of component pieces are near-neighbors
                  do 450 ipc = 1,njoin(rve)
c-------------------check all component pieces of particle "igrain"
c
c-------------------the index of the particular component piece of 
c                   particle "igrain"
                    m_i = ipc - 1
                    do 452 jpc = 1,njoin(rve)
c---------------------check all component pieces of particle "jgrain"
c
c---------------------the index of the particular component piece of 
c                     particle "jgrain"
                      m_j = jpc - 1
c
                      if(linitc(rve)) then
c-----------------------with Hertz-type contacts, we may need to gather
c                       information about overlaps at the beginning of a
c                       simulation
                        seprat = 0.
                        lgeom = .true.
c
c-----------------------sines and cosines of limiting "beta" angles for
c                       contact search.  Use the true values
                        betahi(1) = cbeta(1,rve)
                        betahi(2) = cbeta(2,rve)
                        betalo(1) = cbeta(1,rve)
                        betalo(2) = cbeta(2,rve)
                      else
c-----------------------otherwise, relax parameters for a near-neighbor search
c
c-----------------------the critical separation is non-zero (a near-neighbor 
c                       search)
                        seprat = sep(rve)
c
c-----------------------sines and cosines of limiting "beta" angles for the
c                       near-neighbor search with oval and ovoid particles
                        betahi(1) = betah(1)
                        betalo(1) = betal(1)
                        betahi(2) = betah(2)
                        betalo(2) = betal(2)
                      endif
c
                      if(lcircl(rve).or.lspher(rve)) then
c
c-----------------------but check whether the two particles are touching
                        r_i = rad(igrain,rve)
                        r_j = rad(jgrain,rve)
                        call sphere(r_i,r_j,rxcntr,seprat,ndim1,lexep,
     x                         lgeom,c_eta,ovrlap,l_i,l_j,carea,ltact)
c
c-----------------------are the two particles are near-neighbors?
                        lnear = ltact
                        ltact = .false.
                      elseif(loval(rve)) then
c-----------------------prepare data to pass to subroutin "ovals", which
c                       will check whether the particles are contacting.
c
c-----------------------numbering scheme for the arcs within the igrain:
c                         0 and 2 for the larger radius arcs (top and bottom),
c                         1 and 3 for the smaller radius arcs (right and left)
c                       so that numbering is from 0 to 3, clockwise around 
c                       the oval
c
c-----------------------determine whether the ovals are near-neighbors
                        call ovals(a_i,a_j,betahi,betalo,
     1                       p1_i,p1_j,p2_i,p2_j,
     2                       r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                       seprat,
     3                       m_i,m_j,lgeom,
     4
     5                       c_eta,ovrlap,l_i,l_j,ltact)
c
c-----------------------are the two particles are near-neighbors?
                        lnear = ltact
                        ltact = .false.
c
                      elseif(lnobby(rve)) then
c-----------------------nobby particles
c
c-----------------------establish whether contact has occured, and if so,
c                       compute various auxilary quantities
                        call nobby(r_i,r_j,cenrad(rve),satrad(rve),
     2                             rxcntr,cosa,cosbi,cosbj,
     3                             m_i,m_j,lgeom,lexep,seprat,
     x                             lhiddn(rve),
     4
     5                             c_eta,ovrlap,l_i,l_j,ltact,
     6                             rve, mrve)
c
c-----------------------are the two particles are near-neighbors?
                        lnear = ltact
                        ltact = .false.
                      elseif(lelips(rve)) then
c-----------------------prepare arguments to be passed to subroutin ellips
                        ctheti(1) = ctheta(1,igrain,rve)
                        ctheti(2) = ctheta(2,igrain,rve)
                        cthetj(1) = ctheta(1,jgrain,rve)
                        cthetj(2) = ctheta(2,jgrain,rve)
                        rradi = rad(igrain,rve)
                        rradj = rad(jgrain,rve)
                        thetai = theta(3,igrain,rve)
                        thetaj = theta(3,jgrain,rve)
                        ratioi = aspect(igrain,rve)
                        ratioj = aspect(jgrain,rve)
                        rx(1) = rxcntr(1)
                        rx(2) = rxcntr(2)
                        rx(3) = 0.
c
c-----------------------establish whether contact has occured.  The subroutin 
c                       ellips will also compute the amount of overlap 
c                       and information concerning the location of the 
c                       contact point
                        lnr = .true.
                        call ellips(lnear,
     x                       ltact,ovrlap,c_eta,rad_i,rad_j,
     x                       ctheti,cthetj,l_i,l_j,lnr,lgeom,
     x                       rradi,rradj,ratioi,ratioj,rx,
     x                       sep(rve),thetai,thetaj)
                      elseif(lovoid(rve)) then
c-----------------------prepare data to pass to subroutin "ovoids", which 
c                       will check whether the particles are contacting.  
c
c-----------------------identify the specific component pieces of these 
c                       two particles
c
c-----------------------numbering scheme for the components within igrain:
c                         0 for the top    spherical cap
c                         1 for the bottom spherical cap
c                         2 for the torus
c                       so that the numbering is from 0 to 2
c
c-----------------------the tolerance for convergence of torus-torus distances
                        if(linitc(rve)) then
c-------------------------when this subroutin is collecting overlap information
c                         so that a time increment can be assigned, use a
c                         higher tolerance
                          tol = tolrnc(1,rve)
                        else
c-------------------------otherwise use a lower tolerance for near-neighbor
c                         searches
                          tol = tolrnc(2,rve)
                        endif
c
                        call ovoids(a_i,a_j,betahi,betalo,
     1                       p1_i,p1_j,p2_i,p2_j,
     2                       r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                       seprat,tol,
     3                       m_i,m_j,lgeom,
     4               
     5                       c_eta,ovrlap,l_i,l_j,isweep,ltact)
c
c-----------------------are the two particles are near-neighbors?
                        lnear = ltact
                        ltact = .false.
c
                      elseif(lbumpy(rve)) then
c-----------------------bumpy particles
c
c-----------------------establish whether contact has occured, and if so,
c                       compute various auxilary quantities
                        call bumpy(r_i, r_j, b_rad, s_rad, xlocal,
     x                             rxcntr, Rot_i, Rot_j, m_i, m_j,
     x                             lgeom, lexep, seprat,
     x                             c_eta, ovrlap, l_i, l_j, ltact,
     x                             rve, mrve)
c
c-----------------------are the two particles are near-neighbors?
                        lnear = ltact
                        ltact = .false.
                      endif
c
c---------------------insert the near-neighbor into the linked list
                      if(lnear) then
c
c-----------------------with Hertz-type contacts, we may need to gather
c                       information about overlaps at the beginning of a
c                       simulation
                        if(linitc(rve)) then
                          ntacts(rve) = ntacts(rve) + 1
                          ovravg(rve) = ovravg(rve) + ovrlap
                        endif
c
                        if(ipt2.gt.mlist) then
                          write(ScrUnit(rve),*)
     x                      ' ipt2 exceeded mlist in subroutin lister'//
     x                      '  ipt2 and mlist=',ipt2,mlist
                          stop
                        endif
c
c-----------------------place this particle pair into the linked list,
c                       but (in the case of ovals and ovoids) only if
c                       the pair is not already in the list (lheadr = .true.)
                        if(lheadr) then
                          ipt1a = igrain
                          do while(ipt1a.ne.0)
                            ipt1b = ipt1a
                            ipt1a = list2(ipt1a,rve)
                          end do
c
                          list2(ipt1b,rve) = ipt2
                          list1(ipt2,rve) = jgrain
c
                          ipt1 = ipt2
                          ipt2 = ipt2 + 1
                          lheadr = .false.
                        endif
c
c-----------------------add to the number of component parts that
c                       are near-neighbors for these two particles
                        list3(ipt2-1,0,rve) = list3(ipt2-1,0,rve) + 1
c
c-----------------------check to see whether there are too many near-neighbor
c                       componenets between these particles
                        if(list3(ipt2-1,0,rve) .gt. mlist3) then
                          write(ScrUnit(rve),910)
     x                      timer(rve),igrain,jgrain
                          write(ErrUnit(rve),910) timer(rve),
     x                                             igrain,jgrain
  910                     format('list3(ipt2-1,0) exceeds mlist3 in',
     x                           ' subroutin lister',/,'  timer =',
     x                           1pe13.5, ', igrain =', i7, 
     x                           ', jgrain =', i7)
                        endif
c
c                       idummy
                        list3(ipt2-1,-1,rve) = 1
c
c-----------------------identify the pair of component parts with a modulo
c                       scheme and add to the list of component parts
                        list3(ipt2-1,list3(ipt2-1,0,rve),rve) =
     x                    m_i*10 + m_j
c
c-----------------------check whether the particles are now touching. If so,
c                       check whether they were previously in the near-neighbor 
c                       linked list.  This situation would be an error.
                        if(lprev) then
c
c-------------------------sines and cosines of limiting "beta" angles for the
c                         near-neighbor search with oval and ovoid particles
                          betahi(1) = cbeta(1,rve)
                          betalo(1) = cbeta(1,rve)
                          betahi(2) = cbeta(2,rve)
                          betalo(2) = cbeta(2,rve)
c
c-------------------------the critical separation is zero for a contact check
                          seprat = 0.
c
                          if(lcircl(rve) .or. lspher(rve)) then
c
c---------------------------determine whether the particles are touching
                            call sphere(r_i,r_j,rxcntr,seprat,ndim1,
     x                                  lexep,lgeom,
     x                                c_eta,ovrlap,l_i,l_j,carea,ltact)
                          elseif(lelips(rve)) then
                            lnr = .false.
c
c---------------------------determine whether the particles are touching
                            call ellips(lnear,
     1                       ltact,ovrlap,c_eta,rad_i,rad_j,
     2                       ctheti,cthetj,l_i,l_j,lnr,lgeom,
     3                       rradi,rradj,
     4                       aspect(igrain,rve),aspect(jgrain,rve),
     5                       rx,
     6                       sep(rve),
     7                       theta(3,igrain,rve),theta(3,jgrain,rve))
c
                          elseif(loval(rve)) then
c
c---------------------------determine whether the particles are touching
                            call ovals(a_i,a_j,betahi,betalo,
     1                          p1_i,p1_j,p2_i,p2_j,
     2                          r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                          seprat,
     3                          m_i,m_j,lgeom,
     4
     5                          c_eta,ovrlap,l_i,l_j,ltact)
                          elseif(lnobby(rve)) then
c---------------------------nobby particles
c
c---------------------------establish whether contact has occured, and if so,
c                           compute various auxilary quantities
                            call nobby(r_i,r_j,cenrad(rve),
     1                                satrad(rve),
     2                                rxcntr,cosa,cosbi,cosbj,
     3                                m_i,m_j,lgeom,lexep,seprat,
     x                                lhiddn(rve),
     4
     5                                c_eta,ovrlap,l_i,l_j,ltact,
     6                                rve, mrve)
                          elseif(lovoid(rve)) then
                            tol = tolrnc(1,rve)
c
c---------------------------determine whether the particles are touching
                            call ovoids(a_i,a_j,betahi,betalo,
     1                          p1_i,p1_j,p2_i,p2_j,
     2                          r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                          seprat,tol,
     3                          m_i,m_j,lgeom,
     4                 
     5                          c_eta,ovrlap,l_i,l_j,isweep,ltact)
                          elseif(lbumpy(rve)) then
c---------------------------bumpy particles
c
c---------------------------establish whether contact has occured, and if so,
c                           compute various auxilary quantities
                            call bumpy(r_i, r_j, b_rad, s_rad, xlocal,
     x                                 rxcntr, Rot_i, Rot_j, m_i, m_j,
     x                                 lgeom, lexep, seprat,
     x                                 c_eta, ovrlap, l_i, l_j, ltact,
     x                                 rve, mrve)
c
c---------------------------are the two particles are near-neighbors?
                            lnear = ltact
                            ltact = .false.
                          endif
c
                          if(ltact) then
                            kpt1 = igrain
  402                       if(list2o(kpt1).eq.0) then
c-----------------------------oops!  It seems that we have found a pair of
c                             particles that are in contact, even though
c                             the pair was not previously even included in the
c                             list of near neighbors.  This situation is usually
c                             the result of a particle somehow acquiring an 
c                             extremely large velocity, large enough to 
c                             bring it into immediate contact with other 
c                             particles that were not even close before.
c
                              iflg = 1
                              call illeg(iflg,igrain,jgrain,
     x                           m_i,m_j,nupdat4(rve),
     x                           merror,nerror(rve),
     x                           vh(1,igrain,rve),vh(2,igrain,rve),
     x                           vh(3,igrain,rve),
     x                           vh(1,jgrain,rve),vh(2,jgrain,rve),
     x                           vh(3,jgrain,rve),
     x                           timer(rve),ErrUnit,ScrUnit,rve,mrve)
                            else
                              kpt1 = list2o(kpt1)
                              kgrain = list1o(kpt1)
                              if(jgrain.ne.kgrain) then
                                goto 402
                              else
c-------------------------------these two particles were previously within the
c                               linked list of near neighbors.  Although this
c                               is desirable, we must also check whether
c                               the two component pieces of the current search
c                               were previously in the linked list
c
c-------------------------------consider the combinations of component pieces 
c                               that are near-neighbors for this pair of 
c                               particles
                                ipart = 1
c
c-------------------------------the number of pairs of component pieces that 
c                               are near-neighbors
c                               for the two particles
                                nparts = list3o(kpt1,0)
c
                                llist = .false.
c
c-------------------------------search through the pairs of component pieces 
c                               for a contact.  The logical variable "lnocon" 
c                               is true until a contact is found, then
c                               it becomes false so that the search ends.
                                do 91 while (ipart.le.nparts .and. 
     x                                       .not.llist)
c
c---------------------------------consider the component pieces from the two 
c                                 particles.  Extract the types of components 
c                                 from the digits of list3
                                  iquado = list3o(kpt1,ipart)/10
                                  jquado = mod(list3o(kpt1,ipart),10)
c
c---------------------------------was this pair of component pieces previously
c                                 in the list of possible contacts?
                                  llist = iquado.eq.m_i .and. 
     x                                    jquado.eq.m_j
                                  ipart = ipart + 1
   91                           continue
c
c-------------------------------was this pair of component pieces previously
c                               in contact?
                                if(.not.llist) then
c---------------------------------oops!  It seems that we have found a pair of
c                                 particles that are not in contact, even though
c                                 the pair was not previously even included in 
c                                 the list of near neighbors.  This situation 
c                                 is usually the result of a particle somehow 
c                                 acquiring an extremely large velocity, large 
c                                 enough to bring it into immediate contact 
c                                 with other particles that were not even 
c                                 close before.
                                  iflg = 2
                                  call illeg(iflg,igrain,jgrain,
     x                               m_i,m_j,nupdat4(rve),
     x                               merror,nerror(rve),
     x                               vh(1,igrain,rve),
     x                               vh(2,igrain,rve),
     x                               vh(3,igrain,rve),
     x                               vh(1,jgrain,rve),
     x                               vh(2,jgrain,rve),
     x                               vh(3,jgrain,rve),
     x                               timer(rve),ErrUnit,ScrUnit,
     x                               rve,mrve)
                                endif
                              endif
                            endif
                          endif
                        endif
                      endif
  452               continue
  450             continue
                endif
              endif
              endif
  230       continue
  222     continue
  220   continue
  200 continue
c
      if(ipt2.gt.mlist) then
        write(ScrUnit(rve),*) 'the linked list grew too large',
     x             ipt2,mlist,mfirst
        write(ErrUnit(rve),*) 'the linked list grew too large',
     x                         ipt2,mlist,mfirst
        stop
      endif
c
c-----now that the near-neighbor linked list has been completely modified,
c     reestablish references to the original linked list of contact forces.
      if(nupdat4(rve).gt.1) then
        do 400 igrain = 1,np(rve)
          ipt1 = igrain
          nlisti = 0
c
          do 410 while (list2(ipt1,rve).ne.0)
            nlisti = nlisti + 1
            ipt1 = list2(ipt1,rve)
            ilist2(nlisti) = ipt1
            ilist1(nlisti) = list1(ipt1,rve)
  410     continue
c
          if(nlisti.gt.mnear) then
            write(ScrUnit(rve),*)
     x        'Error in subroutin lister, nlisti too large.'
            write(ScrUnit(rve),*)
     x        'You might try increasing the parameter mnear'
            write(ScrUnit(rve),*)
     x        ' in subroutin lister and then recompiling'
            write(ScrUnit(rve),*) 'nlisti =',nlisti
            stop
          else
c
            jpt1 = igrain
            nnlistj = 0
c
c-----------now look for all of the particles that were previously in contact
c           with the particle 'igrain'.  Create lists of these particles
            do 420 while (list2o(jpt1).ne.0)
              nnlistj = nnlistj + 1
              jpt1 = list2o(jpt1)
              jlist2(nnlistj) = jpt1
              jlist1(nnlistj) = list1o(jpt1)
  420       continue
c
            if(nnlistj.gt.mnear) then
              write(ScrUnit(rve),*)
     x          'Error in lister, nnlistj too large'
              write(ScrUnit(rve),*)
     x          'You might try increasing the parameter mnear'
              write(ScrUnit(rve),*)
     x          ' in subroutin lister and then recompiling'
              stop
            endif
c
c-----------is the current particle 'jgrain' included in the list of particles
c           that were previously in contact with 'igrain'?  If so,
c           copy the contact force reference to the current linked list
            do 430 j = 1,nnlistj
              jgrain = jlist1(j)
              do 440 k = 1,nlisti
                if(jgrain.eq.ilist1(k)) then
                  liste(ilist2(k),rve) = listeo(jlist2(j))
                endif
  440         continue
  430       continue
          endif
  400   continue
      endif
c
c-----with Hertz-type contacts, we may need to gather
c     information about overlaps at the beginning of a
c     simulation
      if(linitc(rve)) then
        ovravg(rve) = ovravg(rve) / ntacts(rve)
      endif
c
      iupdat(rve) = 0
c
c-----the arrays xmove() and thmove() keep track of the particles movements
c     since the last update of the linked list, so that the program can
c     determine when the next update is necessary.  Reset these movements to
c     zero
      do 550 igrain = 1,np(rve)
        do 560 j = 1,ndim1
          xmove(j,igrain,rve) = 0.
  560   continue
c
        do 561 j = ndim2,3
          thmove(j,igrain,rve) = 0.
  561   continue
  550 continue
c
      do 600 i=1,3
        defup(i,rve) = def(i,i,rve)
  600 continue
c
c-----for the Jager contact force algorithm, check the integrity of the 
c     linked list of load path information
      lcheck = .true.
      nfilled(rve) = 0
      nvacant = 0
c
      if((lJager(rve) .or. lJagr2(rve) .or. lJagr3(rve)
     x    .or. lJagr4(rve)) .and. lcheck) then
        do 820 igrain = 1,np(rve)
c
c---------the pointer to the first particle's location within the linked list.  
          ipt1 = igrain
c
c---------in this "do 90" loop, we search through the linked list for all
c         of the near-neighbors of igrain
          do 221 while (list2(ipt1,rve).ne.0)
c
c-----------the next pointer in igrain's list
            ipt1 = list2(ipt1,rve)
c
c-----------the pointer to the location of contact informaton in various
c           arrays.  ipt3 points to a particle pair that is in contact.
            ipt3 = liste(ipt1,rve)
c
c-----------were the two particles not touching at t-dt?
            ltouch = ipt3.eq.0
c
            if(.not.ltouch) then
c-------------if ipt=3, then set ipt5=3 as well

              if(.not.lconvx(rve)) then
c---------------with non-convex particles, we must look through the 
c               array "list" for all instance of contacts between the 
c               two particles
                j4 = liste(ipt1,rve)
                do 802 while (j4.ne.0)
                  i4 = listk(j4,rve)
                  nfilled(rve) = nfilled(rve) + 1
                  do 227 while (listJ(i4,rve).ne.0)
                    nfilled(rve) = nfilled(rve) + 1
                    i4 = listJ(i4,rve)
  227             continue
                  j4 = listf0(j4,rve)
  802           continue
              else
c---------------with convex particles, only one contact
                ipt5 = ipt3
                i4 = listk(ipt5,rve)
                nfilled(rve) = nfilled(rve) + 1
                do 223 while (listJ(i4,rve).ne.0)
                  nfilled(rve) = nfilled(rve) + 1
                  i4 = listJ(i4,rve)
  223           continue
              endif
            endif
  221     continue
  820   continue
c
        i4 = 0
        do 225 while (listJ(i4,rve).gt.0)
          nvacant = nvacant + 1
          i4 = listJ(i4,rve)
  225   continue
      endif
c
      if(lbumpy(rve).and.lcheck) then
        do 700 igrain = 1,np(rve)
c---------the pointer to the first particle's location within the linked list.  
          ipt1 = igrain
c
c---------in this "do 90" loop, we search through the linked list for all
c         of the near-neighbors of igrain
          do 703 while (list2(ipt1,rve).ne.0)
c
c-----------the next pointer in igrain's list
            ipt1 = list2(ipt1,rve)
c
c-----------the pointer to the location of contact informaton in various
c           arrays.  ipt3 points to a particle pair that is in contact.
            ipt3 = liste(ipt1,rve)
c
c-----------were the two particles not touching at t-dt?
            ltouch = ipt3.eq.0
c
            if(.not.ltouch) then
              i4 = liste(ipt1,rve)
              do 701 while (i4.ne.0)
                i4 = listf0(i4,rve)
  701         continue
            endif
  703     continue
  700   continue
      endif
c
      if(lJager(rve) .or. lJagr2(rve)
     x   .or. lJagr3(rve) .or. lJagr4(rve)) then
        call UnitQ(rve)
      endif
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine UnitQ(rve)
c
c-------this subroutin normalizes the contact frame quaternion (Qc_old)
c       so that it is a unit quaternion
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        double precision Qc_mag
        integer*4 i4
        integer*2 rve
c
        do 10 i4 = 0,mlist2
          if(Qc_old(1,i4,rve) .ne. 0.) then
            Qc_mag = sqrt(  Qc_old(1,i4,rve)**2
     x                    + Qc_old(2,i4,rve)**2
     x                    + Qc_old(3,i4,rve)**2
     x                    + Qc_old(4,i4,rve)**2)
c
            Qc_old(1,i4,rve) = Qc_old(1,i4,rve) / Qc_mag
            Qc_old(2,i4,rve) = Qc_old(2,i4,rve) / Qc_mag
            Qc_old(3,i4,rve) = Qc_old(3,i4,rve) / Qc_mag
            Qc_old(4,i4,rve) = Qc_old(4,i4,rve) / Qc_mag
          endif
   10   continue

        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine matinv(a,ai,n,ier,rve,mrve)
c
c-------this utilities computes the inverse of a matrix
c
        implicit double precision(a-h,o-z)
        implicit integer*2(i-n)
        integer*2 ier,mrve,n,rve,pivot
        double precision m
        dimension a(8,8,0:mrve),ai(8,8),b(8,8)
c
        ier = 0
c
        do 15 i = 1,n
          do 25 j = 1,n
            ai(i,j) = 0.
            b(i,j) = a(i,j,rve)
   25     continue
          ai(i,i) = 1.d0
   15   continue
c
        do 40 k = 1,n-1
c
          pivot = k
          amax = abs(b(k,k))
          do 10 i = k+1,n
            absa = abs(b(i,k))
            if (absa.gt.amax) then
              pivot = i
              amax = absa
            endif
  10      continue
c
          if(amax.eq.0.) then
            ier = 1
            return
          endif
c
          if(pivot.ne.k) then
            do 20 j = 1,n
              temp = b(k,j)
              b(k,j) = b(pivot,j)
              b(pivot,j) = temp
c
              temp = ai(k,j)
              ai(k,j) = ai(pivot,j)
              ai(pivot,j) = temp
   20       continue
          endif
c
          do 30 i = k+1,n
            m = -(b(i,k) / b(k,k))
            do 32 j = 1,n
              b(i,j) = b(i,j) + m*b(k,j)
              ai(i,j) = ai(i,j) + m*ai(k,j)
   32       continue
   30     continue
   40   continue
c
        if(b(n,n).eq.0) then
          ier = 1
          return
        end if
c
        do 50 k = n,2,-1
          do 60 i = k-1,1,-1
            m = -(b(i,k)/b(k,k))
            do 70 j = 1,n
              ai(i,j) = ai(i,j) + m*ai(k,j)
   70       continue
   60     continue
   50   continue
c
        do 80 i = 1,n
          do 90 j = 1,n
            ai(i,j) = ai(i,j) / b(i,i)
   90     continue
   80   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine definv(a,ai,n,rve,mrve)
c
c-----this subroutin computes the inverse of the deformation matrix (actually,
c     the deformation gradient matrix)
c
      implicit double precision(a-h,o-z)
      implicit integer*2(i-n)
      parameter(m=3)
      integer*2 rve,mrve
      dimension a(m,m,0:mrve),ai(m,m,0:mrve),b(m,m)
c
      do 11 i = 1,n
        do 12 j = 1,n
          b(i,j) = a(i,j,rve)
          ai(i,j,rve) = 0.
   12   continue
        ai(i,i,rve) = 1.d0
   11 continue
c
      do 10 i = 1,n-1
        do 20 j = i+1,n
          factor = -(b(j,i) / b(i,i))
          do 32 k = 1,n
            ai(j,k,rve) = ai(j,k,rve) + ai(i,k,rve) * factor
            b(j,k) = b(j,k) + b(i,k) * factor
   32     continue
   20   continue
   10 continue
c
      do 50 i = n,2,-1
        do 52 j = i-1,1,-1
          factor = -(b(j,i) / b(i,i))
          do 54 k = 1,n
            ai(j,k,rve) = ai(j,k,rve) + ai(i,k,rve) * factor
            b(j,k) = b(j,k) + b(i,k) * factor
   54     continue
   52   continue
   50 continue
c
      do 30 i = 1,n
        factor = b(i,i)
        do 40 j = 1,n
          ai(i,j,rve) = ai(i,j,rve) / factor
          b(i,j) = b(i,j) / factor
   40   continue
   30 continue
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine quez(rve)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 rve
      double precision C_w, Dcurnt, dJ_f, dm_stress, epsv,
     x                 J_f, K_feff, u_w1, u_w2
      integer*2 itask
c
c-----This subroutin computes an approximate assembly stiffness matrix "q" 
c     that will be used in the servo-algorithm for maintaining target 
c     stresses by adjusting the strain (i.e., cell dimensions).  The 
c     servo-algorithm is implemented in subroutin "deldf2".  The stiffness
c     "q" is a very rough approximation of the initial assembly stiffness.
c     Note, however, that a much larger or much smaller "q" would also work
c     just fine in subroutin "deldf2", since the servo-algorithm makes 
c     continual adjustments of the servo-stiffness: we just need a very
c     rough value of "q" in order to start the servo-algorithm.
c
      if(istart(rve).le.2) then
c-------If "istart" is .eq. 3, then the program will simply read 
c       values from the "dump" file, and the following does 
c       not need to be done
c
        if(ndim1.eq.3) then
c---------3D assemblies
c---------approximate coordination number of a reasonably dense assembly
          coordn = 4.d0
          const = (ravg(rve)**2)*(coordn*np(rve))/vcell(rve)
c---------approximate bulk stiffness
          kbulk(rve) = (2.d0/9.d0)*const*knh(rve)
c---------approximate shear stiffness
          gmod(rve) = const*((2.d0*2.d0*knh(rve)/15.d0)
     x                         + (2.d0*kth(rve)/5.d0))
        else
c---------2D assemblies
c---------approximate coordination number of a reasonably dense assembly
          coordn = 2.5d0
          const = (ravg(rve)**2)*(coordn*np(rve))/vcell(rve)
c---------approximate bulk stiffness
          kbulk(rve) = (1.d0/2.d0)*const*knh(rve)
c---------approximate shear stiffness
          gmod(rve) = const*((2.d0*knh(rve)/4.d0)
     x                        + (2.d0*kth(rve)/4.d0))
        endif
      endif
c
c-----the bulk fluid stifffness.  Will be used to compute undrained
c     bulk stiffness
      if(lporo(rve)) then
        if(iporo(rve).eq.1) then
          K_feff = K_f(rve)
        elseif(iporo(rve).eq.3) then
c---------for the more complex poroelastic model, find an effective
c         stiffness of the pore fluid, "K_feff".  We find this
c         effective stiffness by finding the numberical derivative
c         du/dv of the pore fluid.
c
c---------Jacobian of the bulk deformation gradient
          J_f = def(1,1,rve)*def(2,2,rve)*def(3,3,rve)
c
c---------small change in J_f, to find the numerical derivative
          dJ_f = 1d-6
c
c---------compressibility of pore liquid
          C_w = 1.d0 / K_f(rve)
c
c---------change in mean effective stress from the original (reference)
c         condition
          dm_stress = 
     x      ( (stress(1,1,rve)+stress(2,2,rve)+stress(3,3,rve))
     x       -(stres0(1,1,rve)+stres0(2,2,rve)+stres0(3,3,rve)))
     x      /3.d0
c
c---------whether to compute (1) water pressure with a given strain, or
c         (2) fluid strain with a given water pressure
          itask = 1
c
c---------small number that is used to find the threshold
c         volumetric strain (or water pressure) of the pore
          epsv = 1d-10
c
c---------find the water pressure u_w1 for the current conditions.
          call bubble(gamm(rve), p_atm(rve), p_o(rve), Hcc(rve), 
     x                C_w, S_o(rve), D_o(rve), N_o(rve),
     x                J_f, u_w1, p_vap(rve), p_wcav(rve), Dcurnt,
     x                S_now(rve),
     x                K_s(rve), poros0(rve), defw(rve), dm_stress,
     x                Dlast(rve), itask)
c
c---------find the water pressure u_w2 for the differential conditions,
c         with J_f-dJ_f
          call bubble(gamm(rve), p_atm(rve), p_o(rve), Hcc(rve), 
     x                C_w, S_o(rve), D_o(rve), N_o(rve),
     x                J_f-dJ_f, u_w2, p_vap(rve), p_wcav(rve), Dcurnt,
     x                S_now(rve),
     x                K_s(rve), poros0(rve), defw(rve), dm_stress,
     x                Dlast(rve), itask)
c
c---------effective fluid stiffness
          K_feff = (u_w2 - u_w1) / dJ_f
        endif
      endif
c
c-----a stiffer system is needed with undrained conditions when
c     poro-elastic effects are included
      if(lporo(rve) .and. .not.ldrain(rve) 
     x   .and. .not.lquez(rve)) then
        if(iporo(rve).eq.1) then
c---------the undrained bulk stiffness, using the fluid stiffness K_f
c         and the approximate gtranular stiffness kbulk
          kbulk(rve) = kbulk(rve) 
     x                  + 1.d0
     x                    / ((1.d0 - porosn(rve))/K_s(rve) 
     x                       + porosn(rve)/K_f(rve)) 
     x                    * (1.d0 - (1.d0 - porosn(rve))
     x                              *kbulk(rve)/K_s(rve))
        elseif(iporo(rve).eq.3) then
          kbulk(rve) = kbulk(rve) + K_feff
        endif
      endif
c
c-----for subsequent calls to this subroutin
      lquez(rve) = .false.
c
c-----approximate elastic moduli
      e1 = kbulk(rve) + 4.d0*gmod(rve)/3.d0
      e2 = kbulk(rve) - 2.d0*gmod(rve)/3.d0
      gh = gmod(rve) / 2.d0
c
      do 110 i = 1,8
        do 112 j = 1,8
          q(i,j,rve) = 0.
          q_alt(i,j,rve) = 0.
  112   continue
  110 continue
c
c-----note that the 6x6 components of "q" corresspond to the 11, 22, 33, 
c     12, 13, 23 components of a conventional stiffness.
c     do 100 i = 1,6
c       do 101 j = 1,6
c         if(i.le.3 .and. j.le.3) then
c           q(i,j,rve) = e2
c         else
c           q(i,j,rve) = gh
c         endif
c 101   continue
c       if(i.le.3) then
c         q(i,i,rve) = e1
c       else
c         q(i,i,rve) = gmod(rve)
c       endif
c 100 continue
c
      do 100 i = 1,3
        do 101 j = 1,3
          q(i,j,rve) = e2
  101   continue
        q(i,i,rve) = e1
  100 continue
c
      q(4,4,rve) = gmod(rve)
      q(5,5,rve) = gmod(rve)
      q(6,6,rve) = gmod(rve)
c
c-----These stiffnesses were used in earlier versions to servo-control
c     the mean stress.
      q(7,1,rve) = q(1,1,rve) / 3.d0
      q(7,2,rve) = q(2,2,rve) / 3.d0
      q(7,3,rve) = q(3,3,rve) / 3.d0
      q(7,7,rve) = (q(1,1,rve) + q(2,2,rve) + q(3,3,rve)) / 3.d0
c
c-----stiffnesses that are related to pore fluid pressure
      if(lporo(rve)) then
        denom = (1.d0 - poros0(rve))/K_s(rve) +poros0(rve)/K_feff
        q(8,1,rve) = -1.d0 / denom
        q(8,2,rve) = -1.d0 / denom
        q(8,3,rve) = -1.d0 / denom
        q(8,8,rve) = poros0(rve) / denom
      endif
c
c-----the alternative stiffness is used with undrained conditions
      do 200 i = 1,8
        do 202 j = 1,8
          q_alt(i,j,rve) = q(i,j,rve)
  202   continue
  200 continue
c
c-----constant-volume stiffnesses
      do 210 i = 1,3
        do 212 j = 1,3
          if(j.ne.i) then
            q_alt(i,j,rve) = 0.95d0*q(i,i,rve)
          endif
  212   continue
c       q_alt(i,i,rve) = 1.10d0*q(i,i,rve)
  210 continue
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine sphere(r_i,r_j,rx,seprat,ndim1,lexep,lgeom,
     x                  c_eta,ovrlap,l_i,l_j,carea,ltact)
c
c-------This subroutin determines whether two circles (or spheres) are in 
c       contact with each other.  In the case of a near-neighbor search, 
c       it determines whether the ovoids are within a distance 'sep' of 
c       each other.
c
c       Output from this subroutin includes the amount overlap between
c       the two particles, the location of the contact point relative to the
c       centers of the two particles, and the unit normal vector of the
c       contact point (see a more detailed description below).
c
c-------Input
c
c       r_i       radius of particle "i"
c       r_j       radius of particle "j"
c       rx()      the vector from the center of particle "i" to the center 
c                 of particle "j"
c       ndim1     the dimension of the simulation (2 or 3)
c       lgeom     whether certain vectors required?  These vectors include
c                 c_eta, l_i, and l_j.  These would normally be required
c                 as output during contact detection, but would not be
c                 required for near-neighbor detection
c       lexep     force the reporting of contact indentation
c
c-------Output
c
c         c_eta() the outward normal vector at the contact of particle i
c         l_i()   the vector from the center of particle i to the contact point
c         l_j()   the vector from the center of particle j to the contact point
c         ovrlap  the overlap (distance) between the two particles
c         carea   the contact area of the two particles.  This is a circular
c                 area, with the radius of the circle of intersection of the
c                 two spheres 
c         isweep  the number of iteration loops that were required for
c                 convergence with torus-torus contact detection
c         ltact   are the particles touching?  (or, perhaps, are they
c                 near-neighbors?)
c
        implicit double precision(a-h,o-z)
        double precision c_eta,carea,l_i,l_j,ovrlap,pi,
     x                   r_i,r_j,rij,rijsq,rsum,rx,seprat
c
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 ndim1
c
        logical lexep,lgeom,ltact
c
        dimension c_eta(3),rx(3),l_i(3),l_j(3)
c
c-------numerical constants
        pi = 3.14159265358979323846d0
c
c-------initialize the logical variable ltact to the value "no contact"
        ltact = .false.
c
        rijsq = 0.
        do 2 k = 1,ndim1
c-------square of the distance between particle centers
          rijsq = rijsq + rx(k)**2
    2   continue
c
c-------sum of particle radii (plus the separation threshold)
        rsum = r_i + r_j + seprat
c
c-------are the particles touching
        ltact = rijsq.lt.rsum**2
c
c-------in the event of a contact (ltact=.true.) and when we must find
c       certain geometric quantities (lgeom=.true.)
        if(lgeom .and. (ltact .or. lexep)) then
c---------compute various geometric quantities that will be needed to
c         find the contact forces and the moments acting upon the particles
c
c---------the distance between particle centers
          rij = sqrt(rijsq)
c
c---------the overlap between particles (twice the identation)
          ovrlap = rsum - rij
c
c---------the area of the circle of intersection of the two spheres
          carea = pi * 
     x           (r_i**2 - ((r_i**2 - r_j**2 + rsum**2)/(2*rsum))**2)
c
          do 4 k = 1,ndim1
c-----------the cosines of the branch vector and the outward normal 
c           vector at the contact of particle i
            c_eta(k) = rx(k) / rij
c
c-----------the vector from the center of particle i
c           to the contact point
            l_i(k) = rx(k)*r_i/rsum
c
c-----------the vector from the center of particle j
c           to the contact point
            l_j(k) = -(rx(k)*r_j/rsum)
    4     continue
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ellips(lnear,
     x       ltact,ovrlap,c_eta,rad_i,rad_j,
     x       ctheti,cthetj,l_i,l_j,lnr,lgeom,
     x       rradi,rradj,ratioi,ratioj,rx,
     x       sep,thetai,thetaj)
c
c-------This subroutin determines whether two ellipses are in contact with
c       each other.  If there is contact, it also determines the overlap
c       between the ellipses, the position of the overlap, and the outward
c       normal vector at the contact point.  In the case of a near-neighbor
c       search, it also determines whether two ellipses are within a 
c       distance 'sep' of each other.
c
c-------The subroutin uses the algorithm John M. Ting's algorithm, given
c       in his wonderfully informative and concise paper,
c         John M. Ting, "An ellipse-based micromechanical model for
c         angular granular materials," H. Adeli and R.L. Sierakowski (eds.)
c         Mechanics and Computing in the 1990's and Beyond, ASCE, New
c         York, N.Y., 1991, pp. 1214-1218.
c
        implicit double precision(a-h,o-z)
        double precision a0,a1,a2,a3,a4,
     x                   airad,aijrat,ajrad,
     x                   b1,b2,b3,
     x                   bigA,bigAb,bigB,bigBb,bigC,bigCb,
     x                   bigP,bigQ,bigR,bigS,bigX,bigY,
     x                   birad,bijrat,bjrad,
     x                   c_eta,ceta,cos_i,cos_j,
     x                   cosri,cosrj,cthd,ctheti,cthetj,
     x                   cube1,cubeQ,cubeQ3,cubeQR,
     x                   cubeR,cubeR2,cubeS,cubeT,discrm,dxbar,
     x                   etamag,l_i,l_j,ovrlap,ovrlpi,ovrlpj,
     x                   quadB,quadC,qval,qvalm,rat1,rad_i,rad_j,
     x                   radict,ratioi,ratioj,rradi,rradj,rx,rxc,rxn,
     x                   sep,soln1,soln2,sqrdis,sqrt1,sqrt2,sqrtQR,
     x                   thetad,thetai,thetaj,trifl,trifl2,tryY,
     x                   ups_i,ups_j,
     x                   x_ci,x_cj,xi_tch,xj_tch,Xtry1,Xtry2
        logical lnear,lnr,lgeom,ltact,ltry
c
        dimension bigX(3),bigY(3),
     x            c_eta(3),ceta(3),cos_i(3),cos_j(3),cosri(3),cosrj(3),
     x            cthd(3),ctheti(3),cthetj(3),dxbar(3),l_i(3),l_j(3),
     x            quadB(2),quadC(2),rx(3),rxc(3),rxn(3),tryY(2),
     x            x_ci(3),x_cj(3),xi_tch(3),xj_tch(3)
c
c-------Are the particles in contact?
        ltact = .false.
        lnear = .false.
c
c-------the overlap between the particles
        ovrlap = 0.d0
c
c-------the rotation angle of particle j relative to particle i
        thetad = thetaj - thetai
c
        cthd(1) = cos(thetad)
        cthd(2) = sin(thetad)
c
c-------precision limits
        trifl2 = 1.d-30
        trifl  = 5.d-15
c
c-------the branch vector between particle centers, with respect to the
c       local coordinate system of particle i
        rxn(1) =   rx(1)*ctheti(1)  + rx(2)*ctheti(2)
        rxn(2) = -(rx(1)*ctheti(2)) + rx(2)*ctheti(1)
c
c-------The major and minor radii of the i'th ellipse
        airad = rradi
        birad = rradi*ratioi
c
c-------The major and minor radii of the j'th ellipse
        ajrad = rradj
        bjrad = rradj*ratioj
c
c-------when we are only checking whether the particles are "near-nieghbors"
c       (but possibly not actually in contact), then increase the sizes
c       of the two particles to account for the threshold separation
        if(lnr) then
          airad = airad + sep/2.d0
          birad = birad + sep/2.d0
          ajrad = ajrad + sep/2.d0
          bjrad = bjrad + sep/2.d0
        endif
c
c-------Ratios of the radii
        aijrat = airad / ajrad
        bijrat = birad / bjrad
c
c-------John Ting's equation (2) applied to the j'th ellipse
        bigA = (cthd(1)/ajrad)**2 + (cthd(2)/bjrad)**2
        bigB = (cthd(2)/ajrad)**2 + (cthd(1)/bjrad)**2
        bigC = cthd(1)*cthd(2)*(1.d0/ajrad**2 - 1.d0/bjrad**2)
c
c-------The scaled coordinates in John Ting's equation (4) applied 
c       to the i'th ellipse
        bigAb = bigA*(airad**2)
        bigBb = bigB*(birad**2)
        bigCb = bigC*airad*birad
c
c-------Rotated coordinates of John Ting's equation (3) applied 
c       to the i'th ellipse
        dxbar(1) = rxn(1) / airad
        dxbar(2) = rxn(2) / birad
c
c-------Various derived parameters in John Ting's equation (8)
        bigP = bigBb - bigAb
        bigQ = -(2.d0*(bigBb*dxbar(2) + bigCb*dxbar(1)))
        bigR =   bigAb*(1.d0 + dxbar(1)**2)
     x         + bigBb*dxbar(2)**2
     x         + 2.d0*bigCb*dxbar(1)*dxbar(2)
     x         - 1.d0
        bigS = bigAb*dxbar(1) + bigCb*dxbar(2)
c
c-------Coefficients of the quartic equation, in John Ting's equation (7)
        a4 = bigR**2 - 4.d0*bigS**2
        a3 = 2.d0*bigQ*bigR + 8.d0*bigS*bigCb
        a2 = bigQ**2 + 2.d0*bigP*bigR - 4.d0*bigCb**2 + 4.d0*bigS**2
        a1 = 2.d0*bigP*bigQ - 8.d0*bigS*bigCb
        a0 = bigP**2 + 4.d0*bigCb**2
c
        if(abs(a0).gt.trifl2) then
          a1 = a1 / a0
          a2 = a2 / a0
          a3 = a3 / a0
          a4 = a4 / a0
          a0 = 1.d0
c
c---------coefficients of the associated cubic equation
          b1 = -a2
          b2 = a1*a3 - 4.d0*a4
          b3 = 4.d0*a2*a4 - a3**2 - a4*a1**2
c
c---------start solving the cubic equation
          cubeQ = (3.d0*b2 - b1**2) / 9.d0
          cubeR = (9.d0*b1*b2 - 27.d0*b3 - 2.d0*b1**3) / 54.d0
          cubeQ3 = cubeQ**3
          cubeR2 = cubeR**2
          cubeQR = cubeQ3 + cubeR2
c
c---------a first check of whether the particles are touching
          ltact = cubeQR/abs(cubeQ3) .gt. -trifl
c
          if(ltact) then
c---------A Contact
c
            sqrtQR = sqrt(cubeQR)
            cubeS = (cubeR + sqrtQR)**(1.d0/3.d0)
            cubeT = (cubeR - sqrtQR)**(1.d0/3.d0)
c
c-----------the solution of the associated cubic equation
            cube1 = cubeS + cubeT - b1/3.d0
c
c-----------now solve the quartic equation
            sqrt1 = sqrt(a1**2 - 4.d0*a2 + 4.d0*cube1)
            sqrt2 = sqrt(cube1**2 - 4.d0*a4)
            quadB(1) = 0.5d0*(a1 - sqrt1)
            quadB(2) = 0.5d0*(a1 + sqrt1)
            quadC(1) = 0.5d0*(cube1 - sqrt2)
            quadC(2) = 0.5d0*(cube1 + sqrt2)

            qvalm = 1.d60
            im = 0
            jm = 0
c
c-----------a second check of whether the particles are touching.  The value
c           of John Ting's Y should be in the range of -1 to +1.  Values
c           outside of this range (or complex values) are not contacts
            ltry = .false.
            do 10 i=1,2
              do 12 j = 1,2
                discrm = quadB(i)**2 - 4.d0*quadC(j)
                if(discrm .gt. -(1.d0*trifl)) then
                  sqrdis = sqrt(max(0.d0,discrm))
c
c-----------------trial values of Y.  Choose the values that minimize
c                 the quartic.
                  tryY(1) = (-quadB(i) + sqrdis) / 2.d0
                  tryY(2) = (-quadB(i) - sqrdis) / 2.d0
                  if(abs(tryY(1)).le.1.d0 .and. 
     x               abs(tryY(2)).le.1.d0) then
                    ltry = .true.
                    qval = abs(   tryY(1)**4 + a1*tryY(1)**3 +
     x                       a2*tryY(1)**2 + a3*tryY(1)**1 + a4) +
     x                     abs(   tryY(2)**4 + a1*tryY(2)**3 +
     x                       a2*tryY(2)**2 + a3*tryY(2)**1 + a4)
                    if(qval .lt. qvalm) then
                      qvalm = qval
                      bigY(1) = tryY(1)
                      bigY(2) = tryY(2)
                      im = i
                      jm = j
                    endif
                  endif
                endif
   12         continue
   10       continue
c
            ltact = ltry
          endif
c
c       elseif(a1.ne.0.) then
c---------No code here, perhaps an error message???????
c         print *,'a0 was zero but a1 was nonzero in subroutin ',
c    x            'ellips.  OOPS!'
c         stop
        elseif(a2.ne.0.) then
c---------the equation is quadratic, not quartic.  This will be the case
c         with circular particles
c
          discrm = a3**2 - 4.d0*a2*a4
          ltact = discrm .gt. 0.
          if(ltact.and.lgeom) then
c-----------A Contact
            sqrdis = sqrt(max(0.d0,discrm))
            bigY(1) = (-a3 + sqrdis) / (2.d0*a2)
            bigY(2) = (-a3 - sqrdis) / (2.d0*a2)
c
            if(abs(bigY(1)).gt.1.d0 .or. abs(bigY(2)).gt.1.d0) then
              ltact = .false.
            endif
          endif
        endif
c
c-------Now that contact is established, .........
        if(ltact.and.lgeom) then
c---------lgeom=.true. signifies that we must compute overlaps, contact
c         positions, etc.  This is not the case, when, for example, we
c         are just building a list of near-neighbors and do not need
c         information on contact forces, etc.
c
c---------We now have the situation, not discussed by John Ting, in which
c         both the positive and negative solution of his equation (4c) may 
c         apply.  For lack of a more elegant approach we will use the 
c         combination of bigX and bigY that minimize the right side of
c         his equation (5)
c
c---------for some reason, the program will occasionally get this far, even
c         though 1.d0 - bigY(1)**2 < 0.  (due to bigY(1)=0 and roundoff)
c
          radict = 1.d0 - bigY(1)**2
          if(radict.gt.0.) then
            Xtry1 = sqrt(radict)
          elseif(bigY(1).gt.0.) then
            bigY(1) = 1.d0
            Xtry1 = 0.
          else
            bigY(1) = -1.d0
            Xtry1 = 0.
          endif
          Xtry2 = -Xtry1
c
          soln1 = bigAb*(Xtry1 - dxbar(1))**2 +
     x            bigBb*(bigY(1) - dxbar(2))**2 +
     x            2.d0*bigCb*(Xtry1 - dxbar(1))*(bigY(1) - dxbar(2)) -
     x            1.d0
          soln2 = bigAb*(Xtry2 - dxbar(1))**2 +
     x            bigBb*(bigY(1) - dxbar(2))**2 +
     x            2.d0*bigCb*(Xtry2 - dxbar(1))*(bigY(1) - dxbar(2)) -
     x            1.d0
          if(abs(soln1) .lt. abs(soln2)) then
            bigX(1) = Xtry1
          else
            bigX(1) = Xtry2
          endif
 
          radict = 1.d0 - bigY(2)**2
          if(radict.gt.0.) then
            Xtry1 = sqrt(radict)
          elseif(bigY(2).gt.0.) then
            bigY(2) = 1.d0
            Xtry1 = 0.
          else
            bigY(2) = -1.d0
            Xtry1 = 0.
          endif
          Xtry2 = -Xtry1
c
          soln1 = bigAb*(Xtry1 - dxbar(1))**2 +
     x            bigBb*(bigY(2) - dxbar(2))**2 +
     x            2.d0*bigCb*(Xtry1 - dxbar(1))*(bigY(2) - dxbar(2)) -
     x            1.d0
          soln2 = bigAb*(Xtry2 - dxbar(1))**2 +
     x            bigBb*(bigY(2) - dxbar(2))**2 +
     x            2.d0*bigCb*(Xtry2 - dxbar(1))*(bigY(2) - dxbar(2)) -
     x            1.d0
          if(abs(soln1) .lt. abs(soln2)) then
            bigX(2) = Xtry1
          else
            bigX(2) = Xtry2
          endif
c
c---------vector from the center of the i'th particle to the middle of the
c         contact, with respect to the local coordinate system of the
c         first (i) particle
          x_ci(1) = 0.5d0*airad*(bigX(1) + bigX(2))
          x_ci(2) = 0.5d0*birad*(bigY(1) + bigY(2))
c
c---------Compute the overlap between the two ellipses.  We will use a 
c         different approach from that of John Ting.  Instead of using 
c         the relative particle velocities to compute a change in overlap 
c         from the previous overlab, we compute the overlap directly.
c         This is done by computing the distance (an indentation) between
c         the line that joins the two intersection points and the surface of
c         the ellipse.  This distance is that between the line and the parallel
c         tangent of the ellipse.
c         The approach requires a sum of indentation distances for each of the
c         two particles.
c
c         First, the indentation of the first particle, i
c
c         The radial vector x_ci() is employed.  We may use either of the 
c         two ratios x_ci(1)/x_ci(2) or x_ci(1)/x_ci(2) in the calculation.  
c         Use whichever ratio presents the least opportunity for a division 
c         by zero.
c
          if(abs(x_ci(1)) .gt. abs(x_ci(2))) then
            rat1 = x_ci(2) / x_ci(1)
            ups_i = rat1 / ratioi**2
            xi_tch(1) = airad /
     x                  sqrt(1.d0 + (rat1 / ratioi)**2)
          else
            rat1 = x_ci(1) / x_ci(2)
            ups_i = rat1 * ratioi**2
            xi_tch(1) = airad*rat1 / sqrt(rat1**2 + (1.d0 / ratioi)**2)
          endif
c
c---------transfer the sign of x_ci(1) to xi_tch(1).  This is done
c         to resolve the two roots (+/-) for xi_tch(1)
          xi_tch(1) = sign(xi_tch(1),x_ci(1))
c
          discrm = birad**2 - (xi_tch(1)*ratioi)**2
          if(discrm.gt.trifl2) then
            xi_tch(2) = sqrt(discrm)
          else
            xi_tch(2) = 0.d0
          endif
          xi_tch(2) = sign(xi_tch(2),x_ci(2))
c
          if(abs(x_ci(1)) .gt. abs(x_ci(2))) then
            ovrlpi = 
     x           (x_ci(1) - xi_tch(1) + ups_i*(x_ci(2) - xi_tch(2))) /
     x           sqrt(ups_i**2 + 1.d0)
          else
            ovrlpi = 
     x           (ups_i*(x_ci(1) - xi_tch(1)) + x_ci(2) - xi_tch(2)) /
     x           sqrt(ups_i**2 + 1.d0)
          endif
          ovrlpi = abs(ovrlpi)
c
c---------Now, the indentation of the second ellipse, jgrain
c
c---------Radial vector from the center of jgrain to the contact point x_c,
c         in the local coordinate system of the first ellipse, i
          rxc(1) = x_ci(1) - rxn(1)
          rxc(2) = x_ci(2) - rxn(2)
c
c---------The same radial vector in the local coordinate system of the second
c         ellipse, jgrain
          x_cj(1) =   cthd(1)*rxc(1)  + cthd(2)*rxc(2)
          x_cj(2) = -(cthd(2)*rxc(1)) + cthd(1)*rxc(2)
c
          if(abs(x_cj(1)) .gt. abs(x_cj(2))) then
            rat1 = x_cj(2) / x_cj(1)
            ups_j = rat1 / ratioj**2
            xj_tch(1) = ajrad /
     x                  sqrt(1.d0 + (rat1 / ratioj)**2)
          else
            rat1 = x_cj(1) / x_cj(2)
            ups_j = rat1 * ratioj**2
            xj_tch(1) = ajrad*rat1 / sqrt(rat1**2 + (1.d0 / ratioj)**2)
          endif
c
          xj_tch(1) = sign(xj_tch(1),x_cj(1))

          discrm = bjrad**2 - (xj_tch(1)*ratioj)**2
          if(discrm.gt.trifl2) then
            xj_tch(2) = sqrt(discrm)
          else
            xj_tch(2) = 0.d0
          endif
          xj_tch(2) = sign(xj_tch(2),x_cj(2))

          if(abs(x_cj(1)) .gt. abs(x_cj(2))) then
            ovrlpj = 
     x           (x_cj(1) - xj_tch(1) + ups_j*(x_cj(2) - xj_tch(2))) /
     x           sqrt(ups_j**2 + 1.d0)
          else
            ovrlpj = 
     x           (ups_j*(x_cj(1) - xj_tch(1)) + x_cj(2) - xj_tch(2)) /
     x           sqrt(ups_j**2 + 1.d0)
          endif
          ovrlpj = abs(ovrlpj)
c
c---------The total overlap: the sum of indentations of the two particles
          ovrlap = ovrlpi + ovrlpj
c
c         if(ovrlap.gt.0.05*rradi .or. ovrlap .lt.0.) then
c           print *,timer,' A lot of overlap'
c         endif
c
c---------The length of the vector from the center of the ellipse to the
c         contact center, i'th ellipse
          rad_i = sqrt(x_ci(1)**2 + x_ci(2)**2)
c
c---------The direction cosines of this vector with respect to the local
c         coordinate system that is alligned with ellipse i
          cosri(1) = x_ci(1) / rad_i
          cosri(2) = x_ci(2) / rad_i
c
c---------The direction cosines of the same vector relative to the global
c         coordinate system.  Compute these cosines using angle addition 
c         formulas
          cos_i(1) = 
     x          ctheti(1)*cosri(1) - ctheti(2)*cosri(2)
          cos_i(2) = 
     x          ctheti(2)*cosri(1) + ctheti(1)*cosri(2)
c
c---------The length of the vector from the center of the ellipse to the
c         contact center, j'th ellipse
          rad_j = sqrt(x_cj(1)**2 + x_cj(2)**2)
c
c---------The direction cosines of this vector with respect to the local
c         coordinate system that is alligned with ellipse j
          cosrj(1) = x_cj(1) / rad_j
          cosrj(2) = x_cj(2) / rad_j
c
c---------The direction cosines of the same vector relative to the global
c         coordinate system.  Compute these cosines using the addition formulas
          cos_j(1) = 
     x          cthetj(1)*cosrj(1) - cthetj(2)*cosrj(2)
          cos_j(2) = 
     x          cthetj(2)*cosrj(1) + cthetj(1)*cosrj(2)
c
c---------In calculating omegar() cosx() -> cos_i() and cos_j()
c                                 rradi  -> rad_i   and -rad_j <- NOTE THE MINUS
c
c---------The direction cosines of the outward normal vector with 
c         respect to the local coordinate system that is alligned 
c         with ellipse i
          etamag = sqrt(x_ci(2)**2 + (x_ci(1)* ratioi)**2)
          ceta(1) = (x_ci(1)* ratioi) / etamag
          ceta(2) = x_ci(2) / etamag
c
c---------The direction cosines of the outward normal vector with 
c         respect to the global coordinate system
          c_eta(1) = ctheti(1)*ceta(1) - ctheti(2)*ceta(2)
          c_eta(2) = ctheti(2)*ceta(1) + ctheti(1)*ceta(2)
c
c---------the vector from the center of particle i to the contact point
          l_i(1) = rad_i*cos_i(1)
          l_i(2) = rad_i*cos_i(2)
c
c---------the vector from the center of particle j to the contact point.
          l_j(1) = rad_j*cos_j(1)
          l_j(2) = rad_j*cos_j(2)
        endif
c
        if(lnr) then
          lnear = ltact
          ltact = .false.
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ovals(a_i,a_j,betahi,betalo,
     1                 p1_i,p1_j,p2_i,p2_j,
     2                 r1_i,r1_j,r2_i,r2_j,ravg,rxcntr,seprat,
     3                 m_i,m_j,lgeom,
     4        
     5                 c_eta,ovrlap,l_i,l_j,ltact)

c
c-------This subroutin determines whether two ovals are in contact with
c       each other.  In the case of a near-neighbor search, it determines
c       whether the ovals are within a distance 'sep' of each other.
c
c       Output from this subroutin includes the amount overlap between
c       the two ovals, the location of the contact point relative to the
c       centers of the two particles, and the unit normal vector of the
c       contact point (see a more detailed description below).
c
c--------Input
c
c        a_i()    The unit orientation vector of particle "i".  The vector
c                 points toward the top of the oval, in the direction
c                 of radius R1.  That is, it is directed from the center
c                 of the oval and toward the m_i=0 arc.
c
c        a_j()    Ditto for particle "j"
c
c        betahi   threshold values of the cosine and sine of the angle 
c        betalo   separating the arcs.  These values will differ from 
c                 those of the angle beta when a near-neighbor search is 
c                 being performed.
c
c          p1_i   the "p1" offset of the center of the top (and bottom) arc 
c                 from the center of the particle "i" (p1 is negative for 
c                 oblate ovals, having an aspect ratio less than 1)
c          p1_j   the "p1" offset of the center of the top (and bottom) arc 
c                 from the center of the particle "j" (p1 is negative for 
c                 oblate ovals, having an aspect ratio less than 1)
c          p2_i   the "p2" offset of the center of the left (and right) arc
c                 from the center of the particle "i" (p1 is positive for
c                 oblate ovals, having an aspect ratio less than 1)
c          p2_j   the "p2" offset of the center of the left (and right) arc
c                 from the center of the particle "j" (p1 is positive for
c                 oblate ovals, having an aspect ratio less than 1)
c
c          r1_i   the radius of the top and bottom arcs of particle "i"
c          r1_j   the radius of the top and bottom arcs of particle "j"
c          r2_i   the radius of the left and right arcs of particle "i"
c          r2_j   the radius of the left and right arcs of particle "j"
c
c          ravg   the mean (radial) size of all of the particles.  This
c                 value is NOT used inside this subroutin.  It is included
c                 only for consistency with the "ovoid" subroutin
c
c      rxcntr()   the branch vector from the center of particle "i" to the
c                 center of particle "j"
c
c   rx() -> y()   the vector from the component pieces in particles "i" 
c                 and "j".  Note that this vector connects the centers of 
c                 the component arcs of "i" and "j" (for example, from
c                 the center of an arc in particle "i" to the center of an
c                 arc in particle "j"), rather than the centers of the 
c                 two particles themselves.
c
c        seprat   the threshold separation distance between particles
c                    =0 for contact detection
c                    >= for near-neighbor searches
c
c           tol   a convergence tolerance used in the iterative solution
c                 of the torus-torus contact detection problem.  This
c                 value is NOT used inside this subroutin.  It is included
c                 only for consistency with the "ovoid" subroutin.
c
c           m_i   the number of the component that is being 
c                 investigated with particle "i":
c                   m_i = 0 for the top    arc
c                   m_i = 1 for the right  arc
c                   m_i = 2 for the bottom arc
c                   m_i = 3 for the left   arc
c                
c           m_j   likewise, the number of the component that is being 
c                 investigated with particle "j"
c
c         lgeom   whether certain output vectors required?  These vectors 
c                 include c_eta, l_i, and l_j.  These would normally be 
c                 required as output during contact detection, but would 
c                 not be required for near-neighbor detection
c
c-------Output
c
c         c_eta() the outward normal vector at the contact of particle i
c
c         l_i()  the vector from the center of particle i to the contact point
c
c         l_j()  the vector from the center of particle j to the contact point
c
c         ovrlap  the amount of overlap between the two particles
c
c         isweep  the number of iteration loops that were required for
c                 convergence with torus-torus contact detection (isweep
c                 is NOT used for ovals, it is just included for consistency
c                 with the subroutin "ovoids")
c
c         ltact   are the particles touching?  (or, perhaps, are they
c                 near-neighbors?)
c
        implicit double precision(a-h,o-z)
c
c-------This parameter will establish the sizes of some arrays
        integer*4 msweep
c
        parameter(msweep=100)
c
        double precision adotci,adotcj,a_i,a_j,
     x                   b_i,b_j,beta_i,beta_j,betahi,betalo,
     x                   c_eta,cosx,i_sign,j_sign,
     x                   l_i,l_j,ovrlap,p_i,p_j,p1_i,p1_j,p2_i,p2_j,
     x                   r_i,r_j,r1_i,r1_j,r2_i,r2_j,ravg,rsum,rxcntr,
     x                   rxdot1,rxdot2,
     x                   seprat,y,y_mag,y_sqr
c
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 m_i,m_j,k
c
        logical lgeom,ltact
c
        dimension a_i(3),a_j(3),b_i(3),b_j(3),betahi(2),betalo(2),
     x            c_eta(3),cosx(3),l_i(3),l_j(3),rxcntr(3),y(3)
c
c-------initialize the logical variable ltact to the value "no contact"
        ltact = .false.
c
c-------numbering scheme for the four component arcs of each particle,
c       designated with "m_i" and "m_j" for the two particles (moving
c       clockwise around the particle, starting at the top)
c         0 for the top    arc
c         1 for the right  arc
c         2 for the bottom arc
c         3 for the left   arc
c       so that numbering is from 0 to 3
c
c-------distinguish between arcs that are  at the top or right side
c       from those that are bottom or left, for particle "i"
        if(m_i.eq.0 .or. m_i.eq.1) then
          i_sign = 1.d0
        else
          i_sign = -1.d0
        endif
c
c-------distinguish between arcs that are at the top or right side
c       from those that are bottom or left for particle "j"
        if(m_j.eq.0 .or. m_j.eq.1) then
          j_sign = 1.d0
        else
          j_sign = -1.d0
        endif
c
c-------distinguish between arcs that are at the top or bottom
c       from those that are on the right or left sides for particle "i"
        if(m_i.eq.0 .or. m_i.eq.2) then
          beta_i = betahi(1)
          r_i = r1_i
          p_i = p1_i
          b_i(1) = a_i(1)
          b_i(2) = a_i(2)
        else
          beta_i = betalo(2)
          r_i = r2_i
          p_i = p2_i
          b_i(1) =  a_i(2)
          b_i(2) = -a_i(1)
        endif
c
c-------distinguish between arcs that are at the top or bottom
c       from those that are on the right or left sides for particle "j"
        if(m_j.eq.0 .or. m_j.eq.2) then
          beta_j = betahi(1)
          r_j = r1_j
          p_j = p1_j
          b_j(1) = a_j(1)
          b_j(2) = a_j(2)
        else
          beta_j = betalo(2)
          r_j = r2_j
          p_j = p2_j
          b_j(1) =  a_j(2)
          b_j(2) = -a_j(1)
        endif
c
c-------rxcntr() is the vector that connects the center of particle "i"
c       to the center of particle "j"
c
c-------note that the centers of the component arcs
c       may be offset from the center of the particle.  Find the 
c       separation "y" between the centers of the two component
c       arcs
        y(1) = rxcntr(1) - i_sign*p_i*b_i(1) + j_sign*p_j*b_j(1)
        y(2) = rxcntr(2) - i_sign*p_i*b_i(2) + j_sign*p_j*b_j(2)
c
c-------Note that the vector "y" connects the centers of the two 
c       component arcs, NOT the centers of the particles themselves.
c
c-------the sum of the radii of the two spherical caps.  (We add the distance
c       seprat, which is equal to zero for contact detection, and equal
c       to "sep" for near neighbor detection)
        rsum = r_i + r_j + seprat
c
c-------square of the distance between the centers of the two pieces
        y_sqr = y(1)**2 + y(2)**2
c
c-------compare the two squared distances to see if the particles could
c       be contacting (or or whether they could be near neighbors, depending 
c       on the value of seprat)
        if(y_sqr.lt.rsum**2) then
c---------the distance between the centers of the two arcs
          y_mag = sqrt(y_sqr)
c
c---------the unit vector in the direction of vector y(), which joins 
c         the centers of the two arcs.  Note that the vector "y" connects the
c         centers of the two component pieces (i.e., the two arcs),
c         NOT the centers of the particles themselves.
          cosx(1) = y(1) / y_mag
          cosx(2) = y(2) / y_mag
c
c---------the dot product of two unit vectors: the orientation vector of
c         oval "i" and the direction vector joining the centers of the two arcs
          adotci = b_i(1)*cosx(1) + b_i(2)*cosx(2)
c
c---------is the contact within the angle beta?
          ltact = i_sign*adotci .ge. beta_i
c
          if(ltact) then
c-----------the dot product for particle "j".  Note that the direction
c           between arc "j" to arc "i" is -y()
            adotcj = b_j(1)*cosx(1) + b_j(2)*cosx(2)
c
c-----------Note that the direction between arc "j" to arc "i" is -y()
            adotcj = -adotcj
c
c-----------is the contact within the angle beta?
            ltact =  j_sign*adotcj .ge. beta_j
c
c-----------check to see whether contact is on the "correct sides" of the
c           two arcs
            if(ltact) then
              ovrlap = rsum - y_mag
              ltact = ovrlap.lt.ravg .and. ovrlap.lt.ravg
c
c-------------one more check
              if(ltact) then
                rxdot1 = rxcntr(1)*a_i(1) + rxcntr(2)*a_i(2)
                rxdot2 = rxcntr(1)*a_i(2) - rxcntr(2)*a_i(1)
c
                ltact = (rxdot1.ge.0. .and. m_i.eq.0) .or.
     x                  (rxdot1.le.0. .and. m_i.eq.2) .or.
     x                  (rxdot2.ge.0. .and. m_i.eq.1) .or.
     x                  (rxdot2.le.0. .and. m_i.eq.3)
c
                if(ltact) then
                  rxdot1 = -(rxcntr(1)*a_j(1) + rxcntr(2)*a_j(2))
                  rxdot2 = -(rxcntr(1)*a_j(2) - rxcntr(2)*a_j(1))
c
                  ltact = (rxdot1.ge.0. .and. m_j.eq.0) .or.
     x                    (rxdot1.le.0. .and. m_j.eq.2) .or.
     x                    (rxdot2.ge.0. .and. m_j.eq.1) .or.
     x                    (rxdot2.le.0. .and. m_j.eq.3)
                endif
              endif
            endif
          endif
        endif
c
        if(ltact) then
          kk = 4
        endif
c
c-------in the event of a contact (ltact=.true.), and when we must find
c       certain geometric quantities (lgeom=.true.)
        if(ltact .and. lgeom) then
c---------compute various geometric quantities that will be needed to
c         find the contact forces and the moments acting upon the particles
c
          do 834 k = 1,2
c-----------the vector from the center of particle "i" to the contact point 
            l_i(k) = y(k)*r_i/rsum + i_sign*p_i*b_i(k)
c
c-----------the vector from the center of particle "j" to the contact point
            l_j(k) = -(y(k)*r_j/rsum - j_sign*p_j*b_j(k))
c
c-----------the outward normal vector at the contact of particle i
            c_eta(k) = cosx(k)
  834     continue
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine nobby(r_i,r_j,cenrad,satrad,
     2                 rx,cosa,cosbi,cosbj,
     3                 m_i,m_j,lgeom,lexep,seprat,lhiddn,
     4
     5                 c_eta,ovrlap,l_i,l_j,ltact,
     6                 rve, mrve)
c
c-------This subroutin determines whether two "nobby" particles are in contact
c       with each other.  In the case of a near-neighbor search, it determines
c       whether the particles are within a distance 'sep' of each other.
c
c       Output from this subroutin includes the amount overlap between
c       the two ovals, the location of the contact point relative to the
c       centers of the two particles, and the unit normal vector of the
c       contact point (see a more detailed description below).
c
c       A nobby particle is a non-convex shape that is the union of a set
c       of circles.  The set includes a central circle and several
c       satellite circles.  The number of satellite circles is the input
c       variable "nobs", so that the total number of circles is nobs+1.
c       The satellite circles are evenly spaced, with the centers lying
c       on a circle.  This circle has input radius "rad".  The satellite
c       circles have radius satrad*rad.  The central circle has radius
c       cenrad*rad.
c
c-------Input
c
c       r_i       radius of particle "i"
c       r_j       radius of particle "j"
c       rx()      the vector from the center of particle "i" to the center 
c                 of particle "j"
c       cosa(i,j) cosines of the nob orientation: nob "i", cosine "j"
c       cosbi()   orientation cosines of particle "i", counterclockwise from x1
c       cosbj()   orientation cosines of particle "j", counterclockwise from x1
c       cenrad    radius of central particle relative to r_i or r_j
c       satrad    radius of satellite particles relative to r_i or r_j
c       m_i       the number of the component that is being 
c                 investigated with particle "i":
c                   m_i = 0 for the central circle
c                   m_i = 1 for the top circle
c                   m_i = 2,etc counter-clockwise from the top
c       m_j       likewise, the number of the component that is being 
c                 investigated with particle "j"
c       lgeom     logical, whether certain vectors required?  These 
c                 vectors include c_eta, l_i, and l_j.  These would normally 
c                 be required as output during contact detection, but would 
c                 not be required for near-neighbor detection
c       lexep     logical, to force the reporting of contact indentation
c       seprat    the threshold separation distance between particles
c                    =0 for contact detection
c                    >= for near-neighbor searches
c       lhiddn    logical, whether the central circle is entirely hidden
c                 inside of the satellite particles
c
c-------Output
c
c         c_eta() the outward normal vector at the contact of particle i
c         l_i()   the vector from the center of particle i to the contact point
c         l_j()   the vector from the center of particle j to the contact point
c         ovrlap  the overlap (distance) between the two particles
c         ltact   are the particles touching?  (or, perhaps, are they
c                 near-neighbors?)
c
        implicit integer*2(i-n)
        implicit double precision(a-h,o-z)
c
        double precision c_eta,cenrad,cosa,cosbi,cosbj,
     x                   l_i,l_j,ovrlap,
     x                   r,r_i,r_j,rad_i,rad_j,rijsq,rsum,rx,
     x                   satrad,seprat,
     x                   x_i,x_j
c
        integer*2 rve,mrve
        integer*4 m_i,m_j,mparts
c
        logical lexep,lgeom,lhiddn,ltact
c
        parameter (mparts=5)
c
        dimension c_eta(3),cosa(mparts,3,0:mrve),cosbi(3),cosbj(3),
     x            l_i(3),l_j(3),
     x            r(3),rx(3),x_i(3),x_j(3)
c
c-------initialize the logical variable ltact to the value "no contact"
        ltact = .false.
c
        if(lhiddn .and. (m_i.eq.0 .or. m_j.eq.0)) then
c----------one of the circles is a central circle, but central circles are
c          hidden within the satellite circles (lhiddn.eq..true).  In this
c          case, the two circles can not be touching.
           ltact = .false.
        else
          if(m_i.eq.0) then
            if(m_j.eq.0) then
c-------------both circles are central circles
              rad_i = cenrad*r_i
              rad_j = cenrad*r_j
c
c-------------vector offsets of the centers of the circles from their particle
c             centers
              x_i(1) = 0.
              x_i(2) = 0.
              x_j(1) = 0.
              x_j(2) = 0.
            else
c-------------particle "i" - central circle.  
c             Particle "j" - satellite circle
              rad_i = cenrad*r_i
              rad_j = satrad*r_j
c
c-------------vector offsets of the centers of the circles from their particle
c             centers
              x_i(1) = 0.
              x_i(2) = 0.
              x_j(1) = r_j*(  cosa(m_j,1,rve)*cosbj(1)
     x                      - cosa(m_j,2,rve)*cosbj(2))
              x_j(2) = r_j*(  cosa(m_j,2,rve)*cosbj(1)
     x                      + cosa(m_j,1,rve)*cosbj(2))
            endif
          else
            if(m_j.eq.0) then
c-------------particle "i" is a  satellite circle.  
c             Particle "j" is a  central circle
              rad_i = satrad*r_i
              rad_j = cenrad*r_j
c
c-------------vector offsets of the centers of the circles from their particle
c             centers
              x_i(1) = r_i*(  cosa(m_i,1,rve)*cosbi(1)
     x                      - cosa(m_i,2,rve)*cosbi(2))
              x_i(2) = r_i*(  cosa(m_i,2,rve)*cosbi(1)
     x                      + cosa(m_i,1,rve)*cosbi(2))
              x_j(1) = 0.
              x_j(2) = 0.
            else
c-------------both circles are satellite circles
              rad_i = satrad*r_i
              rad_j = satrad*r_j
c
c-------------vector offsets of the centers of the circles from their particle
c             centers
              x_i(1) = r_i*(  cosa(m_i,1,rve)*cosbi(1)
     x                      - cosa(m_i,2,rve)*cosbi(2))
              x_i(2) = r_i*(  cosa(m_i,2,rve)*cosbi(1)
     x                      + cosa(m_i,1,rve)*cosbi(2))
              x_j(1) = r_j*(  cosa(m_j,1,rve)*cosbj(1)
     x                      - cosa(m_j,2,rve)*cosbj(2))
              x_j(2) = r_j*(  cosa(m_j,2,rve)*cosbj(1)
     x                      + cosa(m_j,1,rve)*cosbj(2))
            endif
          endif
c
c---------vector from center of the circle (arc) of the first particle to
c         the center of the circle (arc) of the second particle
          r(1) = rx(1) - x_i(1) + x_j(1)
          r(2) = rx(2) - x_i(2) + x_j(2)
c
c---------square of the distance between the two circle centers
          rijsq = r(1)**2 + r(2)**2
c
c---------sum of the two circle radii (plus the separation threshold)
          rsum = rad_i + rad_j + seprat
c
c---------are the particles touching?
          ltact = rijsq.lt.rsum**2
        endif
c
c
c-------in the event of a contact (ltact=.true.) and when we must find
c       certain geometric quantities (lgeom=.true.)
        if(lgeom .and. (ltact .or. lexep)) then
c---------compute various geometric quantities that will be needed to
c         find the contact forces and the moments acting upon the particles
c
c---------the distance between particle centers
          rij = sqrt(rijsq)
c
c---------the overlap between particles (twice the identation)
          ovrlap = rsum - rij
c
c---------the cosines of the outward normal vector at the contact of particle i
          c_eta(1) = r(1) / rij
          c_eta(2) = r(2) / rij
c
c---------the vector from the center of particle i
c         to the contact point
          l_i(1) = x_i(1) + r(1)*rad_i/rsum
          l_i(2) = x_i(2) + r(2)*rad_i/rsum
c
c---------the vector from the center of particle j
c         to the contact point
          l_j(1) = x_j(1) - r(1)*rad_j/rsum
          l_j(2) = x_j(2) - r(2)*rad_j/rsum
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine ovoids(a_i,a_j,betahi,betalo,
     1                  p1_i,p1_j,p2_i,p2_j,
     2                  r1_i,r1_j,r2_i,r2_j,ravg,rxcntr,seprat,tol,
     3                  m_i,m_j,lgeom,
     4        
     5                  c_eta,ovrlap,l_i,l_j,isweep,ltact)

c
c-------This subroutin determines whether two ovoids are in contact with
c       each other.  In the case of a near-neighbor search, it determines
c       whether the ovoids are within a distance 'sep' of each other.
c
c       Output from this subroutin includes the amount overlap between
c       the two ovoids, the location of the contact point relative to the
c       centers of the two particles, and the unit normal vector of the
c       contact point (see a more detailed description below).
c
c       Most of the variable names are consistent with notation in
c       the article: "A smooth convex three-dimensional particle for 
c       the discrete element method"
c
c--------Input
c
c        a_i()    The unit orientation vector of particle "i".  The vector
c                 is normal to the plane of the major circle of the torus.  
c                 That is, it is a unit vector aligned with the axis of
c                 the torus "i".  It is directed from the center of the 
c                 torus toward the first spherical cap (m_i=0).
c
c        a_j()    Ditto for particle "j"
c
c        betahi   threshold value of the cos(beta), separating the sphere
c        betalo   and torus pieces.  These values will actually differ from
c                 cos(beta) when a near-neighbor search is being performed.
c
c          p1_i   the "p1" offset of the centers of the spherical caps of
c                 particle "i" (p1 is negative for oblate ovoids)
c          p1_j   the "p1" offset of the centers of the spherical caps of
c                 particle "i"(p1 is negative for oblate ovoids)
c          p2_i   the "p2" radius of the major circle of torus "i" (p2 is
c                 negative for prolate ovoids)
c          p2_j   the "p2" radius of the major circle of torus "j" (p2 is
c                 negative for prolate ovoids)
c          r1_i   the radius of the spherical caps of particle "i"
c          r1_j   the radius of the spherical caps of particle "j"
c          r2_i   the radius of the minor circle torus "i"
c          r2_j   the radius of the minor circle torus "j"
c
c          ravg   the mean (radial) size of all of the particles
c
c   rx() -> y()   the vector between the components in particles "i" and "j".
c                 Note that this vector connects the centers of the
c                 component pieces of "i" and "j" (for example, from
c                 the center of a spherical cap to the center of a
c                 torus), rather than the centers of the two particles 
c                 themselves.
c
c        seprat   the threshold separation distance between particles
c                    =0 for contact detection
c                    >= for near-neighbor searches
c
c           tol   a convergence tolerance used in the iterative solution
c                 of the torus-torus contact detection problem
c
c           m_i   the number of the component that is being 
c                 investigated with particle "i":
c                   m_i = 0 for the top    spherical cap
c                   m_i = 1 for the bottom spherical cap
c                   m_i = 2 for the torus
c                
c           m_j   likewise, the number of the component that is being 
c                 investigated with particle "j"
c
c         lgeom   whether certain vectors required?  These vectors include
c                 c_eta, l_i, and l_j.  These would normally be required
c                 as output during contact detection, but would not be 
c                 required for near-neighbor detection
c
c-------Output
c
c         c_eta() the outward normal vector at the contact of particle i
c
c         l_i()  the vector from the center of particle i to the contact point
c
c         l_j()  the vector from the center of particle j to the contact point
c
c         ovrlap  the amount of overlap between the two particles
c
c         isweep  the number of iteration loops that were required for
c                 convergence with torus-torus contact detection
c
c         ltact   are the particles touching?  (or, perhaps, are they
c                 near-neighbors?)
c
c-------We will refer to equation numbers from the article: "A smooth
c       convex three-dimensional particle for the discrete element method"
c
        implicit double precision(a-h,o-z)
c
        parameter(msweep=100)
c
        double precision adotbi,adotbj,aidotrx,ajdotrx,adotyi,adotyj,
     x                   a_i,a_j,b,bsq,betahi,betalo,b_mag,
     x                   c,c_eta,cdotb,cosb,cosy,
     x                   d,denom,dif2,dif2n,dif2nn,diff2,dmag,
     x                   l_i,l_j,ovrlap,p1_i,p1_j,p2_i,p2_j,
     x                   perp,pfact,qmag,q_i,q_j,
     x                   qn_i,qn_j,qnn_i,qnn_j,
     x                   qo_i,qo_j,qon_i,qon_j,qonn_i,qonn_j,
     x                   r1_i,r1_j,r2_i,r2_j,
     x                   ravg,rsum,rxcntr,
     x                   seprat,seq_i,seq_j,seqn_i,seqn_j,tol,
     x                   y,y_mag,y_sqr
c
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 isweep,m_i,m_j,k
c
        logical lgeom,lpass,ls_s,ls_t,ltact,ltest
c
        dimension a_i(3),a_j(3),b(3),betahi(2),betalo(2),c(3),
     x            c_eta(3),cosb(3),cosy(3),d(3),l_i(3),l_j(3),
     x            rxcntr(3),q_i(3),q_j(3),qn_i(3),qn_j(3),
     x            qnn_i(3),qnn_j(3),
     x            qo_i(3),qo_j(3),qon_i(3),qon_j(3),qonn_i(3),qonn_j(3),
     x            seq_i(3,0:msweep),seq_j(3,0:msweep),
     x            seqn_i(3,0:msweep),seqn_j(3,0:msweep),
     x            y(3)
c
c-------initialize the logical variable ltact to the value "no contact"
        ltact = .false.
        lpass = .false.
c
c-------the number of iterations in torus-torus contact determination
        isweep = 0
c
c-------numbering scheme for the component pieces of each particle,
c       designated with "m_i" and "m_j" for the two particles
c         0 for the top    spherical cap
c         1 for the bottom spherical cap
c         2 for the torus
c       so that numbering is from 0 to 2
c
c-------rxcntr() is the vector that connects the center of particle "i"
c       to the center of particle "j"
c
c-------note that the center of the particular component piece
c       may be offset from the center of the particle.  Find the 
c       separation "y" between the centers of the two component
c       pieces.  We compute y in two steps.  Eq. 8. The first step:
        if(m_i.eq.0) then
          y(1) = rxcntr(1) - p1_i*a_i(1)
          y(2) = rxcntr(2) - p1_i*a_i(2)
          y(3) = rxcntr(3) - p1_i*a_i(3)
        elseif(m_i.eq.1) then
          y(1) = rxcntr(1) + p1_i*a_i(1)
          y(2) = rxcntr(2) + p1_i*a_i(2)
          y(3) = rxcntr(3) + p1_i*a_i(3)
        elseif(m_i.eq.2) then
          y(1) = rxcntr(1)
          y(2) = rxcntr(2)
          y(3) = rxcntr(3)
        endif
c
c-------Eq. 8, the second step:
        if(m_j.eq.0) then
          y(1) = y(1) + p1_j*a_j(1)
          y(2) = y(2) + p1_j*a_j(2)
          y(3) = y(3) + p1_j*a_j(3)
        elseif(m_j.eq.1) then
          y(1) = y(1) - p1_j*a_j(1)
          y(2) = y(2) - p1_j*a_j(2)
          y(3) = y(3) - p1_j*a_j(3)
        endif
c
c       Note that the vector "y" connects the centers of the two 
c       component pieces, NOT the centers of the particles themselves.
c
c-------we must consider three possible cases:  
c         1) a sphere-sphere combination
c         2) a sphere-torus combination
c         3) a torus-torus combination
c
c-------a sphere-sphere pair
        ls_s =  m_i.le.1 .and. m_j.le.1
c
c-------a sphere-torus pair
        ls_t = (m_i.le.1 .and. m_j.eq.2) .or.
     x         (m_i.eq.2 .and. m_j.le.1)
c
        if(ls_s) then
c---------a sphere-sphere combination
c
c---------the sum of the radii of the two spherical caps.  (We add the distance
c         seprat, which is equal to zero for contact detection, and equal
c         to "sep" for near neighbor detection)
          rsum = r1_i + r1_j + seprat
c
c---------square of the distance between the centers of the two pieces
          y_sqr = y(1)**2 + y(2)**2 + y(3)**2
c
c---------compare the two squared distances to see if the particles could
c         be contacting (or could be near neighbors, depending on the
c         value of seprat).  Eq. 14.
          if(y_sqr.lt.rsum**2) then
c-----------the distance between the centers of the two spherical caps
            y_mag = sqrt(y_sqr)
c
c-----------the direction cosines of the vector between the centers of
c           the two spherical caps.  Note that the vector "y" connects the
c           centers of the two component pieces (i.e., the two spherical
c           caps), NOT the centers of the
c           particles themselves.
            cosy(1) = y(1) / y_mag
            cosy(2) = y(2) / y_mag
            cosy(3) = y(3) / y_mag
c
c-----------the dot product of two unit vectors: the axial direction of
c           ovoid "i" and the direction between the centers of 
c           the two spheres
            adotyi = a_i(1)*cosy(1) + a_i(2)*cosy(2) + a_i(3)*cosy(3)
c
c-----------Eq. 15
            if(m_i.eq.0) then
c-------------the contact is oriented toward the top of particle "i"
              ltact =  adotyi.ge.betahi(1)
            else
c-------------the contact is oriented toward the bottom of particle "i"
              ltact = -adotyi.ge.betahi(1)
            endif
c
            if(ltact) then
c-------------the dot product for particle "j".  Note that the direction
c             between sphere "j" to sphere "i" is -y()
              adotyj = a_j(1)*cosy(1) + a_j(2)*cosy(2) +
     x                 a_j(3)*cosy(3)
              adotyj = -adotyj
c
c-------------Eq. 16:
              if(m_j.eq.0) then
c---------------the contact is oriented toward the top of particle "j"
                ltact =  adotyj.ge.betahi(1)
              else
c---------------the contact is oriented toward the bottom of particle "j"
                ltact = -adotyj.ge.betahi(1)
              endif
c
c-------------check to see whether contact is on the "correct sides" of the
c             two spheres.  Eqs. 18 and 17:
              ovrlap = rsum - y_mag
c             ltact = ltact .and. ovrlap.lt.ravg
c
c-------------
              if(ltact) then
                aidotrx = a_i(1)*rxcntr(1) + 
     x                    a_i(2)*rxcntr(2) + 
     x                    a_i(3)*rxcntr(3)
                ajdotrx = a_j(1)*rxcntr(1) +
     x                    a_j(2)*rxcntr(2) +
     x                    a_j(3)*rxcntr(3)
c
                ltact = ((m_i.eq.1 .and. aidotrx.lt.0.) .or.
     x                   (m_i.eq.0 .and. aidotrx.gt.0.)     ) .and.
     x                  ((m_j.eq.1 .and. ajdotrx.gt.0.) .or.
     x                   (m_j.eq.0 .and. ajdotrx.lt.0.)     )
              endif
            endif
          endif
        elseif(ls_t) then
c---------a sphere-torus combination
c
          if(m_i.eq.2) then
c-----------the component of the first particle (particle "i") is a torus.
c           The second ("j") particle's component is a spherical cap
c
c-----------find the projection of the vector (from the center of torus "i"
c           to the center of sphere "j", i.e. the vector "y") onto the 
c           central plane of torus "i" (with normal vector "a_i"):
c
c-----------the projection of "y" onto the unit axial vector "a_i", 
c           which is the unit axial vector for particle "i"
            adotyi = a_i(1)*y(1) + a_i(2)*y(2) + a_i(3)*y(3)
c
c-----------subtract this normal component of "y" from the original 
c           vector "y".  This will leave only the component of "y" in the 
c           plane of torus "i".  Eq. 23:
            d(1) = y(1) - adotyi*a_i(1)
            d(2) = y(2) - adotyi*a_i(2)
            d(3) = y(3) - adotyi*a_i(3)
c
c-----------the length of this vector
            dmag = sqrt(d(1)**2 + d(2)**2 + d(3)**2)
c
c-----------we will now scale "d" so that its length is equal to the radius
c           of torus "i".  The resulting "c" vector connects the center
c           of torus "i" to the point on its major circle that is
c           nearest to the spherical cap of particle "j". Eq. 24.
            pfact = p2_i / dmag
            c(1) = pfact * d(1)
            c(2) = pfact * d(2)
            c(3) = pfact * d(3)
c
c-----------we now subtract the new "p" vector from the vector that connects
c           the center of the torus "i" to the center of the spherical 
c           cap "j" (i.e. vector "y").  This vector will be a radial vector 
c           for two different objects: the spherical cap, and the minor 
c           circle that surrounds the major circle at the closest point.  
c           We can use this vector to directly test whether the torus 
c           and sphere are touching.  The vector is directed from "i" to "j".
c           Eq. 22.
            b(1) = y(1) - c(1)
            b(2) = y(2) - c(2)
            b(3) = y(3) - c(3)
c
c-----------the squared length of the vector
            bsq = b(1)**2 +  b(2)**2 +  b(3)**2
c
c-----------the sum of two radii:  the spherical cap, and the torus minor
c           circle that surrounds its major circle.   (We add the distance
c           seprat, which is equal to zero for contact detection, and equal
c           to "sep" for near neighbor detection)
            rsum = r2_i + r1_j + seprat
c
c-----------now test whether the two objects are touching (the torus and
c           the sphere)
c
c-----------First, check the separation of the centers of the torus and sphere.
c           Eq. 25.
            if(bsq.lt.rsum**2) then
c-------------a dot product to check whether the nearest point is on the
c             correct side of the torus
              cdotb = c(1)*b(1) + c(2)*b(2) + c(3)*b(3)
c
c-------------now check whether the nearest point is on the correct side
c             of both pieces. Eq. 26.
              if(p2_i*cdotb.ge.0.) then
c
c---------------they are touching.  But are the torus and spherical caps
c               touching within their respective ranges of beta?
c
c---------------the distance between the centers of the two objects
                b_mag = sqrt(bsq)
c
c---------------the directions cosines of the vector between the centers of
c               the two circles
                cosb(1) = b(1) / b_mag
                cosb(2) = b(2) / b_mag
                cosb(3) = b(3) / b_mag
c
c---------------the dot product with the axial unit vector of particle "i"
                adotbi =   a_i(1)*cosb(1) + a_i(2)*cosb(2) +
     x                     a_i(3)*cosb(3)
c
c---------------check the range of particle "i".  Eq. 27.
                ltact =  abs(adotbi).lt.betalo(1)
c
c---------------check the range of particle "j"
                if(ltact) then
c-----------------the dot product with the axial unit vector of particle "j".
                  adotbj = a_j(1)*b(1) + a_j(2)*b(2) + a_j(3)*b(3)
c
c-----------------We use the negative, since the vector emmanates from
c                 particle "i", not particle"j"
                  adotbj = -adotbj/b_mag
c
c-----------------Eq. 28
                  if(m_j.eq.0) then
                    ltact =   adotbj.ge.betahi(1)
                  else
                    ltact =  -adotbj.ge.betahi(1)
                  endif
c
c-----------------one more check, in the event that the radius of the
c                 spheres is larger than the particle height
                  if(ltact) then
c                   rxdota = rxcntr(1)*a_j(1) + rxcntr(2)*a_j(2) +
c    x                       rxcntr(3)*a_j(3)
c
c                   ltact = (rxdota.le.0. .and. m_j.eq.0) .or.
c    x                      (rxdota.ge.0. .and. m_j.eq.1)
c
                    ltact = b_mag .gt. r1_j .and. b_mag .gt. r2_i
                  endif
                endif
              endif
            endif
          elseif(m_j.eq.2) then
c-----------the component of the first particle (particle "i") is a 
c           a spherical cap.  The second ("j") particle's component is 
c           a torus.  This is the opposite arrangement as the one above
c
c-----------find the projection of the vector (from the center of torus "j"
c           to the center of sphere "i", i.e. the vector "-y") onto the 
c           plane of torus "j" (with normal vector "a_j":
c
c-----------the projection onto the unit axial vector "a_j"
            adotyj = -(a_j(1)*y(1) + a_j(2)*y(2) + a_j(3)*y(3))
c
c-----------subtract this normal component of "y" from the vector "y".
c           This will leave only the component in the plane of torus "j"
c           We use the negative of "y", since vector "y" emmanates from
c           particle "i", not particle"j"
            d(1) = -(y(1) + adotyj*a_j(1))
            d(2) = -(y(2) + adotyj*a_j(2))
            d(3) = -(y(3) + adotyj*a_j(3))
c
c-----------the length of this vector
            dmag = sqrt(d(1)**2 + d(2)**2 + d(3)**2)
c
c-----------we will now scale "p" so that its length is equal to the radius
c           of torus "j".  The resulting "p" vector connects the center
c           of torus "j" to the point on its major circle that is
c           nearest to the spherical cap of particle "i"
            pfact = p2_j / dmag
            c(1) = pfact * d(1)
            c(2) = pfact * d(2)
            c(3) = pfact * d(3)
c
c-----------we now subtract the new "p" vector from the vector that connects
c           the center of the torus "j" to the center of the 
c           spherical cap "i" (i.e. vector "y").  This vector will be 
c           a radial vector for two different objects: the spherical cap, 
c           and the minor circle that surrounds its major circle at
c           its closest point to the sphere.  It is directed from 
c           particle "j" toward particle "i".  We can use this vector to 
c           directly test whether the torus and sphere are touching
            b(1) = -y(1) - c(1)
            b(2) = -y(2) - c(2)
            b(3) = -y(3) - c(3)
c
c-----------the squared length of the vector
            bsq = b(1)**2 + b(2)**2 + b(3)**2
c
c-----------the sum of two radii:  the spherical cap, and the minor 
c           circle that surrounds its major circle.  (We add the distance
c           seprat, which is equal to zero for contact detection, and equal
c           to "sep" for near neighbor detection)
            rsum = r1_i + r2_j + seprat
c
c-----------now test whether the two objects (torus and sphere) are touching
            if(bsq.lt.rsum**2) then
c
c-------------a dot product to check whether the nearest point is on the
c             correct side of the torus
              cdotb = c(1)*b(1) + c(2)*b(2) + c(3)*b(3)
c
c-------------now check whether the nearest point is on the correct side
c             of the torus
              if(p2_j*cdotb.ge.0.) then
c---------------they are touching.  But are the torus and spherical caps
c               touching within the ranges of their composite particles?
c
c---------------the distance between the centers of the two objects
                b_mag = sqrt(bsq)
c
c---------------the directions cosines of the vector between the centers of
c               the two circles
                cosb(1) = b(1) / b_mag
                cosb(2) = b(2) / b_mag
                cosb(3) = b(3) / b_mag
c
c---------------the dot product with the axial unit vector or particle "j"
                adotbj = a_j(1)*cosb(1) + a_j(2)*cosb(2) +
     x                   a_j(3)*cosb(3) 
c
c---------------check the range of particle "j"
                ltact = abs(adotbj).lt.betalo(1)
c
c---------------check the range of particle "i"
                if(ltact) then
c-----------------the dot product with the axial unit vector or particle "i".
                  adotbi = a_i(1)*b(1) + a_i(2)*b(2) + a_i(3)*b(3)
c
c-----------------The negative is because cosb is directed from "j" to "i".
                  adotbi = -adotbi/b_mag
                  if(m_i.eq.0) then
                    ltact =  adotbi.ge.betahi(1)
                  else
                    ltact = -adotbi.ge.betahi(1)
                  endif
c
c-----------------one more check, in the event that the radius of the
c                 spheres is larger than the particle height
                  if(ltact) then
c                   rxdota = rxcntr(1)*a_i(1) + rxcntr(2)*a_i(2) +
c    x                       rxcntr(3)*a_i(3)
c
c                   ltact = (rxdota.le.0. .and. m_i.eq.1) .or.
c    x                      (rxdota.ge.0. .and. m_i.eq.0)
c
                    ltact = b_mag .gt. r1_i .and. b_mag .gt. r2_j
                  endif
                endif
              endif
            endif
          endif
        else
c---------a torus-torus combination
c
          if(betahi(1).gt.0.0001d0) then
            y_mag = sqrt(y(1)**2 + y(2)**2 + y(3)**2)
            ltest = .false.
          else
            ltest = .true.
          endif
c
c---------seed the iteration process.  "q_j" is a vector from the the
c         center of torus "i" to a point on the major circle of torus "j".
c         Note that with this initial iteration, "y" really doesn't satisfy
c         this criteria, but it is simply a starting value.  (Fig. 10, line 3)
          q_j(1) = y(1)
          q_j(2) = y(2)
          q_j(3) = y(3)
c
c---------another seed. "q_i" is a vector from the the
c         center of torus "j" to a point on the major circle of torus "i".
c         (Fig. 10, line 2)
          q_i(1) = 0.
          q_i(2) = 0.
          q_i(3) = 0.
c
          qon_i(1) = 0.
          qon_i(2) = 0.
          qon_i(3) = 0.
          qon_j(1) = 0.
          qon_j(2) = 0.
          qon_j(3) = 0.
c
          qonn_i(1) = 0.
          qonn_i(2) = 0.
          qonn_i(3) = 0.
          qonn_j(1) = 0.
          qonn_j(2) = 0.
          qonn_j(3) = 0.
c
          dif2 = 100.d0 * ravg
          dif2n = dif2
          dif2nn = dif2
c
c---------the number of iterations that have been performed
          isweep = 0
c
c---------here we enter a iterative loop to find the points of
c         minimum (or maximum) distance between the two circles
c
c---------check for convergence, but do not iterate more than "msweep" times
          do while(dif2.gt.tol .and. isweep.le.msweep)
c
c-----------store the previous values of these vectors so that we can later
c           test for convergence
            qo_i(1) = q_i(1)
            qo_i(2) = q_i(2)
            qo_i(3) = q_i(3)
            qo_j(1) = q_j(1)
            qo_j(2) = q_j(2)
            qo_j(3) = q_j(3)
c
c-----------the projection of "q_j" onto the unit axial vector "a_i" 
c           of particle "i" (Fig. 10, line 9)
            perp = a_i(1)*q_j(1) + a_i(2)*q_j(2) + a_i(3)*q_j(3)
c
c-----------subtract this normal component of "q_j" from the vector "q_j".
c           This will leave only the component in the plane of torus "i"
c           (Fig. 10, line 9)
            q_i(1) = q_j(1) - perp*a_i(1)
            q_i(2) = q_j(2) - perp*a_i(2)
            q_i(3) = q_j(3) - perp*a_i(3)
c
c-----------the length of this vector
            qmag = sqrt(q_i(1)**2 + q_i(2)**2 + q_i(3)**2)
c
c-----------we will now scale "q_i" so that its length is equal to 
c           the radius of torus "i".  The resulting "q_i" vector 
c           connects the center of torus "i" to the point on it 
c           major circle that is nearest to torus "j" (Fig. 10, line 10)
            pfact = p2_i / qmag
            q_i(1) = pfact * q_i(1)
            q_i(2) = pfact * q_i(2)
            q_i(3) = pfact * q_i(3)
c
c-----------change the previously computed vector (from the center of torus "i"
c           to a point on its major circle).  When used as input for 
c           torus "j" (below), we will want this vector to emmanate 
c           from the center of torus "j" (Fig. 10, line 10)
            q_i(1) = q_i(1) - y(1)
            q_i(2) = q_i(2) - y(2)
            q_i(3) = q_i(3) - y(3)
c
c-----------now switch to particle "j"
c
c-----------the projection onto the axial vector "a_j" of particle "j"
            perp = a_j(1)*q_i(1) + a_j(2)*q_i(2) + a_j(3)*q_i(3)
c
c-----------subtract this normal component of "q" from the vector "q".
c           This will leave only the component in the plane of torus "j"
            q_j(1) = q_i(1) - perp*a_j(1)
            q_j(2) = q_i(2) - perp*a_j(2)
            q_j(3) = q_i(3) - perp*a_j(3)
c
c-----------the length of this vector
            qmag = sqrt(q_j(1)**2 + q_j(2)**2 + q_j(3)**2)
c
c-----------we will now scale "q_j" so that its length is equal to 
c           the radius of torus "j".  The resulting "q_j" vector 
c           connects the center of torus "j" to the point on its
c           major circle that is nearest to torus "i"
            pfact = p2_j / qmag
            q_j(1) = pfact * q_j(1)
            q_j(2) = pfact * q_j(2)
            q_j(3) = pfact * q_j(3)
c
c-----------change the previously computed vector (from the center of torus "j"
c           to a point on its major circle).  When used as input for torus "i" 
c           (above) we will want this vetor to emmanate from torus "i"
            q_j(1) = q_j(1) + y(1)
            q_j(2) = q_j(2) + y(2)
            q_j(3) = q_j(3) + y(3)
c
c-----------create a historic sequence of the q_i() values for this
c           pair of ovoids, so that we can later apply Aitken's acceleration
            seq_i(1,isweep) = q_i(1)
            seq_i(2,isweep) = q_i(2)
            seq_i(3,isweep) = q_i(3)
            seq_j(1,isweep) = q_j(1)
            seq_j(2,isweep) = q_j(2)
            seq_j(3,isweep) = q_j(3)
c
            if(isweep.ge.3) then
c
c-------------On the third iteration, begin applying Aitkens acceleration
c
              if(isweep.eq.3) then
                qn_i(1) = q_i(1)
                qn_i(2) = q_i(2)
                qn_i(3) = q_i(3)
                qn_j(1) = q_j(1)
                qn_j(2) = q_j(2)
                qn_j(3) = q_j(3)
              endif
c
              do 100 k = 1,3
                qon_i(k) = qn_i(k)
                qon_j(k) = qn_j(k)
c
                denom = seq_i(k,isweep) - 2*seq_i(k,isweep-1) +
     x                  seq_i(k,isweep-2)
                if(denom.ne.0.) then
                  qn_i(k) = seq_i(k,isweep-2) -
     x                      (seq_i(k,isweep-1) - seq_i(k,isweep-2))**2 /
     x                      denom
                else
                  qn_i(k) = seq_i(k,isweep)
                endif
c
                denom = seq_j(k,isweep) - 2*seq_j(k,isweep-1) +
     x                  seq_j(k,isweep-2)
                if(denom.ne.0.) then
                  qn_j(k) = seq_j(k,isweep-2) -
     x                      (seq_j(k,isweep-1) - seq_j(k,isweep-2))**2 /
     x                      denom
                else
                  qn_j(k) = seq_j(k,isweep)
                endif
  100         continue
c
c-------------create a historic sequence of the q_i() values for this
c             pair of ovoids, so that we can later apply Aitken's
c             acceleration
              seqn_i(1,isweep) = qn_i(1)
              seqn_i(2,isweep) = qn_i(2)
              seqn_i(3,isweep) = qn_i(3)
              seqn_j(1,isweep) = qn_j(1)
              seqn_j(2,isweep) = qn_j(2)
              seqn_j(3,isweep) = qn_j(3)
c
              if(isweep.ge.5) then
c
c---------------On the fifth iteration, begin applying Aitkens acceleration
c               to the Aitkens acceleration sequence
c
                if(isweep.eq.5) then
                  qnn_i(1) = qn_i(1)
                  qnn_i(2) = qn_i(2)
                  qnn_i(3) = qn_i(3)
                  qnn_j(1) = qn_j(1)
                  qnn_j(2) = qn_j(2)
                  qnn_j(3) = qn_j(3)
                endif
c
                do 101 k = 1,3
                  qonn_i(k) = qnn_i(k)
                  qonn_j(k) = qnn_j(k)
c
                  denom = seqn_i(k,isweep) - 2*seqn_i(k,isweep-1) +
     x                    seqn_i(k,isweep-2)
                  if(denom.ne.0.) then
                    qnn_i(k) = seqn_i(k,isweep-2) -
     x                    (seqn_i(k,isweep-1) - seqn_i(k,isweep-2))**2 /
     x                    denom
                  else
                    qnn_i(k) = seqn_i(k,isweep)
                  endif
c
                  denom = seqn_j(k,isweep) - 2*seqn_j(k,isweep-1) +
     x                    seqn_j(k,isweep-2)
                  if(denom.ne.0.) then
                    qnn_j(k) = seqn_j(k,isweep-2) -
     x                    (seqn_j(k,isweep-1) - seqn_j(k,isweep-2))**2 /
     x                    denom
                  else
                    qnn_j(k) = seqn_j(k,isweep)
                  endif
  101           continue
              else
                qnn_i(1) = qn_i(1)
                qnn_i(2) = qn_i(2)
                qnn_i(3) = qn_i(3)
                qnn_j(1) = qn_j(1)
                qnn_j(2) = qn_j(2)
                qnn_j(3) = qn_j(3)
              endif
c
            else
              qnn_i(1) = q_i(1)
              qnn_i(2) = q_i(2)
              qnn_i(3) = q_i(3)
              qnn_j(1) = q_j(1)
              qnn_j(2) = q_j(2)
              qnn_j(3) = q_j(3)
            endif
c
            dif2 = (q_i(1) - qo_i(1))**2 +
     x             (q_i(2) - qo_i(2))**2 + (q_i(3) - qo_i(3))**2 +
     x             (q_j(1) - qo_j(1))**2 +
     x             (q_j(2) - qo_j(2))**2 + (q_j(3) - qo_j(3))**2
c
            dif2n = (qn_i(1) - qon_i(1))**2 +
     x              (qn_i(2) - qon_i(2))**2 + (qn_i(3) - qon_i(3))**2 +
     x              (qn_j(1) - qon_j(1))**2 +
     x              (qn_j(2) - qon_j(2))**2 + (qn_j(3) - qon_j(3))**2
c
            dif2nn = (qnn_i(1) - qonn_i(1))**2 + 
     x           (qnn_i(2) - qonn_i(2))**2 + (qnn_i(3) - qonn_i(3))**2 +
     x           (qnn_j(1) - qonn_j(1))**2 +
     x           (qnn_j(2) - qonn_j(2))**2 + (qnn_j(3) - qonn_j(3))**2
c
            isweep = isweep + 1
          end do
c
          if(dif2nn .le. dif2n .and. dif2nn .le. dif2) then
            q_i(1) = qnn_i(1)
            q_i(2) = qnn_i(2)
            q_i(3) = qnn_i(3)
            q_j(1) = qnn_j(1)
            q_j(2) = qnn_j(2)
            q_j(3) = qnn_j(3)
            diff2 = dif2nn
          elseif(dif2n .le. dif2nn .and. dif2n .le. dif2) then
            q_i(1) = qn_i(1)
            q_i(2) = qn_i(2)
            q_i(3) = qn_i(3)
            q_j(1) = qn_j(1)
            q_j(2) = qn_j(2)
            q_j(3) = qn_j(3)
            diff2 = dif2n
          else
            q_i(1) = q_i(1)
            q_i(2) = q_i(2)
            q_i(3) = q_i(3)
            q_j(1) = q_j(1)
            q_j(2) = q_j(2)
            q_j(3) = q_j(3)
            diff2 = dif2
          endif
c
          if(isweep.gt.msweep) then
c-----------In some (very rare) cases, the torus-torus contact inquiry
c           iteration will not converge.  In particular, this can occur
c           when the two (major) circles are aligned in a pathologic manner:
c           the (perpendicular) axes of the two circles are colinear or
c           are very nearly colinear.  If this is the case, then the
c           question of contact between two (convex) ovoids depends upon
c           whether the spherical caps are touching, since the two
c           torii can not be touching within their portions of the ovoids.
c           So we will determine whether this pathologic case has occured.
c
            aijdot = a_i(1)*a_j(1)+a_i(2)*a_j(2)+a_i(3)*a_j(3)
            aiydot = (a_i(1)*y(1) + a_i(2)*y(2) + a_i(3)*y(3)) 
     x               / sqrt(y(1)*y(1) + y(2)*y(2) + y(3)*y(3))
            if(abs(aijdot).gt.0.99d0 .and. abs(aiydot).gt.0.99d0) then
              ltact = .false.
            elseif(diff2.lt.sqrt(tol)) then
              lpass = .true.
            else
c             print *,' Torus-torus contact did not converge'
            endif
          else
            lpass = .true.
          endif
c         endif
c
          if(lpass) then
c
c-----------vector that joins the two nearest points of the torus circles.
c           Eq. 33.
            b(1) = q_j(1) - (y(1) + q_i(1))
            b(2) = q_j(2) - (y(2) + q_i(2)) 
            b(3) = q_j(3) - (y(3) + q_i(3)) 
c
c-----------the squared length of the vector
            bsq = b(1)**2 +  b(2)**2 +  b(3)**2
c
c-----------the sum of two minor radii (We add the distance
c           seprat, which is equal to zero for contact detection, and equal
c           to "sep" for near neighbor detection)
            rsum = r2_i + r2_j + seprat
c
c-----------now test whether the two objects are touching.  Eq. 34.
            if(bsq.lt.rsum**2) then
c
c-------------so they are touching.  But are they touching on the correct
c             sides of the toruses?  Eqs. 35 and 36.
              if(p2_i*(b(1)*(y(1)+q_i(1)) + 
     x                 b(2)*(y(2)+q_i(2)) + 
     x                 b(3)*(y(3)+q_i(3))).ge.0. .and.
     x           p2_j*(b(1)*(q_j(1)-y(1)) + 
     x                 b(2)*(q_j(2)-y(2)) + 
     x                 b(3)*(q_j(3)-y(3))).le.0.) then
c
c---------------Are the torus and spherical caps
c               touching within the ranges of their composite particles?
c
c---------------the distance between the centers of the two objects
                b_mag = sqrt(bsq)
c
c---------------the directions cosines of the vector between the centers of
c               the two minor circles
                cosb(1) = b(1) / b_mag
                cosb(2) = b(2) / b_mag
                cosb(3) = b(3) / b_mag
c
c---------------the dot product with the axial unit vector or particle "i"
                adotbi =   a_i(1)*cosb(1) + a_i(2)*cosb(2) +
     x                     a_i(3)*cosb(3)
c
c---------------the dot product with the axial unit vector or particle "j"
                adotbj = -(a_j(1)*cosb(1) + a_j(2)*cosb(2) +
     x                     a_j(3)*cosb(3))
c
c---------------check the range of particles "i" and "j".  Eqs. 37 and 38.
                ltact =  abs(adotbi).lt.betalo(1) .and.
     x                   abs(adotbj).lt.betalo(1)
              endif
            endif
          endif
        endif
c
c-------in the event of a contact (ltact=.true.) and when we must find
c       certain geometric quantities (lgeom=.true.)
        if(ltact .and. lgeom) then
c---------compute various geometric quantities that will be needed to
c         find the contact forces and the moments acting upon the particles
c
          if(ls_s) then
c-----------a sphere-sphere combination
c
c-----------the overlap between particles (twice the identation) has already
c           been computed above.  Eq. 18.
c           ovrlap = rsum - y_mag
c
            do 834 k = 1,3
c-------------the outward normal vector at the contact of particle i.
c             Eq. 19.
              c_eta(k) = cosy(k)
c
c-------------the vector from the center of particle i
c             to the contact point.  Eq. 20.
              if(m_i.eq.0) then
                l_i(k) = y(k)*r1_i/rsum + p1_i*a_i(k)
              else
                l_i(k) = y(k)*r1_i/rsum - p1_i*a_i(k)
              endif
c
c-------------the vector from the center of particle j
c             to the contact point.  Eq. 21.
              if(m_j.eq.0) then
                l_j(k) = -(y(k)*r1_j/rsum - p1_j*a_j(k))
              else
                l_j(k) = -(y(k)*r1_j/rsum + p1_j*a_j(k))
              endif
  834       continue
          elseif(ls_t) then
c-----------a sphere-torus combination
c
c-----------the overlap between particles (twice the identation).  Eq. 29.
            ovrlap = rsum - b_mag
c
            if(m_i.eq.2) then
c-------------the component of the first particle (particle "i") is a torus.
c             The second ("j") particle's component is a spherical cap
c
              do 837 k = 1,3
c---------------the vector from the center of particle "i"
c               to the contact point.  Equal to the radial vector
c               from the arc center minus the vector between the
c               arc center and the particle center.  Eq. 31.
                l_i(k) = c(k) + r2_i/rsum*b(k)
c
c---------------the vector from the center of particle "j"
c               to the contact point.  Eq. 32.
                if(m_j.eq.0) then
                  l_j(k) = -(r1_j/rsum*b(k) - p1_j*a_j(k))
                else
                  l_j(k) = -(r1_j/rsum*b(k) + p1_j*a_j(k))
                endif
c
c---------------the outward normal vector at the contact of particle i.
c               Eq. 30.
                c_eta(k) = cosb(k)
  837         continue
            elseif(m_j.eq.2) then
c-------------the component of the second particle (particle "j") is a torus.
c             The first ("i") particle's component is a spherical cap
c
              do 839 k = 1,3
c---------------the vector from the center of particle i
c               to the contact point.  Equal to the radial vector
c               from the arc center minus the vector between the
c               arc center and the particle center
                if(m_i.eq.0) then
                  l_i(k) = -(r1_i/rsum*b(k) - p1_i*a_i(k))
                else
                  l_i(k) = -(r1_i/rsum*b(k) + p1_i*a_i(k))
                endif
c
c---------------the vector from the center of particle j
c               to the contact point 
                l_j(k) = c(k) + r2_j/rsum*b(k)
c
c---------------the outward normal vector at the contact of particle i
                c_eta(k) = -cosb(k)
  839         continue
            endif
          else
c-----------a torus-torus combination
c
c-----------the overlap between particles (twice the identation).  Eq. 39.
            ovrlap = rsum - b_mag
c
            do 840 k = 1,3
c-------------the vector from the center of particle i
c             to the contact point.  Equal to the radial vector
c             from the arc center minus the vector between the
c             arc center and the particle center.  Eq. 40.
              l_i(k) = y(k) + q_i(k) + r2_i/rsum*b(k)
c
c-------------the vector from the center of particle j
c             to the contact point.  Eq. 40.
              l_j(k) = -y(k) + q_j(k) - r2_j/rsum*b(k)
c
c-------------the outward normal vector at the contact of particle i.  Eq. 40.
              c_eta(k) = cosb(k)
  840       continue
          endif
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine bumpy(r_i, r_j,
     x                 b_rad, s_rad, xlocal,
     x                 rx, Rot_i, Rot_j, m_i, m_j,
     x                 lgeom,lexep,seprat,
     x                 c_eta,ovrlap,l_i,l_j,ltact,
     x                 rve, mrve)
c
c-------This subroutin determines whether two "bumpy" particles are 
c       in contact with each other.  In the case of a near-neighbor 
c       search, it determines whether the particles are within a 
c       distance 'sep' of each other.
c
c-------Output from this subroutin includes the amount overlap between
c       the two bumpy particles, the location of the contact point 
c       relative to the centers of the two particles, and the unit 
c       normal vector of the contact point (see a more detailed 
c       description below).
c
c-------A bumpy particle is a non-convex shape that is the union of a set
c       of spheres.  The set includes a central sphere and several
c       satellite spheres.  The number of satellite spheres is the input
c       variable "nbumps", so that the total number of spheres is 
c       nbumps+1.  The satellite spheres are centered on a circumsphere
c       of radius "cirrad*rad()".  The satellite spheres have radius 
c       satrad*rad().  The central sphere has radius cenrad*rad().
c       Although they are included as arguments in this subroutin,
c       they are defined as follows:
c         cenrad   The radius of the central sphere, for a particle of
c                  unit rad(igrain).  That is the radius of the
c                  central sphere is cenrad*rad(igrain)
c         satrad   The radius of the satellite spheres, for a particle of
c                  unit rad(igrain).  That is, the radius of the
c                  satellite spheres is satrad*rad(igrain)
c         cirrad   The radius of the sphere on which the satellite
c                  spheres are centered, for a particle of
c                  unit rad(igrain).  That is, cirrad*rad(igrain) is 
c                  the radius of the circumsphere of satellite centers.
c
c       Note that this subroutin assumes that all particles have the 
c       same shape (cirrad, cenrad, satrad, s_rad, b_rad, xlocal) but 
c       can have different sizes (r_i and r_j)
c
c-------Input-----------------
c
c       r_i         nominal radius of particle "i", as "rad(igrain)"
c       r_j         nominal radius of particle "j", as "rad(jgrain)"
c       s_rad(0:mbumps) is the radius of each component sphere, for a
c                       particle of unit radius
c                       = cenrad for the central partcles, 
c                       = cirrad for the satellite particles
c                       Must be multiplied by "rad(igrain)" to find
c                       the radius for a particular particle.
c       b_rad(0:nbumps) is the distance (radius) from the center of the
c                       particle to the center of the component sphere,
c                       for a particle of unit radius
c                       = 0. for the central particle
c                       = cirrad for the satellite spheres
c                       Must be multiplied by "rad(igrain)" to find
c                       the radius for a particular particle.
c       xlocal(0:nbumps,3) is the location of the centers of the component
c                          spheres in the local frame of the particle
c       rx()        the vector from the center of particle "i" to the center 
c                   of particle "j"
c       Rot_i(3,3)  Rotation matrix for particle "i":  x = Rot_i*x', 
c                   where x' is a 3-vector in the local frame of the 
c                   particle, which is rotated to vector x in the global 
c                   frame of the assembly
c       Rot_j(3,3)  Rotation matrix for particle "j"
c       m_i         the number of the component that is being 
c                   investigated with particle "i":
c                     m_i = 0 for the central sphere
c                     m_i = 1:nbumps for the satellite spheres
c       m_j         likewise, the number of the component that is being 
c                   investigated with particle "j"
c       lgeom       logical, whether certain vectors required?  These 
c                   vectors include c_eta, l_i, and l_j.  These would normally 
c                   be required as output during contact detection, but would 
c                   not be required for near-neighbor detection
c       lexep       logical, to force the reporting of contact indentation
c       seprat      the threshold separation distance between particles
c                      =0 for contact detection
c                      >= for near-neighbor searches
c
c-------Output-----------------
c
c       c_eta() the outward normal vector at the contact of particle i
c       l_i()   the vector from the center of particle i to the contact point
c       l_j()   the vector from the center of particle j to the contact point
c       ovrlap  the overlap (distance) between the two particles
c       ltact   are the particles touching?  (or, perhaps, are they
c               near-neighbors?)
c------------------------------
c
        implicit integer*2(i-n)
        implicit double precision(a-h,o-z)
c
        double precision b_rad, c_eta, l_i, l_j, ovrlap,
     x                   r, r_i, r_j, rad_i, rad_j, 
     x                   rij, rijsq, rsum, rx,
     x                   s_rad, seprat,
     x                   x_i, x_j, xlocal, xlocal3
        integer*2 rve,mrve
        integer*4 ixg,m_i,m_j,mbumps
        logical lexep,lgeom,ltact
c
        parameter (mbumps=8)
c
        dimension b_rad(0:mbumps,0:mrve),c_eta(3), l_i(3),l_j(3),
     x            r(3),Rot_i(3,3), Rot_j(3,3),
     x            rx(3),s_rad(0:mbumps,0:mrve),x_i(3),x_j(3),
     x            xlocal(0:mbumps,3,0:mrve), xlocal3(3)
c
c
c-------initialize the logical variable ltact to the value "no contact"
        ltact = .false.
c
        if(m_i.ne.0) then
c---------compute vector "x_i", from the center of the particle to the
c         center of the component sphere, for particle "i".  Vector x_i 
c         has components in the global coordinate system.
c
c---------we must rotate vector "xlocal3" which, like "x_i" is from the
c         center of the particle to the center of the components sphere,
c         but "xlocal3" has components in the local coordinate system of
c         the particle of particle "i".
c
c---------extract the vector from the center of the particle to the center
c         of the particular (m_i) sphere, in the particles local frame
          xlocal3(1) = xlocal(m_i,1,rve)
          xlocal3(2) = xlocal(m_i,2,rve)
          xlocal3(3) = xlocal(m_i,3,rve)
c
c---------this flag is used in subroutin QMatrixRotateVector to determine
c         whether a forward or reverse (inverse) rotation is applied
          ixg = 2
c
c---------use this subroutin to rotate the vector from the center of
c         particle "i" to the center of the satellite sphere.  This
c         vector, initially in the local frame, must be rotated into
c         the global frame
          call QMatrixRotateVector(Rot_i, x_i, xlocal3, ixg)
c
c---------scale the vector by the particle size r_i=rad(igrain) and by
c         b_rad=cirrad
          x_i(1) = r_i*b_rad(m_i,rve)*x_i(1)
          x_i(2) = r_i*b_rad(m_i,rve)*x_i(2)
          x_i(3) = r_i*b_rad(m_i,rve)*x_i(3)
        else
c---------for the central sphere (m_i=0), the center of the sphere and
c         the center of the particle coincide
          x_i(1) = 0.d0
          x_i(2) = 0.d0
          x_i(3) = 0.d0
        endif
c
        if(m_j.ne.0) then
c---------compute vector "x_j", from the center of the particle to the
c         center of the component sphere, for particle "j".  Vector x_j 
c         has components in the global coordinate system.
c
c---------we must rotate vector "xlocal3" which, like "x_j" is from the
c         center of the particle to the center of the components sphere,
c         but "xlocal3" has components in the local coordinate system of
c         the particle of particle "j".
c
c---------extract the vector from the center of the particle to the center
c         of the particular (m_j) sphere, in the particles local frame
          xlocal3(1) = xlocal(m_j,1,rve)
          xlocal3(2) = xlocal(m_j,2,rve)
          xlocal3(3) = xlocal(m_j,3,rve)
c
c---------this flag is used in subroutin QMatrixRotateVector to determine
c         whether a forward or reverse (inverse) rotation is applied
          ixg = 2
c
c---------use this subroutin to rotate the vector from the center of
c         particle "j" to the center of the satellite sphere.  This
c         vector, initially in the local frame, must be rotated into
c         the global frame
          call QMatrixRotateVector(Rot_j, x_j, xlocal3, ixg)
c
c---------scale the vector by the particle size r_j=rad(jgrain) and by
c         b_rad=cirrad
          x_j(1) = r_j*b_rad(m_j,rve)*x_j(1)
          x_j(2) = r_j*b_rad(m_j,rve)*x_j(2)
          x_j(3) = r_j*b_rad(m_j,rve)*x_j(3)
        else
c---------for the central sphere (m_j=0), the center of the sphere and
c         the center of the particle coincide
          x_j(1) = 0.d0
          x_j(2) = 0.d0
          x_j(3) = 0.d0
        endif
c
c-------vector from center of the component sphere of the first 
c       particle to the center of the component sphere of the 
c       second particle
        r(1) = rx(1) - x_i(1) + x_j(1)
        r(2) = rx(2) - x_i(2) + x_j(2)
        r(3) = rx(3) - x_i(3) + x_j(3)
c
c-------square of the distance between the two component spheres
        rijsq = r(1)**2 + r(2)**2 + r(3)**2
c
c-------the radius of the component spheres, scaled by r_i=rad(igrain)
c       and r_j=rad(jgrain)
        rad_i = r_i*s_rad(m_i,rve)
        rad_j = r_j*s_rad(m_j,rve)
c
c-------sum of the two sphere radii (plus the separation threshold)
        rsum = rad_i + rad_j + seprat
c
c-------are the particles touching?
        ltact = rijsq.lt.rsum**2
c
c-------in the event of a contact (ltact=.true.) and when we must find
c       certain geometric quantities (lgeom=.true.)
        if(lgeom .and. (ltact .or. lexep)) then
c---------compute various geometric quantities that will be needed to
c         find the contact forces and the moments acting upon the particles
c
c---------the distance between particle centers
          rij = dsqrt(rijsq)
c
c---------the overlap between particles (twice the identation)
          ovrlap = rsum - rij
c
c---------the cosines of the outward normal vector at the contact of 
c         particle i.  Note that this vector is in the global frame.
          c_eta(1) = r(1) / rij
          c_eta(2) = r(2) / rij
          c_eta(3) = r(3) / rij
c
c---------the vector from the center of particle i to the contact point.
c         Note that this vector is in the global frame.
          l_i(1) = x_i(1) + r(1)*rad_i/rsum
          l_i(2) = x_i(2) + r(2)*rad_i/rsum
          l_i(3) = x_i(3) + r(3)*rad_i/rsum
c
c---------the vector from the center of particle j to the contact point.
c         Note that this vector is in the global frame.
          l_j(1) = x_j(1) - r(1)*rad_j/rsum
          l_j(2) = x_j(2) - r(2)*rad_j/rsum
          l_j(3) = x_j(3) - r(3)*rad_j/rsum
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine micro(rve)
c
c-------this subroutin produces the F-file output of micro-results
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 iremov,islip2,rve,TempUnit
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 i4,icell,igrain,ipt1,ipt3,isweep,ixg,
     x            jgrain,jsign,listds,listJ,listk,m_i,m_j
c
        double precision a_i,a_j,betahi,betalo,
     x                   c_eta,carea,degrad,Ft_global,Ft_xi,nintx,
     x                   l_i,l_j,ovrlap,p1_i,p1_j,p2_i,p2_j,Qc,
     x                   r_i,r_j,r1_i,r1_j,r2_i,r2_j,rcells,
     x                   rxcntr,seprat,theto,tol
        double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s,
     x                   p_s, p_s0, p_s1,
     x                   RJag,
     x                   zeta_o, zeta_s0, zeta_s1, zeta_s
        character*400 ffile
        logical lexep,lgeom,lnocon,ltact
c
        dimension a_i(3),a_j(3),betahi(2),betalo(2),
     x            c_eta(3),Ft_global(3),Ft_xi(3),
     x            l_i(3),l_j(3),listds(mconvx,0:2),
     x            nintx(3),Qc(4),rcells(3),
     x            rxcntr(3),theto(3)
c
        dimension jsign(0:mlist2)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-------explanation of file numbers.  For each rve, we reserve 5 file
c       numbers:
c          unit = 10 + rve*5 + 0  temporary files for input and output
c          unit = 10 + rve*5 + 1  "A"-file, output
c          unit = 10 + rve*5 + 2  "B"-file, output
c          unit = 10 + rve*5 + 3  "S"-file, screen output
c          unit = 10 + rve*5 + 4  "R"-file, error output
c
        TempUnit = 10 + 5*rve + 0
c
c-------initialize variable passed to subroutins ellips, ovals,
c       and ovoids for contact detection with elliptical, oval, and
c       ovoid particles:
c
c-------extract the contact geometry (subroutin ovoids)
        lgeom = .true.
c
c-------the critical separation is zero (no near-neighbors, just contacts,
c       in subroutin ovoids)
        seprat = 0.
c
c-------tolerance used in iteration for torus-torus contact detection
        tol = tolrnc(1,rve)
c
        lexep = .false.
c
c-------the threshold "beta" angle for contact detection will equal
c       the input value of "beta" (this will not be relaxed as in a
c       near-neighbor search.  Assign the cosine and sine of beta to
c       the threshold arrays betahi and betalo
        betahi(1) = cbeta(1,rve)
        betahi(2) = cbeta(2,rve)
        betalo(1) = cbeta(1,rve)
        betalo(2) = cbeta(2,rve)
c
c-------initialize variables
        c_eta(1) = 0.
        c_eta(2) = 0.
        c_eta(3) = 0.
        l_i(1) = 0.
        l_i(2) = 0.
        l_i(3) = 0.
        l_j(1) = 0.
        l_j(2) = 0.
        l_j(3) = 0.
c
        if(.not.lconvx(rve)) then
          do 10 i4=0,mlist2
            jsign(i4) = 0
   10     continue
        endif
c
        if(itxt(rve).eq.0) then
          ffile = file1(rve)
        else
          ffile = file1(rve)(1:index(file1(rve),'.txt')-1)
        endif
c
        if(ndim1.eq.2) then
          call circuit(rve)
        endif
c
c-------first, the Fa-file of assembly size information
        open(unit=TempUnit,
     x       file='Fa'//cstep(rve)//ffile,
     x       form='formatted')
c
c-------identify the file type.  The information that is presented in the file
c       will depend upon whether the assembly is 2D or 3D and whether the
c       contact stiffness is linear or Hertzian.
        write(TempUnit,960) 122
c
c
c-------write output to the "Fa" file
        write(TempUnit,950) timer(rve)
        write(TempUnit,901) xcell(1,1,rve),xcell(1,2,rve),
     x                      xcell(1,3,rve)
        write(TempUnit,901) xcell(2,1,rve),xcell(2,2,rve),
     x                      xcell(2,3,rve)
        write(TempUnit,901) xcell(3,1,rve),xcell(3,2,rve),
     x                      xcell(3,3,rve)
        write(TempUnit,901) def(1,1,rve),def(1,2,rve),def(1,3,rve)
        write(TempUnit,901) def(2,1,rve),def(2,2,rve),def(2,3,rve)
        write(TempUnit,901) def(3,1,rve),def(3,2,rve),def(3,3,rve)
        write(TempUnit,901) stress(1,1,rve),stress(1,2,rve),
     x                      stress(1,3,rve)
        write(TempUnit,901) stress(2,1,rve),stress(2,2,rve),
     x                      stress(2,3,rve)
        write(TempUnit,901) stress(3,1,rve),stress(3,2,rve),
     x                      stress(3,3,rve)
        write(TempUnit,962) kshape(rve)
c-------imodel was added after version oval-0.7.215.f
        write(TempUnit,962) imodel(rve)
c-------some place-holders for future additions (iheat added after 
c       version oval-0.7.220.f)
        write(TempUnit,962) iheat(rve)
        write(TempUnit,962) 0
        write(TempUnit,962) 0
        write(TempUnit,962) 0
        write(TempUnit,962) 0
c
        if(imodel(rve).eq.5 .or. imodel(rve).eq.6
     x     .or. imodel(rve).eq.7 
     x     .or. imodel(rve).eq.8 .or. imodel(rve).eq.9) then
          write(TempUnit,963) G(rve)
          write(TempUnit,963) nu(rve)
          if(imodel(rve).eq.7) then
            write(TempUnit,963) A_1(rve)
          elseif(imodel(rve).eq.9) then
            write(TempUnit,963) A_1(rve)
            write(TempUnit,963) palpha(rve)
          endif
        else
          write(TempUnit,963) kn(rve)
          write(TempUnit,963) kratio(rve)
        endif
        write(TempUnit,963) frict(rve)
c
        if(loval(rve) .or. lovoid(rve)) then
          write(TempUnit,963) beta(rve)
        elseif(lnobby(rve)) then
c---------write additional information if nobby particles are being used
          write(TempUnit,962) nobs(rve)
          write(TempUnit,963) cenrad(rve)
          write(TempUnit,963) satrad(rve)
        elseif(lbumpy(rve)) then
c---------write additional information if bumpy particles are being used
          write(TempUnit,962) nbumps(rve)
          write(TempUnit,963) cenrad(rve)
          write(TempUnit,963) satrad(rve)
          write(TempUnit,963) cirrad(rve)
        endif
c
c-------In general, the file unit=TempUnit is for temporary input
c       or output (within a single subroutin), and it
c       is closed immediately after its use
        close(unit=TempUnit)
c
c-------next, the Fb-file of particle data
        open(unit=TempUnit,file='Fb'//cstep(rve)//ffile, 
     x       form='formatted')
c
c-------for all of the (np) particles
        do 100 igrain = 1,np(rve)
c---------in past versions, very small values of "theta" (for example, 
c         3.14e-323) would be improperly represented (as 3.14-323, with the
c         "e".  Now we just round these small values to zero.
          do 102 i = 1,3
            if(abs(theta(i,igrain,rve)) .lt. 1.0d-99) then
              theto(i) = 0.
            else
              theto(i) = theta(i,igrain,rve)
            endif
  102     continue
c
          if(ndim1.eq.2) then
            if(lelips(rve) .or. loval(rve)) then
c-------------a change in version 0.6.4 (0.7.40), output theta in radians
              write(TempUnit,910) hv(igrain,rve),rad(igrain,rve),
     x                     aspect(igrain,rve),
     x                     xp(1,igrain,rve),xp(2,igrain,rve),
     x                     theto(3)
            elseif(lcircl(rve) .or. lnobby(rve)) then
c-------------a change in version 0.6.4 (0.7.40), output theta in radians
              write(TempUnit,910) hv(igrain,rve),rad(igrain,rve),1.d0,
     x                     xp(1,igrain,rve),xp(2,igrain,rve),
     x                     theto(3)
            endif
          elseif(ndim1.eq.3) then
            if(lspher(rve)) then
              if(iheat(rve).eq.0) then
                write(TempUnit,914) rad(igrain,rve),
     x                       xp(1,igrain,rve),
     x                       xp(2,igrain,rve),
     x                       xp(3,igrain,rve),
     x                       theto(1),theto(2),theto(3)
              elseif(iheat(rve).eq.1) then
                write(TempUnit,917) rad(igrain,rve),
     x                       xp(1,igrain,rve),
     x                       xp(2,igrain,rve),
     x                       xp(3,igrain,rve),
     x                       theto(1),theto(2),theto(3),
     x                       tempr(igrain,rve)
              endif
            elseif(lovoid(rve)) then
c-------------compute the orientation angles, gamma_1 and gamma_2 (in degrees),
c             of the ovoid axis
              call gammas(rve)
c
c-------------a change in version 0.6.4 (0.7.40), output gamma in radians
              degrad = pi / 180.d0
              write(TempUnit,915) rad(igrain,rve),aspect(igrain,rve),
     x                     xp(1,igrain,rve),
     x                     xp(2,igrain,rve),
     x                     xp(3,igrain,rve),
     x                     degrad*gamma_(1,igrain,rve),
     x                     degrad*gamma_(2,igrain,rve),
     x                     theto(1),theto(2),theto(3)
            elseif(lbumpy(rve)) then
              write(TempUnit,916) rad(igrain,rve),
     x                     (xp(j,igrain,rve),j=1,3),
     x                     (Qp(j,igrain,rve),j=1,4)
            endif
          endif
  100   continue
c
c-------In general, the file unit=TempUnit is for temporary input
c       or output (within a single subroutin), and it
c       is closed immediately after its use
        close(unit=TempUnit)
c
c-------next, the Fc-file of contact data
        open(unit=TempUnit,
     x       file='Fc'//cstep(rve)//ffile,
     x       form='formatted')
c
        if(.not.lconvx(rve)) then
c---------see description in the next comment
          if(lnobby(rve)) then
            nmaxc = 4
          elseif(lbumpy(rve)) then
            nmaxc = 6
          endif
c
c---------For non-convex particles, write a version number ("200") and
c         the maximum number of slots per particle for contacts. That is,
c         if "nmaxc" is 4, then the "Fc" will contain information on,
c         at most 4 contacts per particle pair.
          write(TempUnit,971) 200,nmaxc,imodel(rve)
        endif
c
        if(ndim1.eq.2) then
c---------fixed an error here at version 0:7:54 and subsequently changed
c         the version number of the "Fa" files from 100 to 101
c
          do 120 ipt1 = 1,mlist2
            if(liste(ipt1,rve).ne.0) then
              ipt3 = liste(ipt1,rve)
c
              if(v1(ipt3,rve).lt.v2(ipt3,rve)) then
                isign = 1
              else
                isign = -1
              endif
c
              if(lconvx(rve)) then
                if(lHertz(rve)) then
                  write(TempUnit,921) v1(ipt3,rve),v2(ipt3,rve),
     x                       f1(ipt3,rve),f2(ipt3,rve),
     x                       p1(ipt3,rve),p2(ipt3,rve),
     x                       isign*branch(1,ipt3,rve),
     x                       isign*branch(2,ipt3,rve),
     x                       isign*c_etas(1,ipt3,rve),
     x                       isign*c_etas(2,ipt3,rve),
     x                       fnold1(ipt3,rve),
     x                       isign*ftold(1,ipt3,rve),
     x                       isign*ftold(2,ipt3,rve),
     x                       Tstar(ipt3,rve),islip(ipt3,rve)
                elseif(lJager(rve) .or. lJagr2(rve)
     x                 .or. lJagr3(rve) .or. lJagr4(rve)) then
c-----------------note the "ftold" is given in terms of the rotated xi-plane
c                 coordinates
                  write(TempUnit,920) v1(ipt3,rve),v2(ipt3,rve),
     x                       f1(ipt3,rve),f2(ipt3,rve),
     x                       p1(ipt3,rve),p2(ipt3,rve),
     x                       isign*branch(1,ipt3,rve),
     x                       isign*branch(2,ipt3,rve),
     x                       isign*c_etas(1,ipt3,rve),
     x                       isign*c_etas(2,ipt3,rve),
     x                       fnold1(ipt3,rve),
     x                       isign*ftold(1,ipt3,rve),
     x                       isign*ftold(2,ipt3,rve),
     x                       islip(ipt3,rve)
                else
                  write(TempUnit,920) v1(ipt3,rve),v2(ipt3,rve),
     x                       f1(ipt3,rve),f2(ipt3,rve),
     x                       p1(ipt3,rve),p2(ipt3,rve),
     x                       isign*branch(1,ipt3,rve),
     x                       isign*branch(2,ipt3,rve),
     x                       isign*c_etas(1,ipt3,rve),
     x                       isign*c_etas(2,ipt3,rve),
     x                       fnold1(ipt3,rve),
     x                       isign*ftold(1,ipt3,rve),
     x                       isign*ftold(2,ipt3,rve),
     x                       islip(ipt3,rve)
                endif
              elseif(lnobby(rve)) then
                do 803 i = 1,nmaxc
                  listds(i,0) = 0
                  listds(i,1) = 0
                  listds(i,2) = 0
  803           continue
c
                ihit = 0
                i4 = liste(ipt1,rve)
                do 804 while (i4.ne.0)
                  ihit = ihit + 1
                  if(ihit.le.nmaxc) then
                    listds(ihit,0) = i4
                    listds(ihit,1) = listf1(i4,rve)
                    listds(ihit,2) = listf2(i4,rve)
                  endif
c
c-----------------we must give the proper sign to the possibly multiple
c                 contacts between a particle pair
                  jsign(listds(ihit,0)) = isign
c
                  i4 = listf0(i4,rve)
  804           continue
c
c---------------Note, no more than "nmaxc" contacts per particle.
                write(TempUnit,922) v1(ipt3,rve),v2(ipt3,rve),
     x                     f1(ipt3,rve),f2(ipt3,rve),
     x                     p1(ipt3,rve),p2(ipt3,rve),
     x                     isign*branch(1,ipt3,rve),
     x                     isign*branch(2,ipt3,rve),
     x                     ihit,
     x                     listds(1,0),listds(1,1),listds(1,2),
     x                     listds(2,0),listds(2,1),listds(2,2),
     x                     listds(3,0),listds(3,1),listds(3,2),
     x                     listds(4,0),listds(4,1),listds(4,2)
              endif
            endif
  120     continue
        elseif(ndim1.eq.3) then
          do 400 igrain = 1,np(rve)
            ipt1 = igrain
            do 410 while (list2(ipt1,rve).ne.0)
              ipt1 = list2(ipt1,rve)
              if(liste(ipt1,rve).ne.0) then
                ipt3 = liste(ipt1,rve)
                jgrain = list1(ipt1,rve)
c
                do 29 i=1,3
                  rcells(i) = 0.
   29           continue
c
                do 30 k = 1,3
c-----------------the relative positions of the two spheres
                  rxcntr(k) = xp(k,jgrain,rve) - xp(k,igrain,rve)
c
c-----------------the number of periodic cell boundaries between the 
c                 particle pair (for example, when the pair straddles a 
c                 periodic boundary)
                  do 31 l = 1,ndim1
                    rcells(l) = rcells(l) + xcelli(l,k,rve)*rxcntr(k)
   31             continue
   30           continue
c
                do 137 k = 1,ndim1
                  nintx(k) = nint(rcells(k))
  137           continue
c
                do 33 k = 1,ndim1
                  do 34 l = 1,ndim1
                    rxcntr(k) = rxcntr(k) - xcell(k,l,rve)*nintx(l)
   34             continue
   33           continue
c
                if(lspher(rve)) then
c-----------------radii of the two particles
                  r_i = rad(igrain,rve)
                  r_j = rad(jgrain,rve)
c
c-----------------establish whether contact has occured, and if so, compute
c                 various auxilary quantities
                  call sphere(r_i,r_j,rxcntr,seprat,ndim1,lexep,lgeom,
     x                        c_eta,ovrlap,l_i,l_j,carea,ltact)
c
                  if(ltact) then
                    if(lHertz(rve)) then
                      write(TempUnit,931) 
     x                        igrain,jgrain,(rxcntr(i),i=1,3),
     x                        fnold1(ipt3,rve),
     x                        (ftold(i,ipt3,rve),i=1,3),
     x                        Tstar(ipt3,rve),islip(ipt3,rve)
                    elseif(lJager(rve) .or. lJagr2(rve)
     x                     .or. lJagr3(rve)
     x                     .or. lJagr4(rve)) then
c---------------------when the Jager algorithm is being used, then "ftold"
c                     gives components of the tangential force in the 
c                     rotated xi-plane.  The quaternion "Qc_old" provides
c                     rotation from the global system to the xi-system.
c                     We must use Qc_old to translate ftold to its
c                     global components
                      Qc(1) = Qc_old(1,ipt3,rve)
                      Qc(2) = Qc_old(2,ipt3,rve)
                      Qc(3) = Qc_old(3,ipt3,rve)
                      Qc(4) = Qc_old(4,ipt3,rve)
                      Ft_xi(1) = ftold(1,ipt3,rve)
                      Ft_xi(2) = ftold(2,ipt3,rve)
                      Ft_xi(3) = 0.
c
c---------------------this subroutin will rotate Ft_xi into Ft_global
                      ixg = 2
                      call Qrotate(Qc, Ft_global, Ft_xi, ixg)
c
                      write(TempUnit,932) 
     x                         igrain,jgrain,(rxcntr(i),i=1,3),
     x                         fnold1(ipt3,rve),(Ft_global(i),i=1,3),
     x                         islip(ipt3,rve)
                    else
                      write(TempUnit,932)
     x                         igrain,jgrain,(rxcntr(i),i=1,3),
     x                         fnold1(ipt3,rve),
     x                         (ftold(i,ipt3,rve),i=1,3),
     x                         islip(ipt3,rve)
                    endif
                    lnocon = .false.
                  endif
                elseif(lovoid(rve)) then
c-----------------with ovoids, we must use subroutin "ovoids" to find the
c                 vectors l_i, l_j, and c_eta
c
c-----------------prepare data to pass to subroutin "ovoids", which will check
c                 whether the particles are contacting.  The array a_vect( , )
c                 contains the unit orientation vectors for all particles.
c                 Just pass the 6 values that are needed for the two particles:
                  a_i(1) = a_vect(1,igrain,rve)
                  a_i(2) = a_vect(2,igrain,rve)
                  a_i(3) = a_vect(3,igrain,rve)
                  a_j(1) = a_vect(1,jgrain,rve)
                  a_j(2) = a_vect(2,jgrain,rve)
                  a_j(3) = a_vect(3,jgrain,rve)
c
c-----------------dimensions of the component pieces of the two particles
                  r1_i = r_piec(1,igrain,rve)
                  r1_j = r_piec(1,jgrain,rve)
                  r2_i = r_piec(2,igrain,rve)
                  r2_j = r_piec(2,jgrain,rve)
                  p1_i = r_piec(3,igrain,rve)
                  p1_j = r_piec(3,jgrain,rve)
                  p2_i = r_piec(4,igrain,rve)
                  p2_j = r_piec(4,jgrain,rve)
c
c-----------------no contact has yet been found among the component 
c                 pieces of the two particles
                  lnocon = .true.
c
c-----------------consider the combinations of component pieces that are
c                 near-neighbors for this pair of particles
                  ipart = 0
c
c-----------------the number of pairs of component pieces that are 
c                 near-neighbors for the two particles
                  nparts = list3(ipt1,0,rve)
c
c-----------------This is index of the pair of component pieces that was in 
c                 contact during the previous deformation step.  We will start 
c                 our contact search with this pair.  If this pair is no 
c                 longer in contact, we will check the other pairs of 
c                 component pieces.
                  jpart = list3(ipt1,-1,rve)
c
c-----------------search through the pairs of component pieces for a contact.
c                 The logical variable "lnocon" is true until a contact is
c                 found, then it becomes false so that the search ends.
                  do 91 while (ipart.le.nparts-1 .and. lnocon)
c
c-------------------the pair of component pieces that is currently be checked
                    kpart = mod(jpart+ipart,nparts)
c
c-------------------fix the modulo value
                    if(kpart.eq.0) then
                      kpart = nparts
                    endif
c
c-------------------consider the component pieces from the two particles.  
c                   Extract the types of components from the digits of list3
                    m_i = list3(ipt1,kpart,rve)/10
                    m_j = mod(list3(ipt1,kpart,rve),10)
c
c-------------------determine the branch vector and unit normal vector
                    call ovoids(a_i,a_j,betahi,betalo,
     1                          p1_i,p1_j,p2_i,p2_j,
     2                          r1_i,r1_j,r2_i,r2_j,ravg(rve),rxcntr,
     x                          seprat,tol,
     3                          m_i,m_j,lgeom,
     4                  
     5                          c_eta,ovrlap,l_i,l_j,isweep,ltact)
c
                    if(ltact) then
                      if(.not.lHertz(rve)) then
                        write(TempUnit,935) igrain,jgrain,l_i(1)-l_j(1),
     x                               l_i(2)-l_j(2),l_i(3)-l_j(3),
     x                               (l_i(i),i=1,3),
     x                               fnold1(ipt3,rve),
     x                               (ftold(i,ipt3,rve),i=1,3),
     x                               (c_eta(i),i=1,3),
     x                               islip(ipt3,rve)
                      else
                        write(TempUnit,936) igrain,jgrain,l_i(1)-l_j(1),
     x                               l_i(2)-l_j(2),l_i(3)-l_j(3),
     x                               (l_i(i),i=1,3),
     x                               fnold1(ipt3,rve),
     x                               (ftold(i,ipt3,rve),i=1,3),
     x                               (c_eta(i),i=1,3),Tstar(ipt3,rve),
     x                               islip(ipt3,rve)
                      endif
                      lnocon = .false.
                    endif
                    ipart = ipart + 1
   91             continue
                elseif(lbumpy(rve)) then
                  do 805 i = 1,nmaxc
                    listds(i,0) = 0
                    listds(i,1) = 0
                    listds(i,2) = 0
  805             continue
c
                  ihit = 0
                  i4 = liste(ipt1,rve)
                  do 806 while (i4.ne.0)
                    ihit = ihit + 1
                    if(ihit.le.nmaxc) then
                      listds(ihit,0) = i4
                      listds(ihit,1) = listf1(i4,rve)
                      listds(ihit,2) = listf2(i4,rve)
                    endif
c
c-------------------we must give the proper sign to the possibly multiple
c                   contacts between a particle pair
                    jsign(listds(ihit,0)) = 1
c
                    i4 = listf0(i4,rve)
  806             continue
c
c-----------------Note, no more than "nmaxc" contacts per particle.
                  write(TempUnit,924)
     x                     igrain,jgrain,
     x                     rxcntr(1),rxcntr(2),rxcntr(3),
     x                     ihit,
     x                     listds(1,0),listds(1,1),listds(1,2),
     x                     listds(2,0),listds(2,1),listds(2,2),
     x                     listds(3,0),listds(3,1),listds(3,2),
     x                     listds(4,0),listds(4,1),listds(4,2),
     x                     listds(5,0),listds(5,1),listds(5,2),
     x                     listds(6,0),listds(6,1),listds(6,2)

                endif
              endif
  410       continue
  400     continue
        endif
c
c-------In general, the file unit=TempUnit is for temporary input or
c       output (within a single subroutin), and it is closed 
c       immediately after its use
        close(unit=TempUnit)
c
        if(ndim1.eq.2) then
c---------next, the Fd-file of contact data for 2D assemblies only
          open(unit=TempUnit,file='Fd'//cstep(rve)//ffile, 
     x         form='formatted')
          do 500 icell = 1,ncells(rve)
            write(TempUnit,940) hf(icell,rve)
  500     continue
c
c---------In general, the file unit=1 is for temporary input or output, and it
c         is closed immediately after its use
          close(unit=TempUnit)
        endif
c
        if(.not.lconvx(rve)) then
c---------next, the Ff-file of contact data for non-convex particles
          open(unit=TempUnit,
     x         file='Ff'//cstep(rve)//ffile,
     x         form='formatted')
c
          if(lnobby(rve)) then
            do 122 i4=1,mlist2
              if(.not.(lHertz(rve) .or. lJager(rve) .or. lJagr2(rve) 
     x                        .or. lJagr3(rve) .or. lJagr4(rve))) then
                write(TempUnit,926) jsign(i4)*c_etas(1,i4,rve),
     x                       jsign(i4)*c_etas(2,i4,rve),
     x                       fnold1(i4,rve),
     x                       jsign(i4)*ftold(1,i4,rve),
     x                       jsign(i4)*ftold(2,i4,rve),
     x                       jsign(i4)*l_i_old(1,i4,rve), 
     x                       jsign(i4)*l_i_old(2,i4,rve),
     x                       islip(i4,rve)
              elseif(lHertz(rve)) then
                write(TempUnit,927) jsign(i4)*c_etas(1,i4,rve),
     x                       jsign(i4)*c_etas(2,i4,rve),
     x                       fnold1(i4,rve),
     x                       jsign(i4)*ftold(1,i4,rve),
     x                       jsign(i4)*ftold(2,i4,rve),
     x                       Tstar(i4,rve),
     x                       jsign(i4)*l_i_old(1,i4,rve), 
     x                       jsign(i4)*l_i_old(2,i4,rve),
     x                       islip(i4,rve)
              elseif(lJager(rve) .or. lJagr2(rve)
     x               .or. lJagr3(rve) .or. lJagr4(rve)) then
                write(TempUnit,926) jsign(i4)*c_etas(1,i4,rve),
     x                       jsign(i4)*c_etas(2,i4,rve),
     x                       fnold1(i4,rve),
     x                       jsign(i4)*ftold(1,i4,rve),
     x                       jsign(i4)*ftold(2,i4,rve),
     x                       jsign(i4)*l_i_old(1,i4,rve), 
     x                       jsign(i4)*l_i_old(2,i4,rve),
     x                       islip(i4,rve)
              endif
  122       continue
          elseif(lbumpy(rve)) then
            do 123 i4=1,mlist2
              if(.not.(lHertz(rve) .or. lJager(rve) .or. lJagr2(rve) 
     x                        .or. lJagr3(rve) .or. lJagr4(rve))) then
                if(fnold1(i4,rve).ne.0.) then
                  write(TempUnit,928) c_etas(1,i4,rve),
     x                         c_etas(2,i4,rve),
     x                         c_etas(3,i4,rve),
     x                         fnold1(i4,rve),
     x                         ftold(1,i4,rve),
     x                         ftold(2,i4,rve),
     x                         ftold(3,i4,rve),
     x                         l_i_old(1,i4,rve),
     x                         l_i_old(2,i4,rve),
     x                         l_i_old(3,i4,rve),
     x                         islip(i4,rve)
                else
                  write(TempUnit,973) 0,0,0,0,0,0,0,0,0,0,0
                endif
              elseif(lHertz(rve)) then
                if(fnold1(i4,rve).ne.0.) then
                  write(TempUnit,929) c_etas(1,i4,rve),
     x                         c_etas(2,i4,rve),
     x                         c_etas(3,i4,rve),
     x                         fnold1(i4,rve),
     x                         ftold(1,i4,rve),
     x                         ftold(2,i4,rve),
     x                         ftold(3,i4,rve),
     x                         Tstar(i4,rve),
     x                         l_i_old(1,i4,rve),
     x                         l_i_old(2,i4,rve),
     x                         l_i_old(3,i4,rve),
     x                         islip(i4,rve)
                else
                  write(TempUnit,973) 0,0,0,0,0,0,0,0,0,0,0,0
                endif
              elseif(lJager(rve) .or. lJagr2(rve)
     x               .or. lJagr3(rve) .or. lJagr4(rve)) then
                if(fnold1(i4,rve).ne.0.) then
                  write(TempUnit,975) c_etas(1,i4,rve),
     x                         c_etas(2,i4,rve),
     x                         c_etas(3,i4,rve),
     x                         fnold1(i4,rve),
     x                         ftold(1,i4,rve),
     x                         ftold(2,i4,rve),
     x                         ftold(3,i4,rve),
     x                         l_i_old(1,i4,rve),
     x                         l_i_old(2,i4,rve),
     x                         l_i_old(3,i4,rve),
     x                         Qc_old(1,i4,rve),
     x                         Qc_old(2,i4,rve),
     x                         Qc_old(3,i4,rve),
     x                         Qc_old(4,i4,rve),
     x                         xi_old(1,i4,rve),
     x                         xi_old(2,i4,rve),
     x                         islip(i4,rve)
                else
                  write(TempUnit,973) 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                endif
              endif
  123       continue
          endif
c
c---------In general, the file unit=TempUnit is for temporary input or
c         output (within a single subroutin), and it is closed 
c         immediately after its use
          close(unit=TempUnit)
        endif
c
        return
c
  901   format(3(1pe25.17))
  910   format(i7,4(1pe17.9),1(1pe18.9))
  914   format(4(1pe17.9),3(1pe18.9))
  915   format(7(1pe17.9),3(1pe18.9))
  916   format(4(1pe20.12),4(1pe20.12))
  917   format(4(1pe17.9),3(1pe18.9),1(1pe12.4))
  920   format(4(i7),2(i8),2(1pe19.11),5(1pe13.5),i2)
  921   format(4(i7),2(i8),2(1pe19.11),6(1pe13.5),i2)
  922   format(4(i7),2(i8),2(1pe19.11),i3,4(i7,i3,i3))
  924   format(2(i7),3(1pe19.11),i3,6(i7,i3,i3))
  926   format(7(1pe17.9),i2)
  927   format(8(1pe17.9),i2)
  928   format(10(1pe19.11),i2)
  929   format(11(1pe19.11),i2)
  931   format(2(i7),3(1pe19.11),5(1pe13.5),i2)
  932   format(2(i7),3(1pe19.11),4(1pe13.5),i2)
  935   format(2(i7),3(1pe19.11),10(1pe13.5),i2)
  936   format(2(i7),3(1pe19.11),10(1pe13.5),1pe13.5,i2)
  940   format(i7)
  950   format(1pe14.7)
  960   format(i3)
  962   format(i2)
  963   format(1pe17.9)
  971   format(3(i7))
  973   format(20(i2))
  975   format(16(1pe19.11),i2)
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine Qrotate(Qc, X_global, X_local, ixg)
c
        integer*4 ixg
        double precision Qc, QRot, QiRot,
     x                   tt2, tt3, tt4, tt5, tt6, tt7, tt8, tt9, tt10,
     x                   X_global, X_local
        dimension Qc(4), QRot(3,3), QiRot(3,3), X_global(3), X_local(3)
c
c-------This subroutin uses a quaternion Qc to rotate a vector "X" between
c       a global and local frame.
c
c-------When ixg=1, then the quaterion Qc is used to rotate a vector from
c       the global frame to the local frame: X_global to X_local
c
c       When ixg=2, the inverse of Qc is used to rotate a vector from
c       the local frame to the global frame: X_local to X_global
c
c-------Products for finding the rotation matrix of Qc
        tt2 =   Qc(1)*Qc(2)
        tt3 =   Qc(1)*Qc(3)
        tt4 =   Qc(1)*Qc(4)
        tt5 =  -Qc(2)*Qc(2)
        tt6 =   Qc(2)*Qc(3)
        tt7 =   Qc(2)*Qc(4)
        tt8 =  -Qc(3)*Qc(3)
        tt9 =   Qc(3)*Qc(4)
        tt10 = -Qc(4)*Qc(4)
c
c-------Rotation matrix of quaternion Qc, which rotates
c       vectors from the (global) frame of the local frame
        QRot(1,1) = tt8 + tt10 + 0.5d0
        QRot(1,2) = tt6 + tt4
        QRot(1,3) = tt7 - tt3
        QRot(2,1) = tt6 - tt4
        QRot(2,2) = tt5 + tt10 + 0.5d0
        QRot(2,3) = tt9 + tt2
        QRot(3,1) = tt7 + tt3
        QRot(3,2) = tt9 - tt2
        QRot(3,3) = tt5 + tt8 + 0.5d0
c
        if(ixg.eq.1) then
c---------Rotate the vector "X_global" from the global frame to the 
c         local frame
          X_local(1) = 2.d0*(  QRot(1,1)*X_global(1)
     x                       + QRot(1,2)*X_global(2)
     x                       + QRot(1,3)*X_global(3))
          X_local(2) = 2.d0*(  QRot(2,1)*X_global(1)
     x                       + QRot(2,2)*X_global(2)
     x                       + QRot(2,3)*X_global(3))
          X_local(3) = 2.d0*(  QRot(3,1)*X_global(1)
     x                       + QRot(3,2)*X_global(2)
     x                       + QRot(3,3)*X_global(3))
        elseif(ixg.eq.2) then
c---------Rotate the local vector "X_local" from the local frame to the
c         global frame
c
c---------Inverse rotation matrix QiRot: the rotation matrix of the 
c         conjugate (inverse) of quaternion Qci, and it rotates
c         vectors from the local frame to the (global) frame
          QiRot(1,1) = QRot(1,1)
          QiRot(1,2) = QRot(2,1)
          QiRot(1,3) = QRot(3,1)
          QiRot(2,1) = QRot(1,2)
          QiRot(2,2) = QRot(2,2)
          QiRot(2,3) = QRot(3,2)
          QiRot(3,1) = QRot(1,3)
          QiRot(3,2) = QRot(2,3)
          QiRot(3,3) = QRot(3,3)
c
c---------Rotate the vector "X_local" from the local frame to the 
c         global frame 
          X_global(1) = 2.d0*(  QiRot(1,1)*X_local(1)
     x                        + QiRot(1,2)*X_local(2)
     x                        + QiRot(1,3)*X_local(3))
          X_global(2) = 2.d0*(  QiRot(2,1)*X_local(1)
     x                        + QiRot(2,2)*X_local(2)
     x                        + QiRot(2,3)*X_local(3))
          X_global(3) = 2.d0*(  QiRot(3,1)*X_local(1)
     x                        + QiRot(3,2)*X_local(2)
     x                        + QiRot(3,3)*X_local(3))
        endif
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine QRotationMatrix(Qc,QRot)
c
        double precision Qc, QRot,
     x                   tt2, tt3, tt4, tt5, tt6, tt7, tt8, tt9, tt10
        dimension Qc(4), QRot(3,3)
c
c-------This subroutin uses a quaternion Qc to find the 3x3 rotation
c       matrix that can then be used to rotate a vector in the global
c       global frame into a vector in the local frame.
c
c-------NOTE: the resulting matrix QRot is actually one-half of the
c       true rotation matrix
c
c-------Products for finding the rotation matrix of Qc
        tt2 =   Qc(1)*Qc(2)
        tt3 =   Qc(1)*Qc(3)
        tt4 =   Qc(1)*Qc(4)
        tt5 =  -Qc(2)*Qc(2)
        tt6 =   Qc(2)*Qc(3)
        tt7 =   Qc(2)*Qc(4)
        tt8 =  -Qc(3)*Qc(3)
        tt9 =   Qc(3)*Qc(4)
        tt10 = -Qc(4)*Qc(4)
c
c-------Rotation matrix of quaternion Qc, which rotates
c       vectors from the (global) frame of the local frame
        QRot(1,1) = tt8 + tt10 + 0.5d0
        QRot(1,2) = tt6 + tt4
        QRot(1,3) = tt7 - tt3
        QRot(2,1) = tt6 - tt4
        QRot(2,2) = tt5 + tt10 + 0.5d0
        QRot(2,3) = tt9 + tt2
        QRot(3,1) = tt7 + tt3
        QRot(3,2) = tt9 - tt2
        QRot(3,3) = tt5 + tt8 + 0.5d0
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine QMatrixRotateVector(QRot, X_frame_1, X_frame_2, ixg)
c
        integer*4 ixg
        double precision QRot, X_frame_2, X_frame_1
c
        dimension QRot(3,3), X_frame_2(3), X_frame_1(3)
c
c-------This subroutin uses the rotation matrix QRot to rotate a 
c       vector "X" between the global frame (1) and local frame (2).
c
c-------NOTE: the matrix QRot is computed from a Quaternion, so QRot is
c       actual one-half of the true rotation matrix.  Hence, we multiply
c       by a factor of 2.d0 below.
c
c-------When ixg=1, then the matrix QRot is used to rotate a vector from
c       the global frame (1) to the local frame (2): X_frame_1 to X_frame_2
c
c       When ixg=2, the inverse of QRot is used to rotate a vector from
c       the local frame (2) to the global frame (1): X_frame_2 to X_frame_1
c
        if(ixg.eq.1) then
c---------Rotate the vector "X_frame_1" from the global frame (1) to the 
c         local frame (2)
          X_frame_2(1) = 2.d0*(  QRot(1,1)*X_frame_1(1)
     x                         + QRot(1,2)*X_frame_1(2)
     x                         + QRot(1,3)*X_frame_1(3))
          X_frame_2(2) = 2.d0*(  QRot(2,1)*X_frame_1(1)
     x                         + QRot(2,2)*X_frame_1(2)
     x                         + QRot(2,3)*X_frame_1(3))
          X_frame_2(3) = 2.d0*(  QRot(3,1)*X_frame_1(1)
     x                         + QRot(3,2)*X_frame_1(2)
     x                         + QRot(3,3)*X_frame_1(3))
        elseif(ixg.eq.2) then
c---------Rotate the local vector "X_frame_2" from the local frame (2) to the
c         global frame (1)
c
c---------We use the inverse of the rotation matrix QRot, which is
c         its transpose
c
c---------Rotate the vector "X_frame_2" from the local frame (2) to the 
c         global frame (1)
          X_frame_1(1) = 2.d0*(  QRot(1,1)*X_frame_2(1)
     x                         + QRot(2,1)*X_frame_2(2)
     x                         + QRot(3,1)*X_frame_2(3))
          X_frame_1(2) = 2.d0*(  QRot(1,2)*X_frame_2(1)
     x                         + QRot(2,2)*X_frame_2(2)
     x                         + QRot(3,2)*X_frame_2(3))
          X_frame_1(3) = 2.d0*(  QRot(1,3)*X_frame_2(1)
     x                         + QRot(2,3)*X_frame_2(2)
     x                         + QRot(3,3)*X_frame_2(3))
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine QIncRotate(Qc, Qc_new, dw, inorm)
c
        integer*4 inorm
        double precision dw, fQc, Qc, Qc_new,
     x      wq21, wq31, wq41, wq22, wq32, wq42,
     x      wq23, wq33, wq43, wq24, wq34, wq44
c
        dimension Qc(4), Qc_new(4), dw(3)

c
c-------Compute the new quaternion of the contact frame:
c          Qc_new -> Qc + dQc = Qc + (1/2) dw*Qc, where "*" is
c       the quaternion composition operator.  The updated
c       quaternion Qci_new will rotate the (Jager) xi-plane 
c       (whose normal is in the z-direction) into the (global)
c       contact tangent plane
        wq21 = dw(1)*Qc(1)
        wq31 = dw(2)*Qc(1)
        wq41 = dw(3)*Qc(1)
        wq22 = dw(1)*Qc(2)
        wq32 = dw(2)*Qc(2)
        wq42 = dw(3)*Qc(2)
        wq23 = dw(1)*Qc(3)
        wq33 = dw(2)*Qc(3)
        wq43 = dw(3)*Qc(3)
        wq24 = dw(1)*Qc(4)
        wq34 = dw(2)*Qc(4)
        wq44 = dw(3)*Qc(4)
c
        Qc_new(1) = Qc(1) + 0.5d0*(-wq22 - wq33 - wq44)
        Qc_new(2) = Qc(2) + 0.5d0*( wq21 - wq43 + wq34)
        Qc_new(3) = Qc(3) + 0.5d0*( wq31 + wq42 - wq24)
        Qc_new(4) = Qc(4) + 0.5d0*( wq41 - wq32 + wq23)
c
c-------Normalize the quaternion Qc_new, but only when "inorm" is not 0
c
        if(inorm.ne.0) then
          if(inorm.eq.1) then
c-----------Apply a small approximate correction to more closely 
c           approximate a unit quaternion.  This correction is 
c           suggested by Katz, A., Computational Rigid Vehicle 
c           Dynamics, Krieger Publ. Co., Malabar, Florida, 1997.
c
c-----------The Katz correction factor
            fQc = 1.5d0 - 0.5d0*(  Qc_new(1)**2 + Qc_new(2)**2
     x                           + Qc_new(3)**2 + Qc_new(4)**2)
          elseif(inorm.eq.2) then
c-----------A precise adjustment is, of course,
            fQc = 1.d0 / sqrt(  Qc_new(1)**2 + Qc_new(2)**2
     x                        + Qc_new(3)**2 + Qc_new(4)**2)
          endif
c
c---------Now apply the correction factor
          Qc_new(1) =   fQc * Qc_new(1)
          Qc_new(2) =   fQc * Qc_new(2)
          Qc_new(3) =   fQc * Qc_new(3)
          Qc_new(4) =   fQc * Qc_new(4)
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine closem(lout,lScreen,AUnit,BUnit,ErrUnit,ScrUnit,
     x                  mfiles)
c-------this subroutin closes the many output files
c
        integer*2 AUnit,BUnit,ErrUnit,mfiles,ScrUnit
        logical lout,lScreen
c
c       parameter(mfiles=100)
c
        dimension lout(mfiles)
c
c-------close output files
        if(lout(1)) then
          close(unit=BUnit)
          close(unit=AUnit)
        endif
c
        close(unit=ErrUnit)
c
        if(.not.lScreen) then
          close(unit=ScrUnit)
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      double precision function xmod5(x,j)
        double precision x,y
        integer*2 j
c
        y = j
        xmod5 = mod(x,y)
        if(xmod5.lt.0.) then
          xmod5 = xmod5 + y
        endif
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer*2 function newmod(i,j)
        integer*2 i,j
        newmod = mod(i,j)
        if(newmod.lt.0) newmod = newmod + j
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer*4 function nwmod4(i,j)
        integer*4 i,j
        nwmod4 = mod(i,j)
        if(nwmod4.lt.0) nwmod4 = nwmod4 + j
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      integer*2 function mod4(x,j)
        double precision x
        integer*2 j
c
        if(x.ge.0.) then
          mod4 = x
          mod4 = mod(mod4,j)
        else
          mod4 = x
          mod4 = mod4 - 1
          mod4 = mod4 + j
        endif
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine circuit(rve)
c
c-----this subroutin identifies the 'space cells' (after K. Bagi, or 'void
c     cells') within a 2-dimensional assembly.  In general, these cells are 
c     polygonal.  If triangular cells are desired, specify ltrian = .true.  
c     The sides of the space cells correspond to particle contacts.
c
c-----note that we treat convex and non-convex particles the same.  With 
c     non-convex particles, multiple contacts between the same pair of 
c     particles are accorded a single branch vector (edge).
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      double precision nintx,pi2,rcells,rx
c
      logical ltrian,lring1,lring2
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i1,i2,i4,i4a,i4b,icell,iedge,iface,iigran,
     x          igrain,ipt1,ipt1o,ipt5,iside,itemp,
     x          j1,jedge,jface,jgrain,
     x          kgrain,kkgran,lgrain,llgran,
     x          listc,loop,mlistc,ncellm,nedgs,npm,tree
c
      integer*2 icorner,icornm,iint2,ilimb1,
     x          klimb,ksides,
     x          limb,limbd,limbi,lsides,twig,newmod,rve,ntwigs
c
      parameter(mlistc=mlist*2)
      parameter(mtwigs=300)
c
      dimension nintx(mdim1),rcells(mdim1),rx(mdim1)
c
      dimension alphaz(0:mlimbs),angle(0:mlimbs,mtwigs),
     x          angle1(0:mlimbs),
     x          xcelh(2)
c
      dimension 
     x          listc(0:mlistc,2),
     x          loop(0:mlimbs),ntwigs(0:mlimbs),
     x          tree(0:mlimbs,mtwigs),twig(0:mlimbs)
c
      dimension jedge(0:mlimbs),iedge(0:mlimbs)
c
      ltrian = .false.
c
c-----half-cell size
      do 1 i = 1,ndim1
        xcelh(i) = xcell(i,i,rve) / 2.d0
    1 continue
c
      pi2 = 2.d0*pi
c
c-----initialize the DCEL: Doubly Connected Edge List, a data structure
c     for storing the voronoi tesselation of void cells
      do 2 i4 = 0,mlist2
        v1(i4,rve) = 0
        v2(i4,rve) = 0
        p1(i4,rve) = 0
        p2(i4,rve) = 0
        f1(i4,rve) = 0
        f2(i4,rve) = 0
    2 continue
c
c-----more DCEL initialization
      do 3 i4 = 1,mcells
        hf(i4,rve) = 0
    3 continue
c
c-----more DCEL initialization
      do 7 i4 = 1,np(rve)
        hv(i4,rve) = 0
    7 continue
c
c-----initialize a doubly connected linked list
      do 20 i4 = 0,mlistc
        listc(i4,1) = 0
        listc(i4,2) = 0
   20 continue
c
c-----initialize the data structure for constructing the tesselation
      do 21 i = 0,mlimbs
        ntwigs(i) = 0
        twig(i) = 0
        do 22 j = 1,mtwigs
          tree(i,j) = 0
          angle(i,j) = 0.
   22   continue
   21 continue
c
      i2 = np(rve) + 1
c
c-----construct a doubly connected linked list of contacting particles
      do 705 igrain = 1,np(rve)
        ipt1 = igrain
        do 90 while (list2(ipt1,rve).ne.0)
          ipt1 = list2(ipt1,rve)
          if(liste(ipt1,rve).ne.0) then
            jgrain = list1(ipt1,rve)
c
            i1 = igrain
  769       if(listc(i1,2).ne.0) then
              i1 = listc(i1,2)
              goto 769
            else
              listc(i1,2) = i2
              listc(i2,1) = jgrain
              i2 = i2 + 1
            endif
c
            j1 = jgrain
  765       if(listc(j1,2).ne.0) then
              j1 = listc(j1,2)
              goto 765
            else
              listc(j1,2) = i2
              listc(i2,1) = igrain
              i2 = i2 + 1
            endif
          endif
   90   continue
  705 continue
c
      if(i2.gt.mlistc) then
        write(ScrUnit(rve),*) 'i2 exceeded mlistc in subroutin sides'
        write(ErrUnit(rve),*) 'i2 exceeded mlistc in subroutin sides'
        stop
      endif
c
      ntwigs(0) = 1
      angle(0,1) = 0.
      icell = 0
c
      do 510 iigran = 1,np(rve)
        limb = 0
        tree(0,1) = iigran
        twig(0) = 1
c
        limbi = 0
c
  560   igrain = tree(limb,twig(limb))
        limb = limb + 1
c
        if(limb.gt.mlimbs) then
          write(ScrUnit(rve),*)
     x      'limb is greater than mlimbs in subroutin sides'
          write(ErrUnit(rve),*)
     x      'limb is greater than mlimbs in subroutin sides'
          stop
        endif
c
        twig(limb) = 1
        ntwigs(limb) = 0
c
        ipt1 = igrain
        do 570 while (listc(ipt1,2) .ne. 0)
          ipt1 = listc(ipt1,2)
          jgrain = listc(ipt1,1)
          ntwigs(limb) = ntwigs(limb) + 1
          tree(limb,ntwigs(limb)) = jgrain
c
          if(ntwigs(limb).gt.mtwigs) then
            write(ScrUnit(rve),*)
     x        'ntwigs is greater than mtwigs in subroutin circuit'
            write(ErrUnit(rve),*) 
     x        'ntwigs is greater than mtwigs in subroutin circuit'
            stop
          endif
c
          do 552 k = 1,ndim1
            rcells(k) = 0.
  552     continue
c
          do 561 k = 1,ndim1
            rx(k) = xp(k,jgrain,rve) - xp(k,igrain,rve)
            do 562 l = 1,ndim1
              rcells(l) = rcells(l) + xcelli(l,k,rve) * rx(k)
  562       continue
  561     continue
c
          do 564 k = 1,ndim1
            nintx(k) = nint(rcells(k))
  564     continue
c
          do 566 k = 1,ndim1
            do 568 l = 1,ndim1
              rx(k) = rx(k) - xcell(k,l,rve)*nintx(l)
  568       continue
  566     continue
c
          if(rx(1).eq.0. .and. rx(2).eq.0) then
            write(ScrUnit(rve),*) 'Problem 1 in subroutin sides'
            ntwigs(limb) = ntwigs(limb) - 1
          else
            angle(limb,ntwigs(limb)) = atan2(rx(2),rx(1))
          endif
  570   continue
c
        do 580 i = 1,ntwigs(limb) - 1
          do 585 j = i+1,ntwigs(limb)
            alpha1 = mod(dble(pi-(angle(limb,i) - 
     x                        angle(limb-1,twig(limb-1)))),pi2)
c
            if(alpha1.lt.0.) then
              alpha1 = alpha1 + pi2
            endif
c
            alpha2 = mod(dble(pi-(angle(limb,j) -
     x                        angle(limb-1,twig(limb-1)))),pi2)
            if(alpha2.lt.0.) alpha2 = alpha2 + pi2
            if(alpha1 .gt. alpha2) then
              temp = angle(limb,j)
              angle(limb,j) = angle(limb,i)
              angle(limb,i) = temp
c
              itemp = tree(limb,j)
              tree(limb,j) = tree(limb,i)
              tree(limb,i) = itemp
            endif
  585     continue
  580   continue
c
  550   if(twig(limb).gt.ntwigs(limb)) then
          limb = limb - 1
          if(limb.le.0) goto 510
          twig(limb) = twig(limb) + 1
          goto 550
        else
          do 851 i = 1,limb - 1
            if(tree(i,twig(i)) .eq. tree(limb,twig(limb)) ) then
              twig(limb) = twig(limb) + 1
              goto 550
            endif
  851     continue
c
          if(tree(limb,twig(limb)).eq.tree(0,1)) then
c
            limbd = limb - limbi
c
            if(limbd.eq.2) then
              twig(limb) = twig(limb) + 1
              goto 550
            elseif(ltrian) then
              if(limbd.gt.3) then
                do 805 i = 0,limbd-1
                  loop(i) = tree(limbi+i,twig(limbi+i))
  805           continue
c
                lsides = limbd
                do 800 ksides = lsides,3,-1
                  do 810 iside = 0,ksides-1
                    jgrain = loop(iside)
                    iint2 = iside + 1
                    kgrain = loop(newmod(iint2,ksides))
c
                    do 852 k = 1,ndim1
                      rcells(k) = 0.
  852               continue
c
                    do 861 k = 1,ndim1
                      rx(k) = xp(k,kgrain,rve) - xp(k,jgrain,rve)
                      do 862 l = 1,ndim1
                        rcells(l) = rcells(l) + xcelli(l,k,rve) * rx(k)
  862                 continue
  861               continue
c
                    do 864 k = 1,ndim1
                      nintx(k) = nint(rcells(k))
  864               continue
c
                    do 866 k = 1,ndim1
                      do 868 l = 1,ndim1
                        rx(k) = rx(k) - xcell(k,l,rve)*nintx(l)
  868                 continue
  866               continue
c
                    if(rx(1).eq.0. .and. rx(2).eq.0) then
                      write(ScrUnit(rve),*)
     x                  'Problem 2 in subroutin sides'
                      angle1(iside) = pi
                    else
                      angle1(iside) = atan2(rx(2),rx(1))
                    endif
  810             continue
c
                  alpham = 10.d0
c
                  do 820 icorner = 0,ksides-1
                    iint2 = icorner - 1
                    alphaz(icorner) = 
     x                  mod(dble(pi - (angle1(newmod(icorner,ksides))
     x                  - angle1(newmod(iint2,ksides))))
     x                  ,pi2)
                    if(alphaz(icorner).lt.0.) then
                      alphaz(icorner) = alphaz(icorner) + pi2
                    endif
c
                    if(alphaz(icorner).lt.alpham) then
                      alpham = alphaz(icorner)
                      icornm = icorner
                    endif
  820             continue
c
                  do 830 i = icornm,ksides-1
                    loop(i) = loop(i+1)
  830             continue
  800           continue
              endif
            else
              icell = icell + 1
              do 102 ilimb = 0,limb-1
                ilimb1 = ilimb + 1
                kgrain = tree(ilimb,twig(ilimb))
                klimb = newmod(ilimb1,limb)
                lgrain = tree(klimb,twig(klimb))
c
                kkgran = min(kgrain,lgrain)
                llgran = max(kgrain,lgrain)
c
                ipt1 = kkgran
                do while(list2(ipt1,rve).ne.0)
                  ipt1 = list2(ipt1,rve)
                  if(list1(ipt1,rve).eq.llgran) then
                    ipt5 = liste(ipt1,rve)
                  endif
                end do
c
                if(v1(ipt5,rve).eq.0) then
                  v1(ipt5,rve) = kgrain
                  v2(ipt5,rve) = lgrain
                  f1(ipt5,rve) = icell
                  jedge(ilimb) = ipt5
                else
                  f2(ipt5,rve) = icell
                  jedge(ilimb) = -ipt5
                endif
  102         continue
c
              hf(icell,rve) = abs(jedge(0))
c
              do 103 ilimb = 0,limb-1
                ilimb1 = ilimb + 1
                klimb = newmod(ilimb1,limb)
                if(jedge(ilimb).gt.0) then
                  p2(jedge(ilimb),rve) = abs(jedge(klimb))
                else
                  p1(-jedge(ilimb),rve) = abs(jedge(klimb))
                endif
  103         continue
            endif
c
            do 590 i = limbi,limb-1
              jgrain = tree(i,twig(i))
              kgrain = tree(i+1,twig(i+1))
c
              ipt1 = jgrain
  591         if(listc(ipt1,2).ne.0) then
                ipt1o = ipt1
                ipt1 = listc(ipt1,2)
                if(kgrain.eq.listc(ipt1,1)) then
                  listc(ipt1o,2) = listc(ipt1,2)
                  listc(ipt1,1) = 0
                  listc(ipt1,2) = 0
                  goto 590
                endif
                goto 591
              endif
  590       continue
c
            limb = 1
            twig(limb) = twig(limb) + 1
c
            goto 550
c
          else
            if(limb.ge.mlimbs-1) then
c             print *,'limb will exceed mlimbs in subroutin sides:'
              limb = 1
              twig(limb) = twig(limb) + 1
              goto 550
            else
              goto 560
            endif
          endif
        endif
  510 continue
c
      ncells(rve) = icell
c
      if(ncells(rve).gt.mcells) then
        write(ScrUnit(rve),*) 'ncells greater than mcells in circuit'
        write(ErrUnit(rve),*) 'ncells greater than mcells in circuit'
        stop
      endif
c
c-----find isolated "ringlets" and pendants and eliminate their faces
      ncellm = 0
      do 1101 icell = 1,ncells(rve)
        lring1 = .true.
        lring2 = .true.
        i4a = hf(icell,rve)
        if(i4a.ne.0) then
          i4b = i4a
          iedge(0) = i4a
          i = 1
c
          if(f1(i4a,rve).eq.icell) then
            iface = f2(i4a,rve)
            i4a = p2(i4a,rve)
          else
            iface = f1(i4a,rve)
            i4a = p1(i4a,rve)
          endif
c
          do while(i4b.ne.i4a)
            iedge(i) = i4a
            if(f1(i4a,rve).eq.icell) then
              jface = f2(i4a,rve)
              i4a = p2(i4a,rve)
            elseif(f2(i4a,rve).eq.icell) then
              jface = f1(i4a,rve)
              i4a = p1(i4a,rve)
            else
              write(ScrUnit(rve),*) 'Error 5 in subroutin circuit'
              write(ErrUnit(rve),*) 'Error 5 in subroutin circuit'
c             stop
            endif
            i = i + 1
            if(i.gt.mlimbs) then
              lring1 = .false.
              i4a = i4b
              iedgs = 0
            endif
c
            lring2 = lring2 .and. iface.eq.jface
          end do
          iedgs = i
        else
          iedgs = 0
        endif
c
        if(lring2.or.iedgs.eq.2) then
          ncellm = ncellm + 1
          hf(icell,rve) = 0
          do 1102 i = 0,iedgs-1
            i4 = iedge(i)
            v1(i4,rve) = 0
            v2(i4,rve) = 0
            if(f1(i4,rve).eq.icell) then
              f1(i4,rve) = 0
            elseif(f2(i4,rve).eq.icell) then
              f2(i4,rve) = 0
            endif
 1102     continue
        endif
 1101 continue
c
c-----construct the vertex header file
      do 1111 i4 = 0,mlist2
        if(v1(i4,rve).ne.0) then
          if(hv(v1(i4,rve),rve).eq.0) then
            hv(v1(i4,rve),rve) = i4
          endif
        endif
c-------fixed an error here at version 0:7:54 and subsequently changed
c       the version number of the "Fa" files from 100 to 101
c
        if(v2(i4,rve).ne.0) then
          if(hv(v2(i4,rve),rve).eq.0) then
            hv(v2(i4,rve),rve) = i4
          endif
        endif
 1111 continue
c
      npm = 0
      do 1112 i4 = 1,np(rve)
        if(hv(i4,rve).eq.0) then
          npm = npm + 1
        endif
 1112 continue
c
      nedgs = 0
      do 1114 i4 = 1,mlist2
        if(v1(i4,rve).ne.0 .or. v2(i4,rve).ne.0) then
          nedgs = nedgs + 1
        endif
 1114 continue
c
      if(np(rve).eq.np(rve)) then
        if(np(rve)-npm+ncells(rve)-ncellm .ne. nedgs) then
c         print *,'Eulers formula disobeyed in subroutin circuit'
        endif
      endif
c
      nverts(rve) = np(rve) - npm
      lfaces(rve) = ncells(rve) - ncellm
      medges(rve) = nedgs
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine normal(rve)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain,ipt1,jgrain,i4
c
        dimension rcells(mdim1),nintx(mdim1),vector(mdim1)
c
        do 100 ipt1 = 1,mlist2
          if(liste(ipt1,rve).ne.0) then
            i4 = liste(ipt1,rve)
            igrain = v1(i4,rve)
            jgrain = v2(i4,rve)
c
            if(igrain.ne.0) then
              do 102 k = 1,ndim1
                rcells(k) = 0.
                vector(k) = xp(k,jgrain,rve) - xp(k,igrain,rve)
  102         continue
c
              do 104 k = 1,ndim1
                do 106 l = 1,ndim1
                  rcells(l) = rcells(l) + xcelli(l,k,rve)*vector(k)
  106           continue
  104         continue
c
              do 120 k = 1,ndim1
                nintx(k) = nint(rcells(k))
  120         continue
c
              xlen = 0.
              do 108 k = 1,ndim1
                do 110 l = 1,ndim1
                  vector(k) = vector(k) - xcell(k,l,rve)*nintx(l)
  110           continue
                xlen = xlen + vector(k)**2
  108         continue
c
              xlen = sqrt(xlen)
c
              do 112 k = 1,ndim1
                cosxl(k,i4,rve) = vector(k)
  112         continue
            endif
          endif
  100   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine plotd(rve)
c
c-----this subroutin writes G-files that can be used by a post-processor
c     program to graphically display particle movements, local deformations,
c     contact forces, etc.  The files are in a machin-dependent binary
c     (unformatted) format.  The post-processing usually requires two
c     such files -- one each for a beginning and end condtion.
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      integer*2 rve,TempUnit
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,i4hold,igrain,k4,lim1,lim2,lim3,lim4,lim5
c
      logical lhold
      double precision dhold
c
      parameter(mhold=10)
c
c-----these arays are just "place holders" in the file, for use
c     as future flags
      dimension dhold(mhold)
      dimension rhold(mhold)
      dimension i4hold(mhold)
      dimension lhold(mhold)
      dimension i2hold(mhold)
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      TempUnit = 10 + 5*rve + 0
c
      jnput = 2
c
      if(itxt(rve).eq.0) then
        open(unit=TempUnit,file='G'//cstep(rve)//file1(rve),
     x            form='unformatted')
      else
        open(unit=TempUnit,file='G'//cstep(rve)//
     x                file1(rve)(1:index(file1(rve),'.txt')-1),
     x              form='unformatted')
      endif
c
      write(unit=TempUnit) np(rve),npiece(rve),iflex,ndim1,ndim2
cN
      write(unit=TempUnit) lcirc1(rve),lcirc2(rve),lcirc3(rve),
     x              kshape(rve),lcircl(rve),loval(rve),lelips(rve),
     x              lspher(rve),
     x              lbodyf,(nbound(i),i=1,3)
c
      write(unit=TempUnit) version
cN
c-----these arays are just "place holders" in the file, for use
c     as future flags
      write(unit=TempUnit) (dhold(i),i=1,mhold)
      write(unit=TempUnit) (rhold(i),i=1,mhold)
      write(unit=TempUnit) (i4hold(i),i=1,mhold)
      write(unit=TempUnit) (lhold(i),i=1,mhold)
      write(unit=TempUnit) (i2hold(i),i=1,mhold)
c
      write(unit=TempUnit) ((def(i,j,rve),i=1,3),j=1,3)
      write(unit=TempUnit) ((defp(i,j),i=1,3),j=0,3)
      write(unit=TempUnit) ((xcell(i,j,rve),i=1,3),j=1,3)
c
c
      write(unit=TempUnit) ((stress(i,j,rve),i=1,3),j=1,3)
c
      do 50 j = 1,ndim1
        do 52 k4 = 0,np(rve)/1000 - 1
          write(unit=TempUnit) (xp(j,igrain,rve),
     x                          igrain=k4*1000+1,(k4+1)*1000)
   52   continue
        write(unit=TempUnit)
     x    (xp(j,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
   50 continue
c
c-----there are three levels of detail for the file, depending on the
c     logical variables lcirc1, lcirc2, lcirc3.
      if(lcirc1(rve)) then
        do 58 k4 = 0,np(rve)/1000 - 1
          write(unit=TempUnit) (theta(3,igrain,rve),
     x                   igrain=k4*1000+1,(k4+1)*1000)
   58   continue
        write(unit=TempUnit)
     x    (theta(3,igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
c
        if(lcircl(rve).or.lspher(rve)) then
          do 60 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (rad(igrain,rve),
     x                      igrain=k4*1000+1,(k4+1)*1000)
   60     continue
          write(unit=TempUnit)
     x      (rad(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
cN
        elseif(loval(rve).or.lelips(rve)) then
          if(loval(rve)) then
            write(unit=TempUnit) beta(rve)
          endif
c
          do 158 k4 = 0,np(rve)/1000 - 1
            write(unit=TempUnit) (rad(igrain,rve),
     x                      igrain=k4*1000+1,(k4+1)*1000)
            write(unit=TempUnit) (aspect(igrain,rve),
     x                     igrain=k4*1000+1,(k4+1)*1000)
  158     continue
          write(unit=TempUnit)
     x      (rad(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
          write(unit=TempUnit)
     x      (aspect(igrain,rve),igrain=(np(rve)/1000)*1000+1,np(rve))
        endif
      endif
c
      if(lcirc2(rve)) then
        call circuit(rve)
c
        write(unit=TempUnit) ipt2,ipt4(rve),mfirst,ncells(rve)
        lim1 = ipt2 - 1
        lim2 = ipt4(rve)
        lim3 = ncells(rve)
        lim4 = np(rve)
        lim5 = mfirst
c
        do 24 k4 = 0,(lim1-mfirst)/1000 - 1
          write(unit=TempUnit) 
     x         (list1(i4,rve),i4=k4*1000+mfirst+1,(k4+1)*1000+mfirst)
   24   continue
        write(unit=TempUnit) 
     x       (list1(i4,rve),i4=((lim1-mfirst)/1000)*1000+mfirst+1,lim1)
c
        do 26 k4 = 0,(lim1+1)/1000 - 1
          write(unit=TempUnit) (list2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   26   continue
        write(unit=TempUnit) (list2(i4,rve),
     x                        i4=((lim1+1)/1000)*1000,lim1)
c
        do 31 k4 = 0,(lim1-mfirst-1)/1000 - 1
          write(unit=TempUnit) 
     x         (liste(i4,rve),i4=mfirst+k4*1000+1,mfirst+(k4+1)*1000)
   31   continue
        write(unit=TempUnit) (liste(i4,rve),
     x                 i4=mfirst+((lim1-mfirst-1)/1000)*1000+1,lim1)
c
        do 32 k4 = 0,lim2/1000 - 1
          write(unit=TempUnit) (v1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (v2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (p1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (p2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (f1(i4,rve),i4=k4*1000,(k4+1)*1000-1)
          write(unit=TempUnit) (f2(i4,rve),i4=k4*1000,(k4+1)*1000-1)
   32   continue
        write(unit=TempUnit) (v1(i4,rve),i4=(lim2/1000)*1000,lim2)
        write(unit=TempUnit) (v2(i4,rve),i4=(lim2/1000)*1000,lim2)
        write(unit=TempUnit) (p1(i4,rve),i4=(lim2/1000)*1000,lim2)
        write(unit=TempUnit) (p2(i4,rve),i4=(lim2/1000)*1000,lim2)
        write(unit=TempUnit) (f1(i4,rve),i4=(lim2/1000)*1000,lim2)
        write(unit=TempUnit) (f2(i4,rve),i4=(lim2/1000)*1000,lim2)
c
        do 34 k4 = 0,lim3/1000 - 1
          write(unit=TempUnit) (hf(i4,rve),i4=k4*1000+1,(k4+1)*1000)
   34   continue
        write(unit=TempUnit) (hf(i4,rve),i4=(lim3/1000)*1000+1,lim3)
c
c
        do 36 k4 = 0,lim4/1000 - 1
          write(unit=TempUnit) (hv(i4,rve),i4=k4*1000+1,(k4+1)*1000)
   36   continue
        write(unit=TempUnit) (hv(i4,rve),i4=(lim4/1000)*1000+1,lim4)
      endif
c
      if(lcirc3(rve)) then
c       print *,lim1,lim2,lim3,lim4
        lim1 = ipt2 - 1
        lim2 = ipt4(rve)
        lim3 = ncells(rve)
        lim4 = np(rve)
c
        frictw(rve) = 0.
        write(unit=TempUnit) ipt2,ipt4(rve),ncells(rve)
        write(unit=TempUnit) kn(rve),kratio(rve),knh(rve),
     x                kth(rve),frict(rve),frictw(rve)
c
        do 70 k4 = 0,lim2/1000 - 1
          do 73 i = 1,ndim1
            write(unit=TempUnit) (ftold(i,i4,rve),
     x                            i4=k4*1000,(k4+1)*1000-1)
   73     continue
          write(unit=TempUnit) (fnold1(i4,rve),
     x                          i4=k4*1000,(k4+1)*1000-1)
   70   continue
c
        do 71 i = 1,ndim1
          write(unit=TempUnit) (ftold(i,i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
   71   continue
        write(unit=TempUnit) (fnold1(i4,rve),i4=(lim2/1000)*1000,lim2)
c
        if(loval(rve)) then
          do 75 k4 = 0,lim2/1000 - 1
            do 76 i = 1,2
              write(unit=TempUnit) (quad(i,i4,rve),
     x                              i4=k4*1000,(k4+1)*1000-1)
   76       continue
   75     continue
c
          do 77 i = 1,2
            write(unit=TempUnit) (quad(i,i4,rve),
     x                          i4=(lim2/1000)*1000,lim2)
   77     continue
        endif
      endif
c
c-----In general, the file unit=TempUnit is for temporary input or
c     output (within a single subroutin), and it is closed 
c     immediately after its use
      close(unit=TempUnit)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine illeg(iflg,igrain,jgrain,
     x                 m_i,m_j,nupdat4,merror,nerror,
     x                 vh_i1,vh_i2,vh_i3,
     x                 vh_j1,vh_j2,vh_j3,
     x                 timer,ErrUnit,ScrUnit,rve,mrve)
c
        double precision timer,vh_i1,vh_i2,vh_i3,vh_j1,vh_j2,vh_j3
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 iflg,igrain,jgrain,m_i,m_j,merror,nerror
        integer*4 nupdat4
        integer*2 mrve,rve
        integer*2 ErrUnit(0:mrve),ScrUnit(0:mrve)
c
c-------this subroutin prints some error messages to the screen and also
c       to an error file.  It stops the program
c
c-------the number of error messages that have been reported
        nerror = nerror + 1
c
c-------oops!  It seems that we have found a pair of
c       particles that are not in contact, even though
c       the pair was not previously even included in the
c       list of near neighbors.  This situation is usually
c       the result of a particle somehow acquiring an
c       extremely large velocity, large enough to
c       bring it into immediate contact with other
c       particles that were not even close before.
c
        write(ScrUnit(rve),*)
     x   ' ERROR.  An illegitimate contact in subroutin lister.'
        if(nerror.le.merror) then
          write(ErrUnit(rve),*) ' An illegitimate contact in lister'
        endif
c
        if(iflg.eq.1) then
c---------the sudden contact was found between two particles
          write(ScrUnit(rve),*)
     x      'Contact detected betweentwo particles not already in'
          if(nerror.le.merror) then
            write(ErrUnit(rve),*) 'Contact detected between',
     x                 ' two particles not already in'
          endif
        elseif(iflg.eq.2) then
c---------the sudden contact was found between two new component pieces
          write(ScrUnit(rve),*)
     x     'Contact detected betweentwo component pieces not already in'
          if(nerror.le.merror) then
            write(ErrUnit(rve),*) 'Contact detected between',
     x                 ' two component pieces not already in'
          endif
        endif
        write(ScrUnit(rve),*) 'the linked list of near-neighbors.'
        if(nerror.le.merror) then
          write(ErrUnit(rve),*) 'the linked list of near-neighbors.'
        endif
c
        write(ScrUnit(rve),*) ' igrain=',igrain,
     x          ' jgrain=',jgrain,
     x          '  time =',timer
c
        if(nerror.le.merror) then
          write(ErrUnit(rve),*) '  time =',timer
          write(ErrUnit(rve),*) '  igrain =',igrain,
     x               '  jgrain =',jgrain
          write(ErrUnit(rve),*) '  vh(igrain) =',vh_i1,vh_i2,vh_i3
          write(ErrUnit(rve),*) '  vh(jgrain) =',vh_j1,vh_j2,vh_j3
        endif
c
        if(iflg.eq.2) then
          write(ScrUnit(rve),*) ' m_i =',m_i,
     x               ' m_j =',m_j,
     x               ' nupdat =',nupdat4
c
          if(nerror.le.merror) then
            write(ErrUnit(rve),*) ' m_i =',m_i,
     x                 ' m_j =',m_j,
     x                 ' nupdat =',nupdat4
         endif
        endif
c
c-------we will stop the program
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine omega(ddthr,dthr,l_i,l_j,l3d,lcdamp,
     x                  domegr,omegar)
c
c-------This subroutin computes the contact movement produced by 
c       the particle rotations.  Note that I have unrolled several 
c       nested loops to speed the calculation of cross products.
c
        implicit double precision(a-h,o-z)
        double precision ddthr,domegr,dthr,l_i,l_j,omegar
c
        logical l3d,lcdamp
c
        dimension ddthr(3,2),domegr(3),dthr(3,2),l_i(3),l_j(3),
     x            omegar(3)
c
        if(l3d) then
c---------a 3-dimensional particle, dthr() is a rotation component
c         and l_i() is the vector from the particle center to
c         the contact point.
          omegar(1) = (-dthr(2,1))*l_i(3)
     x                 +dthr(2,2) *l_j(3)
     x                 +dthr(3,1) *l_i(2)
     x                 -dthr(3,2) *l_j(2)
          omegar(2) = (-dthr(3,1))*l_i(1)
     x                 +dthr(3,2) *l_j(1)
     x                 +dthr(1,1) *l_i(3)
     x                 -dthr(1,2) *l_j(3)
          omegar(3) = (-dthr(1,1))*l_i(2)
     x                 +dthr(1,2) *l_j(2)
     x                 +dthr(2,1) *l_i(1)
     x                 -dthr(2,2) *l_j(1)
        else
c---------a 2-dimensional particle
          omegar(1) =   dthr(3,1) *l_i(2)
     x                 -dthr(3,2) *l_j(2)
          omegar(2) = (-dthr(3,1))*l_i(1)
     x                 +dthr(3,2) *l_j(1)
        endif
c
        if(lcdamp) then
c---------contact damping is being used.  We need to compute the
c         rate of contact movement produced by particle spins
          if(l3d) then
c-----------a 3-dimensional particle
            domegr(1) = (-ddthr(2,1))*l_i(3)
     x                   +ddthr(2,2) *l_j(3)
     x                   +ddthr(3,1) *l_i(2)
     x                   -ddthr(3,2) *l_j(2)
            domegr(2) = (-ddthr(3,1))*l_i(1)
     x                   +ddthr(3,2) *l_j(1)
     x                   +ddthr(1,1) *l_i(3)
     x                   -ddthr(1,2) *l_j(3)
            domegr(3) = (-ddthr(1,1))*l_i(2)
     x                   +ddthr(1,2) *l_j(2)
     x                   +ddthr(2,1) *l_i(1)
     x                   -ddthr(2,2) *l_j(1)
          else
c-----------a 2-dimensional particle
            domegr(1) =   ddthr(3,1) *l_i(2)
     x                   -ddthr(3,2) *l_j(2)
            domegr(2) = (-ddthr(3,1))*l_i(1)
     x                   +ddthr(3,2) *l_j(1)
          endif
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine frictn(c_eta,dampc2,ddxrlt,
     x                  dely,delz,dthr,dxreln,dxrelt,
     x                  fdmpav,fn,fnold,fricto,ftolds,
     x                  func1,func2,func3,func4,func5,knh,kthz,
     x                  l3d,last2,lcdamp,ltouch,ndim1,rtouch,viscc,
     x
     x                  cosft,dslip,
     x                  ft,ft2,ftmavg,fttot,npts,plastic,
     x                  ScrUnit, rve)
c
          include 'param-dempla-0.2.2.f'
c
c         implicit double precision(a-h,o-z)
c
          double precision a,alpha,alth,asdott,b,
     x         c,c_eta,cosf,cosfm,cosft,coss,costh,
     x         d,dampc2,delfn,delft2,delftm,dely,delz,dft,dft2,dftabc,
     x         dslip,dslip2,dthr,dtwist,dxrelm,dxreln,dxrelt,
     x         fds,fn,fnew,fnew2,fnewm,fnold,
     x         fricto,ft2,ftavg,ftdmp1,ftfact,ftm,ftm2,ftmag,
     x         ftmavg,ftold2,ftolda,ftoldm,ftoldn,ftolds,
     x         ftom2,ftomag,ftpro2,ftproj,ftprom,
     x         knh,kthz,pi,radicl,rtouch,s1,s2,sdim,sdott,sinth,
     x         theta1,viscc,x,xmi1,wro
          logical l3d,last2,lcdamp,ltouch,plastic
c
c-------these integers will be too large for integer*2 with large assemblies
          integer*4 ndim1
c
          integer*2 i1,i1p1,rve, npts, ScrUnit
c
          dimension c_eta(3),cosf(3),cosft(3),coss(3),cost(3),
     x              ddxrlt(3),dftabc(3),dthr(3,2),dxrelt(3),
     x              fnew(3),
     x              ft(3),ftavg(3),ftolda(3),
     x              ftolds(3),ftproj(3),fttot(3),
     x              func1(0:mpts),func2(0:mpts),func3(0:mpts+1),
     x              func4(0:mpts+1),func5(0:mpts+1),
     x              ScrUnit(0:mrve)

c---------this subroutin computes the tangential contact force for the case
c         of a contact mechanism with linear normal and tangential springs and
c         simple coulomb friction
c
c---------check for proper compile
          if(mpts.ne.npts) then
            write(ScrUnit(rve),*) '******** ERROR *************'
            write(ScrUnit(rve),*)
     x        'parameter mpts in param-dempla-0.2.2.f and in',
     x        ' subroutin frictn are not equal'
            write(ScrUnit(rve),*) 'Fix and recompile.'
          endif
c
          pi = 3.14159265358979323846d0
c
c---------has frictional slipping occured at this contact? (initialize)
          plastic = .false.
c
c---------the amount of frictional slipping at this contact (initialize)
          dslip = 0.
          dslip2 = 0.
c
c---------squared magnitude of the tangential contact force
          ft2 = 0.
c
c---------the maximum tangential force, based upon the normal force
c         and the friction coefficient
          ftm = fn*fricto
c
c---------the squared magnitude of ftm
          ftm2 = ftm**2
c
c---------initialize the 3-component for 2D simulations
          if(.not.l3d) then
            cosf(3) = 0.
            cosft(3) = 0.
            ftolda(3) = 0.
            fnew(3) = 0.
            ftproj(3) = 0.
            ft(3) = 0.
            ftavg(3) = 0.
          endif
c
          do 153 k = 1,ndim1
c-----------the change in tangential contact force that would result from this
c           movement if there were no frictional slipping (this value will, 
c           of course, need to be modified in the event of frictional 
c           slipping between particles
c-----------Notice that we do not use rtouch
            dftabc(k) = dxrelt(k)*kthz
  153     continue
c
c---------because the normal vector may rotate during the previous time
c         step, the tangent force will also rotate.  We must rotate
c         the old tangent force "ftolds" as described by Lin and Ng,
c         Geotechnique, 47(2), 319-329. 
          if(l3d) then
c-----------the squared length of the old tangent force, this norm
c           will be preserved during our rotation of the old tangent force
            ftold2 = ftolds(1)**2 + ftolds(2)**2 + ftolds(3)**2
c
c-----------the component of the old tangent force in the normal direction.
c           This will be used to project the old tangent force onto the
c           new tangent plane
            ftoldn = ftolds(1)*c_eta(1) + ftolds(2)*c_eta(2)
     x               + ftolds(3)*c_eta(3)
c
c-----------the projection of the old tangent force onto the new tangent plane
            ftproj(1) = ftolds(1) - ftoldn*c_eta(1)
            ftproj(2) = ftolds(2) - ftoldn*c_eta(2)
            ftproj(3) = ftolds(3) - ftoldn*c_eta(3)
c
c-----------length of the projected force
            ftpro2 = ftproj(1)**2 + ftproj(2)**2 + ftproj(3)**2
            ftprom = sqrt(ftpro2)
c
c-----------lenght of the old tangent force
            ftomag = sqrt(ftold2)
c
            if(ftprom.gt.0.) then
c-------------adjust the length of the projected tangent force, so that it
c             equals that of hte old tangent force
              ftolda(1) = ftomag*ftproj(1)/ftprom
              ftolda(2) = ftomag*ftproj(2)/ftprom
              ftolda(3) = ftomag*ftproj(3)/ftprom
c
c-------------now for another adjustment to the old tangent force, not
c             described in Lin and Ng.  If the two particles rotate about
c             the normal vector as a rigid body (a rigid twist), 
c             then the contact force will rotate in the tangent plane.  
c             This adjustment only applies in 3D.
c             Note that dthr(:,1) is the rotation increment of the first
c             particle, and dthr(:,2) is the rotation increment of the second
c             particle.
c
c-------------the average rotation of the two particles about the normal 
c             vector.  Although there are other definitions of a rigid
c             rotation, we will treat this as the rigid twist.
              dtwist = 0.5d0*(  (dthr(1,1) + dthr(1,2))*c_eta(1)
     x                        + (dthr(2,1) + dthr(2,2))*c_eta(2)
     x                        + (dthr(3,1) + dthr(3,2))*c_eta(3))
c
              ftolda(1) = ftolda(1) 
     x                    - dtwist*(ftolda(2)*c_eta(3) 
     x                    - ftolda(3)*c_eta(2))
              ftolda(2) = ftolda(2)
     x                    - dtwist*(ftolda(3)*c_eta(1) 
     x                    - ftolda(1)*c_eta(3))
              ftolda(3) = ftolda(3)
     x                    - dtwist*(ftolda(1)*c_eta(2) 
     x                    - ftolda(2)*c_eta(1))
            else
              ftolda(1) = 0.
              ftolda(2) = 0.
              ftolda(3) = 0.
            endif
          else
            ftold2 = ftolds(1)**2 + ftolds(2)**2
c
            ftoldn = ftolds(1)*c_eta(1) + ftolds(2)*c_eta(2)
c
            ftproj(1) = ftolds(1) - ftoldn*c_eta(1)
            ftproj(2) = ftolds(2) - ftoldn*c_eta(2)
c
            ftpro2 = ftproj(1)**2 + ftproj(2)**2
            ftprom = sqrt(ftpro2)
            ftomag = sqrt(ftold2)
c
            if(ftprom.gt.0.) then
              ftolda(1) = ftomag*ftproj(1)/ftprom
              ftolda(2) = ftomag*ftproj(2)/ftprom
            else
              ftolda(1) = 0.
              ftolda(2) = 0.
            endif
          endif
c
          do 51 k = 1,ndim1
c-----------the new tangential contact force, based upon the 
c           previous force and the change produce by the particle
c           movements and rotations.  Note that this force will
c           need to be modified in the event of frictional slipping
            ft(k) = ftolda(k) + dftabc(k)
c
c-----------the squared magnitude
            ft2 = ft2 + ft(k)**2
   51     continue
c
          if(ft2.gt.ftm2) then
c-----------the friction coefficient has been exceeded.  
c
c-----------The contact is slipping.
            plastic = .true.
c
c-----------compute the previous normal force
            delfn = -(dxreln*knh)
            fnold = fn - delfn
c
            if(ltouch.or.fnold.lt.0.) then
c-------------this is a new contact
c
c-------------magnitude of the tangential force (at present, neglecting
c             any frictional slipping)
              ftmag = sqrt(ft2)
c
c-------------now, scale the tangential forces so that the
c             the new magnitude will equal the normal force times
c             the friction coefficient
              ftfact = ftm / ftmag
              ft(1) = ft(1)*ftfact
              ft(2) = ft(2)*ftfact
              ft(3) = ft(3)*ftfact
c
              if(last2) then
c---------------if subroutin force is going to be exited, then
c               compute the amount of contact slip, etc.
                ftmavg = ftm
c               dslip = (ftmag - ftm) / kthz
c---------------an equivalent "dslip" that will give the frictional
c               dissipation when paired with ftmavg.  The frictional
c               dissipation equals the full work area minus the
c               elastic area
                dxrelm = sqrt(dxrelt(1)**2 + dxrelt(2)**2 +dxrelt(3)**2)
                dslip = 0.5d0*(ftmag*dxrelm - (ftm**2)/kthz) / ftmavg
c
                ft2 = ft(1)*ft(1) + ft(2)*ft(2) + ft(3)*ft(3)
                cosft(1) = ft(1) / ftm
                cosft(2) = ft(2) / ftm
                cosft(3) = ft(3) / ftm
              endif
c
            else
c-------------this is an existing contact.
c
              delftm = delfn*fricto
              delft2 = delftm**2
              ftoldm = fnold*fricto
              ftom2 = ftoldm**2
              wro = delftm*ftoldm
c
              if(l3d) then
                ftold2 = ftolda(1)**2 + ftolda(2)**2 + ftolda(3)**2
                dft2 = dftabc(1)**2 + dftabc(2)**2 + dftabc(3)**2
                fds = ftolda(1)*dftabc(1) + ftolda(2)*dftabc(2)
     x                                    + ftolda(3)*dftabc(3)
              else
                ftold2 = ftolda(1)**2 + ftolda(2)**2
                dft2 = dftabc(1)**2 + dftabc(2)**2
                fds = ftolda(1)*dftabc(1) + ftolda(2)*dftabc(2)
              endif
c
              a = dft2 - delft2
              b = fds - wro
              c = ftold2 - ftom2
              d = 0.
c
              if(c.gt.0.) then
                ftoldm = ftomag
                ftom2 = ftoldm**2
                wro = delftm*ftoldm
                b = fds - wro
                c = 0.
              endif
c
              if(c.lt.-(0.00000001d0*ftom2)) then
c             if(c.lt.-(0.000001d0*ftom2) .or. b.lt.0.) then
                if(c.gt.0.) then
                  c = 0.
                endif
c
                if(a.eq.0.) then
                  if(delftm.lt.0.) then
                    if(b.ne.0.) then
                      d = -(c / b / 2.d0)
                    endif
                  endif
                else
                  radicl = b**2 - a*c
                  if(radicl.ge.0.) then
                    d = (-b + sqrt(radicl)) / a
                  endif
                endif
c
                fnew(1) = ftolda(1) + dftabc(1)*d
                fnew(2) = ftolda(2) + dftabc(2)*d
                if(l3d) then
                  fnew(3) = ftolda(3) + dftabc(3)*d
                  fnew2 = fnew(1)**2 + fnew(2)**2 + fnew(3)**2
                else
                  fnew2 = fnew(1)**2 + fnew(2)**2
                endif
                fnewm = sqrt(fnew2)
c
                cosf(1) = fnew(1) / fnewm
                cosf(2) = fnew(2) / fnewm
                cosf(3) = fnew(3) / fnewm
c
                ftmavg = (fnewm + ftm) / 2.d0
c
              else
                if(ftoldm.ne.0.) then
                  fnewm = ftoldm
                elseif(ftm.ne.0.) then
                  fnewm = ftm
                else
                  write(ScrUnit(rve),*) 'ERROR 10 in subroutin frictn'
                endif
c
                cosf(1) = ftolda(1) / fnewm
                cosf(2) = ftolda(2) / fnewm
                cosf(3) = ftolda(3) / fnewm
c
                ftmavg = (ftoldm + ftm) / 2.d0
              endif
c
              dft = sqrt(dft2)
c
              if(l3d) then
                if(dft.ne.0) then
                  coss(1) = dftabc(1) / dft
                  coss(2) = dftabc(2) / dft
                  coss(3) = dftabc(3) / dft
c
                  cost(1) = c_eta(2)*cosf(3) -c_eta(3)*cosf(2)
                  cost(2) = c_eta(3)*cosf(1) -c_eta(1)*cosf(3)
                  cost(3) = c_eta(1)*cosf(2) -c_eta(2)*cosf(1)
                  sdott = coss(1)*cost(1) + coss(2)*cost(2)
     x                      + coss(3)*cost(3)
                else
                  sdott = 0.
                endif
c
                sdim = (1.d0 - d) * dft / ftmavg
c
                asdott = abs(sdott)
                if(asdott.ge.1.d0) then
c                 print *,'Error 2 in finding tangent force'
                  s1 = 0.
                  alpha = 0.
c
                  if(asdott.gt.1.d0) then
                    cosfm = 
     x                 cosf(1)**2 + cosf(2)**2 + cosf(3)**2
                    cosfm = sqrt(cosfm)
                    cosf(1) = cosf(1)/cosfm
                    cosf(2) = cosf(2)/cosfm
                    cosf(3) = cosf(3)/cosfm
c
                    if(l3d) then
                      cost(1) =   c_eta(2)*cosf(3) 
     x                          - c_eta(3)*cosf(2)
                      cost(2) =   c_eta(3)*cosf(1) 
     x                          - c_eta(1)*cosf(3)
                    endif
                    cost(3) = c_eta(1)*cosf(2) -c_eta(2)*cosf(1)
                  endif
                else
                  x = mpts*asdott
                  i1 = x
                  i1p1 = i1 + 1
                  xmi1 = x - i1
c
                  if(x.lt.1.d0) then
                    if(x.gt.0.) then
                      s2 = tan(acos(asdott)/2.d0+pi/4.d0)
                      if(s2.ge.1.d-11) then
                        s1 = log(s2)
                      else
                        s1 = 20.
                      endif
                    else
                      s1 = 20.
                    endif
                  else
                    s1 = func1(i1) + xmi1*
     x                             (func1(i1p1) - func1(i1))
                  endif
c
                  alpha = func3(i1) + xmi1*
     x                              (func3(i1p1) - func3(i1))
                endif
c
                s1 = s1 + sdim
c
                if(s1.lt.func1(1)) then
                  s1 = s1 / dely
                  i1 = s1
                  alth = func2(i1)
     x                   + (s1-i1)*(func2(i1+1) - func2(i1))
                else
                  alth = 2.d0*(atan(exp(s1)) - pi/4.d0)
                  if(alth.lt.-1.d-7 .or. alth.gt.1.5707964d0) then
                    write(ScrUnit(rve),*)
     x                'Error 3 in finding tangent force'
                  endif
                endif
c
                theta1 = alth - alpha
c
                x = theta1/delz
                i1 = x
                i1p1 = i1 + 1
                xmi1 = x - i1
                costh = func4(i1) 
     x                  + xmi1*(func4(i1p1) - func4(i1))
                sinth = func5(i1) 
     x                  + xmi1*(func5(i1p1) - func5(i1))
c
                if(sdott.lt.0.) then
                  sinth = -sinth
                endif
c
                cosft(1) = costh*cosf(1) + sinth*cost(1)
                cosft(2) = costh*cosf(2) + sinth*cost(2)
                cosft(3) = costh*cosf(3) + sinth*cost(3)
              elseif(ndim1.eq.2) then
                cosft(1) = cosf(1)
                cosft(2) = cosf(2)
                cosft(3) = cosf(3)
              endif
c
              cosftm = sqrt(cosft(1)**2 + cosft(2)**2 + cosft(3)**2)
              cosft(1) = cosft(1) / cosftm
              cosft(2) = cosft(2) / cosftm
              cosft(3) = cosft(3) / cosftm
c
              if(last2) then
                dslip = ((ft(1)*cosft(1) + ft(2)*cosft(2)
     x                    + ft(3)*cosft(3)) - fnewm) / kthz
              endif
c
              ft(1) = ftm * cosft(1)
              ft(2) = ftm * cosft(2)
              ft(3) = ftm * cosft(3)
c
              if(last2) then
                ft2 = ft(1)*ft(1) + ft(2)*ft(2) + ft(3)*ft(3)
              endif
c
              if(last2) then
                ftavg(1) = 0.5d0*(ft(1) + ftolds(1))
                ftavg(2) = 0.5d0*(ft(2) + ftolds(2))
                ftavg(3) = 0.5d0*(ft(3) + ftolds(3))
                dslip2 = ((  ftavg(1)*dxrelt(1) 
     x                     + ftavg(2)*dxrelt(2) 
     x                     + ftavg(3)*dxrelt(3))
     x                    - 0.5d0*(ftm2 - ftold2) / kthz) / ftmavg
                dslip = dslip2
              endif
            endif
          endif
c
          ftmag = ftoldm
c
c---------with contact damping . . .
          if(lcdamp .and. .not.plastic) then
            do 57 k = 1,ndim1
c-------------the contact force, including the contact damping component
              ftdmp1 = dampc2*ddxrlt(k)
c
c-------------energy expended in viscous (tangential) movements
              viscc = viscc + ftdmp1*ddxrlt(k)*rtouch
c
c-------------the total (tangential) contact force, including the
c             viscous component
              fttot(k) = ft(k) + ftdmp1
              fdmpav = fdmpav + ftdmp1**2
   57       continue
          else
            do 67 k = 1,ndim1
              fttot(k) = ft(k)
   67       continue
          endif
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine frictl(c_eta,dampc2,ddxrlt,
     x                  dfunc7i,dthr,dxreln,dxrelt,
     x                  fdmpav,fn,fnold,fricto,ftolds,
     x                  func7i,knh,kthz,
     x                  l3d,last2,lcdamp,ltouch,ndim1,rtouch,viscc,
     x                  linitf,
     x
     x                  cosft,dslip,
     x                  ft,ft2,ftmavg,fttot,npts,plastic,
     x                  ScrUnit, rve)
c
          include 'param-dempla-0.2.2.f'
c
c         implicit double precision(a-h,o-z)
c
          double precision a,adjst,alpha_0,alpha_s,
     x         b,bigD, bigE,
     x         c,c1,c2,c_eta,cosf,cosft,coss,ctheta,
     x         dampc2,delfn,delft2,delftm,delzeta,
     x         dft,dft2,dftabc,dfunc7i,
     x         dslip,dslip2,dthr,dtwist,dxrelm,dxreln,dxrelt,
     x         eps,eps2,fds,fn,fnold,
     x         fricto,ft2,ftavg,ftdmp1,ftfact,ftm,ftm2,ftmag,
     x         ftmavg,ftold,ftold2,ftoldm,ftoldn,ftolds,
     x         ftom2,ftomag,ftpro2,ftproj,ftprom,
     c         func7i,
     x         knh,kthz,pi,radicl,rtouch,sdott,
     x         theta_t,theta_tpdt,viscc,x,wro
          logical l3d,last2,lcdamp,linitf,ltouch,plastic
c
c---------these integers will be too large for integer*2 with large assemblies
          integer*4 ndim1
c
          integer*2 i1,rve,npts,ScrUnit
c
          dimension c_eta(3),cosf(3),cosft(3),coss(3),cost(3),
     x              ddxrlt(3),dftabc(3),dthr(3,2),dxrelt(3),
     x              ft(3),ftavg(3),ftold(3),
     x              ftolds(3),ftproj(3),fttot(3),
     x              func7i(0:mpts+1),
     x              ScrUnit(0:mrve)

c---------this subroutin computes the tangential contact force for the case
c         of a contact mechanism with linear normal and tangential springs and
c         simple coulomb friction
c
c---------small numbers
          eps = 1.d-8
          eps2 = 1.d-12
c
c---------rtouch was computed in subroutin forces, as in Eq. 6
          alpha_0 = 1.d0 - rtouch
c
c---------check for proper compile
          if(mpts.ne.npts) then
            write(ScrUnit(rve),*) '******** ERROR *************'
            write(ScrUnit(rve),*)
     x        'parameter mpts in param-dempla-0.2.2.f and in',
     x        ' subroutin frictl are not equal'
            write(ScrUnit(rve),*) 'Fix and recompile.'
          endif
c
          pi = 3.14159265358979323846d0
c
c---------has frictional slipping occured at this contact? (initialize)
          plastic = .false.
c
c---------the amount of frictional slipping at this contact (initialize)
          dslip = 0.
          dslip2 = 0.
c
c---------squared magnitude of the tangential contact force
          ft2 = 0.
c
c---------the maximum tangential force, based upon the normal force
c         and the friction coefficient
          ftm = fn*fricto
c
c---------the squared magnitude of ftm
          ftm2 = ftm**2
c
c---------Delta_zeta in Eq. 5 and line 8
          delzeta = -dxreln
c
c---------initialize the 3-component for 2D simulations
          if(.not.l3d) then
            cosf(3) = 0.
            cosft(3) = 0.
            ftproj(3) = 0.
            ft(3) = 0.
            ftavg(3) = 0.
            ftold(3) = 0.
          endif
c
          do 153 k = 1,ndim1
c-----------the previous tangential force
            ftold(k) = ftolds(k)
c
c-----------the change in tangential contact force that would result from this
c           movement if there were no frictional slipping (this value will, 
c           of course, need to be modified in the event of frictional 
c           slipping between particles
c
c-----------Notice that we do not use rtouch. Eq. 6 and 7, and lines 12 and 18
            dftabc(k) = (1.d0 - alpha_0)*dxrelt(k)*kthz
  153     continue
c
c---------because the normal vector may rotate during the previous time
c         step, the tangent force will also rotate.  We must rotate
c         the old tangent force "ftolds" as described by Lin and Ng,
c         Geotechnique, 47(2), 319-329.  See lines 46 and 47
          if(l3d) then
c-----------the squared length of the old tangent force, this norm
c           will be preserved during our rotation of the old tangent force
            ftold2 = ftold(1)**2 + ftold(2)**2 + ftold(3)**2
c
c-----------the component of the old tangent force in the normal direction.
c           This will be used to project the old tangent force onto the
c           new tangent plane
            ftoldn = ftold(1)*c_eta(1) + ftold(2)*c_eta(2)
     x               + ftold(3)*c_eta(3)
c
c-----------the projection of the old tangent force onto the new tangent plane
            ftproj(1) = ftold(1) - ftoldn*c_eta(1)
            ftproj(2) = ftold(2) - ftoldn*c_eta(2)
            ftproj(3) = ftold(3) - ftoldn*c_eta(3)
c
c-----------length of the projected force
            ftpro2 = ftproj(1)**2 + ftproj(2)**2 + ftproj(3)**2
            ftprom = sqrt(ftpro2)
c
c-----------lenght of the old tangent force
            ftomag = sqrt(ftold2)
c
            if(ftprom.gt.0.) then
c-------------adjust the length of the projected tangent force, so that it
c             equals that of hte old tangent force
              ftold(1) = ftomag*ftproj(1)/ftprom
              ftold(2) = ftomag*ftproj(2)/ftprom
              ftold(3) = ftomag*ftproj(3)/ftprom
c
c-------------now for another adjustment to the old tangent force, not
c             described in Lin and Ng.  If the two particles rotate about
c             the normal vector as a rigid body (a rigid twist), 
c             then the contact force will rotate in the tangent plane.  
c             This adjustment only applies in 3D.
c             Note that dthr(:,1) is the rotation increment of the first
c             particle, and dthr(:,2) is the rotation increment of the second
c             particle.
c
c-------------the average rotation of the two particles about the normal 
c             vector.  Although there are other definitions of a rigid
c             rotation, we will treat this as the rigid twist.
              dtwist = 0.5d0*(  (dthr(1,1) + dthr(1,2))*c_eta(1)
     x                        + (dthr(2,1) + dthr(2,2))*c_eta(2)
     x                        + (dthr(3,1) + dthr(3,2))*c_eta(3))
c
              ftold(1) = ftold(1) 
     x                   - dtwist*(ftold(2)*c_eta(3) 
     x                   - ftold(3)*c_eta(2))
              ftold(2) = ftold(2)
     x                   - dtwist*(ftold(3)*c_eta(1) 
     x                   - ftold(1)*c_eta(3))
              ftold(3) = ftold(3)
     x                   - dtwist*(ftold(1)*c_eta(2) 
     x                   - ftold(2)*c_eta(1))
c
c-------------adjust ftold one more time, so that its magnitude
c             is equal to its original magnitude. Because the difference
c             will be very tiny, use Taylor series expansion of sqrt()
              adjst = 1.d0 - 0.5d0
     x                       *((ftold(1)**2 + ftold(2)**2 + ftold(3)**2)
     x                         / ftold2 - 1.d0)
              ftold(1) = adjst * ftold(1)
              ftold(2) = adjst * ftold(2)
              ftold(3) = adjst * ftold(3)
            else
              ftold(1) = 0.
              ftold(2) = 0.
              ftold(3) = 0.
            endif
          else
            ftold2 = ftold(1)**2 + ftold(2)**2
c
            ftoldn = ftold(1)*c_eta(1) + ftold(2)*c_eta(2)
c
            ftproj(1) = ftold(1) - ftoldn*c_eta(1)
            ftproj(2) = ftold(2) - ftoldn*c_eta(2)
c
            ftpro2 = ftproj(1)**2 + ftproj(2)**2
            ftprom = sqrt(ftpro2)
            ftomag = sqrt(ftold2)
c
            if(ftprom.gt.0.) then
              ftold(1) = ftomag*ftproj(1)/ftprom
              ftold(2) = ftomag*ftproj(2)/ftprom
            else
              ftold(1) = 0.
              ftold(2) = 0.
            endif
          endif
c
          do 51 k = 1,ndim1
c-----------the new tangential contact force, based upon the 
c           previous force and the change produce by the particle
c           movements and rotations.  Note that this force will
c           need to be modified in the event of frictional slipping
            ft(k) = ftold(k) + dftabc(k)
c
c-----------the squared magnitude
            ft2 = ft2 + ft(k)**2
   51     continue
c
          if(ft2.gt.ftm2) then
c-----------the friction coefficient has been exceeded.  
c
c-----------The contact is slipping.
            plastic = .true.
c
c-----------compute the previous normal force
            if(linitf) then
c-------------the old contact force was not computed
              delfn = delzeta*knh
              fnold = fn - (1.d0 - alpha_0)*delfn
            else
c-------------use the stored value of fnold, retrieved from array fnold1()
              delfn = fn - fnold
              delzeta = delfn / knh
            endif
c
c           line 9
            if(ltouch.or.fnold.lt.0.) then
c-------------this is a new contact
c
c-------------magnitude of the tangential force (at present, neglecting
c             any frictional slipping)
              ftmag = sqrt(ft2)
c
c-------------now, scale the tangential forces so that the
c             the new magnitude will equal the normal force times
c             the friction coefficient. Eq. 2_3, and line 14
              ftfact = ftm / ftmag
              ft(1) = ft(1)*ftfact
              ft(2) = ft(2)*ftfact
              ft(3) = ft(3)*ftfact
c
              if(last2) then
c---------------if subroutin force is going to be exited, then
c               compute the amount of contact slip, etc.
                ftmavg = ftm
c               dslip = (ftmag - ftm) / kthz
c---------------an equivalent "dslip" that will give the frictional
c               dissipation when paired with ftmavg.  The frictional
c               dissipation equals the full work area minus the
c               elastic area
                dxrelm = sqrt(dxrelt(1)**2 + dxrelt(2)**2 +dxrelt(3)**2)
                dslip = 0.5d0*(ftmag*dxrelm - (ftm**2)/kthz) / ftmavg
c
                ft2 = ft(1)*ft(1) + ft(2)*ft(2) + ft(3)*ft(3)
                cosft(1) = ft(1) / ftm
                cosft(2) = ft(2) / ftm
                cosft(3) = ft(3) / ftm
              endif
c
c-----------line 17
            else
c-------------this is an existing contact.
c
              delftm = delfn*fricto
              delft2 = delftm**2
              ftoldm = fnold*fricto
              ftom2 = ftoldm**2
              wro = delftm*ftoldm
c
              if(l3d) then
                ftold2 = ftold(1)**2 + ftold(2)**2 + ftold(3)**2
                dft2 = dftabc(1)**2 + dftabc(2)**2 + dftabc(3)**2
                fds = ftold(1)*dftabc(1) + ftold(2)*dftabc(2)
     x                                   + ftold(3)*dftabc(3)
              else
                ftold2 = ftold(1)**2 + ftold(2)**2
                dft2 = dftabc(1)**2 + dftabc(2)**2
                fds = ftold(1)*dftabc(1) + ftold(2)*dftabc(2)
              endif
c
c-------------Eqs. 10, 11, 12, and lines 21, 22, 23
              a = dft2 - delft2
              b = fds - wro
              c = ftold2 - ftom2
              alpha_s = 0.
c
              if(abs(c).gt.eps2*ftom2) then
c
c---------------line 24
                if(abs(a).lt.eps*abs(dft2*delft2)) then
                  if(b.ne.0.) then
c-------------------Eq. 13
                    alpha_s = -(c / b / 2.d0)
                  else
                    alpha_s = 0.
                  endif
                else
c-----------------line 25
                  radicl = b**2 - a*c
                  if(radicl.ge.0.) then
c-------------------Eq. 9
                    alpha_s = (-b + sqrt(radicl)) / a
                  else
                    alpha_s = 0.
                  endif
                endif
c
                if(alpha_s .lt. 0. .or. alpha_s.gt.1.d0) then
                  continue
                endif
c
              else
c---------------when c=0 in Eq. 9 or 13
c               if(abs(a).lt.eps*abs(dft2*delft2)) then
c                 alpha_s = 0.
c               else
c                 alpha_s = -2.d0*b/a
c               endif
                alpha_s = max(0., -2.d0*b/a)
c
                if(alpha_s .lt. 0. .or. alpha_s.gt.1.d0) then
                  if(a+2.d0*b .gt. 0.) then
                    alpha_s = 0.
                  else
                    write(ScrUnit(rve),*) 
     x                   'ERROR 11 in subroutin frictl'
                  endif
                endif
c               alpha_s = 0.
c               if(ftold2.ne.0.) then
c                 ftoldm = sqrt(ftold2)
c               elseif(ftm.ne.0.) then
c                 ftoldm = ftm
c               else
c                 print *,'ERROR 10 in subroutin frictn'
c               endif
              endif
c
c-------------line 27. Reset ftold
              ftold(1) = ftold(1) + dftabc(1)*alpha_s
              ftold(2) = ftold(2) + dftabc(2)*alpha_s
              if(l3d) then
                ftold(3) = ftold(3) + dftabc(3)*alpha_s
                ftold2 = ftold(1)**2 + ftold(2)**2 + ftold(3)**2
              else
                ftold2 = ftold(1)**2 + ftold(2)**2
              endif
              ftoldm = sqrt(ftold2)
c
c-------------line 27. Reset fnold
              fnold = fnold + alpha_s*delzeta*knh
c
c-------------line 28, reset delzeta
              delzeta = (1.d0 - alpha_s) * delzeta
c
c-------------unit vector m^(f,t) in line 30
              cosf(1) = ftold(1) / ftoldm
              cosf(2) = ftold(2) / ftoldm
              cosf(3) = ftold(3) / ftoldm
c
              ftmavg = (ftoldm + ftm) / 2.d0
c
              dft = sqrt(dft2)
c
              if(l3d) then
                if(dft.ne.0) then
c-----------------unit vector m^(Delta xi) in line 31
                  coss(1) = dftabc(1) / dft
                  coss(2) = dftabc(2) / dft
                  coss(3) = dftabc(3) / dft
c
c-----------------unit vector m^(perp Delta xi) in line 32
                  cost(1) = c_eta(2)*coss(3) - c_eta(3)*coss(2)
                  cost(2) = c_eta(3)*coss(1) - c_eta(1)*coss(3)
                  cost(3) = c_eta(1)*coss(2) - c_eta(2)*coss(1)
c
c-----------------the inner product in line 33
                  sdott =   cosf(1)*cost(1) + cosf(2)*cost(2)
     x                    + cosf(3)*cost(3)
                else
                  sdott = 0.
                endif
c
c---------------line 33, the angle between m^(Delta xi) and m^(f perp, t)
                if(sdott.gt.1.d0) then
                  theta_t =  pi/2.d0
                elseif(sdott.lt.-1.d0) then
                  theta_t = -pi/2.d0
                else
                  theta_t = asin(sdott)
                endif
c
                if(abs(theta_t).lt.eps) then
c-----------------line XX
                  theta_tpdt = theta_t
                else
c-----------------line 34
                  c1 = fricto * fnold / ((1.d0 - alpha_s)*dft)
c
c-----------------line 35
                  c2 = knh * delzeta / fnold
c
c-----------------line XX
                  bigD = log(abs(1.d0/sin(theta_t) - 1.d0/tan(theta_t)))
c-----------------Or ...
c                 x = theta_t / dfunc6
c                 i1 = x
c                 if(i1.eq.0) then
c                   bigD = log(abs(csc(theta_t) - cot(theta_t)))
c                 elseif
c                   bigD = func6(i1)
c    x                     + (x - i1)*(func6(i1+1) - func6(i1))
c                 endif
c
                  if(abs(c2).lt.eps) then
c-------------------line XX
                    bigE = 1.d0 / c1
                  else
c-------------------line XX
                    bigE = log(1.d0 + c2) / c1 / c2
                  endif
c
c-----------------solve Eq. 17
                  x = exp(bigD - bigE) / dfunc7i
c
                  i1 = x
                  theta_tpdt = func7i(i1) 
     x                         + (x - i1)*(func7i(i1+1) - func7i(i1))
                endif
c
c----------------
                theta_tpdt = sign(theta_tpdt, theta_t)
                ctheta = cos(theta_tpdt)
                stheta = sin(theta_tpdt)

c---------------line XX
                cosft(1) = stheta*cost(1)  + ctheta*coss(1)
                cosft(2) = stheta*cost(2)  + ctheta*coss(2)
                cosft(3) = stheta*cost(3)  + ctheta*coss(3)
              elseif(ndim1.eq.2) then
                cosft(1) = cosf(1)
                cosft(2) = cosf(2)
                cosft(3) = cosf(3)
              endif
c
              cosftm = sqrt(cosft(1)**2 + cosft(2)**2 + cosft(3)**2)
              cosft(1) = cosft(1) / cosftm
              cosft(2) = cosft(2) / cosftm
              cosft(3) = cosft(3) / cosftm
c
              if(last2) then
                dslip = ((ft(1)*cosft(1) + ft(2)*cosft(2)
     x                    + ft(3)*cosft(3)) - ftoldm) / kthz
              endif
c
              ft(1) = ftm * cosft(1)
              ft(2) = ftm * cosft(2)
              ft(3) = ftm * cosft(3)
c
              if(last2) then
                ft2 = ft(1)*ft(1) + ft(2)*ft(2) + ft(3)*ft(3)
              endif
c
              if(last2) then
                ftavg(1) = 0.5d0*(ft(1) + ftolds(1))
                ftavg(2) = 0.5d0*(ft(2) + ftolds(2))
                ftavg(3) = 0.5d0*(ft(3) + ftolds(3))
                dslip2 = ((  ftavg(1)*dxrelt(1) 
     x                     + ftavg(2)*dxrelt(2) 
     x                     + ftavg(3)*dxrelt(3))
     x                    - 0.5d0*(ftm2 - ftold2) / kthz) / ftmavg
                dslip = dslip2
              endif
            endif
          endif
c
          ftmag = ftoldm
c-----------------------------------------------------
c
c---------with contact damping . . .
          if(lcdamp .and. .not.plastic) then
            do 57 k = 1,ndim1
c-------------the contact force, including the contact damping component
              ftdmp1 = dampc2*ddxrlt(k)
c
c-------------energy expended in viscous (tangential) movements
              viscc = viscc + ftdmp1*ddxrlt(k)*rtouch
c
c-------------the total (tangential) contact force, including the
c             viscous component
              fttot(k) = ft(k) + ftdmp1
              fdmpav = fdmpav + ftdmp1**2
   57       continue
          else
            do 67 k = 1,ndim1
              fttot(k) = ft(k)
   67       continue
          endif
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine Mindlin(ovrlap, Ebar, Gbar, frict, dxreln, 
     x                   dxrelt, l3d, lcdamp, Tstar, ft_old, 
     x                   R, rtouch, dampc2, fn, a, n,
     x                   ft, ft2, fttot, ftmavg, cosft, dslip, ierr)
c
        double precision a,a_i,a_o,cosft,
     x                   dampc2,ddxrln,ddxrlt,ddxrltm,ddxtn,ddxtt,
     x                   dfn,dftt,drtouch,dslip,dxreln,dxrelt,
     x                   Ebar,fn,fn_i,fn_o,frict,
     x                   ft,ft2,ft_i,ft_o,ft_old,ftrel,
     x                   ftmag,ftmago,ftmag1,ftmavg,ftmax,fttot,
     x                   Gbar,H,Ho,Ho_1,Ho_avg,H_p,
     x                   ovrlap,ovr_i,ovrold,R,reduc,rtouch,
     x                   theta1,third,third2,Tn,Tstar,Tstar1,yieldn
c
        logical l3d,lcdamp
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 i,ierr,n
c
        dimension cosft(3),ddxrlt(3),ddxtt(3),dftt(3),dxrelt(3),
     x            ft(3),ft_i(3),ft_o(3),ft_old(3),fttot(3),yieldn(3)
c
        third = 1.d0 / 3.d0
        third2 = 2.d0 / 3.d0
c
        ierr = 0
        ft(3) = 0.
c
        if(ovrlap .le. 0.) then
          ft(1) = 0.
          ft(2) = 0.
          ft(3) = 0.
          Tstar = 0.
          dslip = 0.
          cosft(1) = 0.
          cosft(2) = 0.
          cosft(3) = 0.
          ftmavg = 0.
          ft2 = 0.
        else
          ovrold = ovrlap + dxreln
          if(ovrold .gt. 0.) then
            a_o = sqrt(ovrold * R / 2.d0)
            fn_o = Ebar * a_o**3 / R
            ft_o(1) = ft_old(1)
            ft_o(2) = ft_old(2)
            ft_o(3) = ft_old(3)
          else
            ovrold = 0.
            a_o = 0.
            fn_o = 0.
            ft_o(1) = 0.
            ft_o(2) = 0.
            ft_o(3) = 0.
          endif
c
          drtouch = rtouch / n
          ddxrln = drtouch * dxreln
c
          ddxrlt(1) = drtouch * dxrelt(1)
          ddxrlt(2) = drtouch * dxrelt(2)
          ddxrlt(3) = drtouch * dxrelt(3)
c
          ovr_i = ovrold
c
          ftmago = 0
          ftmago = ft_o(1)**2 + ft_o(2)**2 + ft_o(3)**2
          ftmago = sqrt(ftmago)
c
          do 10 i = 1,n
c
            if(i.lt.n) then
              ovr_i = ovr_i - ddxrln
              a_i = sqrt(ovr_i * R / 2.d0)
              fn_i = Ebar * a_i**3 / R
            else
              a_i = a
              fn_i = fn
            endif
            dfn = fn_i - fn_o
c
            if(ftmago .gt. 0.) then
              yieldn(1) = ft_o(1) / ftmago
              yieldn(2) = ft_o(2) / ftmago
              yieldn(3) = ft_o(3) / ftmago
              ddxtn = ddxrlt(1)*yieldn(1) + ddxrlt(2)*yieldn(2)
     x              + ddxrlt(3)*yieldn(3)
            else
              ddxrltm = sqrt(ddxrlt(1)**2 + ddxrlt(2)**2 
     x                       + ddxrlt(3)**2)
              if(ddxrltm .gt. 0.) then
                yieldn(1) = ddxrlt(1) / ddxrltm
                yieldn(2) = ddxrlt(2) / ddxrltm
                yieldn(3) = ddxrlt(3) / ddxrltm
                ddxtn = ddxrltm
              else
                yieldn(1) = 1.d0
                yieldn(2) = 0.
                yieldn(3) = 0.
                ddxtn = 0.
              endif
            endif
c
            Ho = Gbar * (a_o + a_i)/2.d0
c
            if(i.eq.1) then
              Ho_1 = Ho
              ftmag1 = ftmago
            endif
c
            if(l3d) then
              ddxtt(1) = ddxrlt(1) - yieldn(1)*ddxtn
              ddxtt(2) = ddxrlt(2) - yieldn(2)*ddxtn
              ddxtt(3) = ddxrlt(3) - yieldn(3)*ddxtn
c
              ftrel = ftmago / frict / ((fn_o + fn_i)/2.d0)
              if(ftrel .gt. 1.d-10) then
                H_p = (2.d0/3.d0) * Ho * ftrel
     x                / (1.d0
     x                   - max(0.,(1.d0 - ftrel))**third2)
c    x                            - (ftmago / frict 
c    x                               / (fn_o + fn_i)/2.d0)))**third2)
              elseif(ftmago .gt. 0.) then
                H_p = Ho
              else
                H_p = 0.
              endif
c
              dftt(1) = H_p * ddxtt(1)
              dftt(2) = H_p * ddxtt(2)
              dftt(3) = H_p * ddxtt(3)
            endif
c
            theta1 = max(0., (1.d0 - ftrel))**third
c    x                   (1.d0 
c    x                    - ftmago 
c    x                      / (frict*(fn_o + fn_i)/2.d0)))**third
            Tstar1 = Tstar + frict*(1.d0 - theta1)*dfn
c
            if((ftmago + Ho*ddxtn) .gt. Tstar1) then
              Tn = ftmago + frict*dfn*(1.d0 - theta1) 
     x                    + Ho*theta1*ddxtn
            else
              H = Ho * max(0.,(1.d0
     x                        - abs(Tstar - ftmago)
     x                          /(frict*(fn_o+fn_i))))**third
              Tn = ftmago + frict*dfn*(1.d0 - H/Ho) + H*ddxtn
            endif
c
            if(l3d) then
              ft_i(1) = ft_o(1) + dftt(1) + (Tn - ftmago)*yieldn(1)
              ft_i(2) = ft_o(2) + dftt(2) + (Tn - ftmago)*yieldn(2)
              ft_i(3) = ft_o(3) + dftt(3) + (Tn - ftmago)*yieldn(3)
            else
              ft_i(1) = ft_o(1) + (Tn - ftmago)*yieldn(1)
              ft_i(2) = ft_o(2) + (Tn - ftmago)*yieldn(2)
              ft_i(3) = 0.
            endif
c
            ftmag = 0
            ftmag = ft_i(1)**2 + ft_i(2)**2 + ft_i(3)**2
            ftmag = sqrt(ftmag)
c
            ftmax = frict*fn_i
            if(ftmag .gt. ftmax) then
              reduc = ftmax / ftmag
              ft_i(1) = reduc * ft_i(1)
              ft_i(2) = reduc * ft_i(2)
              ft_i(3) = reduc * ft_i(3)
              ftmag = ftmax
            endif
c
c           Tstar = max(ftmag, Tstar+frict*dfn)
            Tstar = max(ftmag, Tstar1)
            Tstar = min(Tstar, frict*fn_i)
c
            a_o = a_i
            fn_o = fn_i
            ft_o(1) = ft_i(1)
            ft_o(2) = ft_i(2)
            ft_o(3) = ft_i(3)
            ftmago = ftmag
   10     continue
c
          ft(1) = ft_i(1)
          ft(2) = ft_i(2)
          ft(3) = ft_i(3)
c
c---------the average elastic stiffness of the contact
          Ho_avg = (Ho_1 + Ho) / 2.d0
c
c---------the amount of frictional slipping at this contact
          dslip = sqrt(
     x               (dxrelt(1) -  (ft(1) - ft_old(1))/Ho_avg)**2
     x             + (dxrelt(2) -  (ft(2) - ft_old(2))/Ho_avg)**2
     x             + (dxrelt(3) -  (ft(3) - ft_old(3))/Ho_avg)**2)
c
c---------squared magnitude of the tangential contact force
          ft2 = ftmag**2
c
c---------magnitude of tangential contact force mid-way within a time step
          ftmavg = (ftmag1 + ftmag) / 2.d0
c
c---------direction of the tangential force
          if(ftmag.gt.0.) then
            cosft(1) = ft_i(1) / ftmag
            cosft(2) = ft_i(2) / ftmag
            cosft(3) = ft_i(3) / ftmag
          else
            cosft(1) = 0.
            cosft(2) = 0.
            cosft(3) = 0.
          endif
c
c---------with contact damping
          if(lcdamp) then
            fttot(1) = ft(1) + dampc2*ddxrlt(1)
            fttot(2) = ft(2) + dampc2*ddxrlt(2)
            fttot(3) = ft(3) + dampc2*ddxrlt(3)
          else
            fttot(1) = ft(1)
            fttot(2) = ft(2)
            fttot(3) = ft(3)
          endif
        endif
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
c
      subroutine Jager3D(rad_i, rad_j, zeta, 
     x                   d_xi, Ft_old,
     x                   Ebar, A_1, palpha, Cn, kappa, 
     x                   f, f2, fk2,
     x                   lJsphr, lJcone, lJgen,
     x                   Fn, Ft,
     x                   ipt5, nlist2, nlistJ,
     x                   rve)
c
c This subroutin computes the contact force that between two spherical
c surfaces that results from contact movements.  It is based upon Hertz 
c and Mindlin-Deresiewicz theory, as generalized by J. Jager:
c
c [1] J. Jager, New Solutions in Contact Mechanics, WIT Press, 
c     Southampton, UK, 2005.
c
c In particular, Chapters 4 and 7 in the above book (see pp. 128 & 129).
c
c The following article gives a 2D version of the algorithm with some excellent
c examples:
c
c [2] J. Jager, "Uniaxial deformation of a random packing of particles,"
c     Archive of Applied Mechanics, 1999, Vol 69, 181-203.
c
c The entire algorithm is presented in a form that is suitable for DEM
c simulations in the following article:
c
c [3] M. R. Kuhn, Implementation of the Jager contact model for discrete
c     element simulations, International Journal for Numerical Methods in
c     Engineering, 2011, Vol. 88, No. 1, pp. 66-82.
c
c Some variations of the algorithm
c [4] M. R. Kuhn, H. E. Renken, A. Mixsell, and S. Kramer, "Investigation of
c     cyclic liquefaction with discrete element simulations," Journal of
c     Geotechnical and Geoenvironmental Engineering, 2015, 140(12), 04014075.
c [5] M. R. Kuhn, 
c
c Also,
c  R.D. Mindlin and H. Deresiewicz, "Elastic spheres in contact under 
c  varying oblique forces," Journal of Applied Mechanics, 1953, 
c  Vol. 75, 327-344.
c
c  Seridi, A. and Dobry, R. (1984), "An Incremental Elastic-Plastic Model 
c  for the Force-Displacement Relation at the Contact Between Two Spheres,"
c  Research Report, Dept. of Civil Engineering, Rensselaer Polytechnic 
c  Institute, Troy, N.Y.
c
c  R. Dobry, T.-T. Ng, and E. Petrakis, "General model for contact law
c  between two rough spheres," Journal of Engineering Mechanics, 1991,
c  Vol. 117, 1365-1381.
c
c Input:
c    rad_i,rad_j    radii of curvatures of the two particles
c    zeta           the indentation (half the overlap) of the two particles
c    d_xi           increments of the tangential indentation
c                   (in Jager's 1999 paper Delta_xi_k and Delta_zeta_k, but
c                   half of these values in the 2005 book).
c                   d_xi is a 2-vector.
c    Ftold          previous tangential forces.  Ftold is a 2-vector.
c    Ebar           elastic constant = (8.d0/3.d0) * (G/(1.d0-nu)) for finding
c                   the normal contact force
c    A_1            the slope A_1 of the cone.  Usually, 0 < A_1 << 1.
c                   This is the slope that the cone's surface makes with a 
c                   plane that is perpendicular to the cone's central axis.
c    kappa          Jager's ratio normal and tangential stiffness 
c                   = (2-nu) / (2*(1-nu))
c    f              contact friction coefficient
c    f2             square of contact friction coefficient: f^2
c    fk2            (f * kappa)^2
c    lJsphr         logical variable, whether the contacting surfaces are
c                   spherical
c    lJcone         logical variable, whether the contacting surfaces are
c                   conical
c    ipt5           pointer to the current place along the effective load path.
c                   Within the list "listk", listk(ipt5) points to a location
c                   within the linked list listJ of load path information
c    nlist2         size of arrays for load path information: zeta_s, etc.
c    nlistJ         size of arrays for load path information: zeta_s, etc.
c
c Output:
c    Fn             normal contact force (compression positive)
c    Ft             tangential contact force vector.  A 2-vector.
c
c Both input and output.  The following data defines the equivalent load
c history.  Held in the fortran "common" block named "Jager"
c    zeta_s()       list of indentations along the effective load path
c                   (Jager's zeta_star).  This list contains the historical
c                   values.  One purpose of the subroutin is to compute the
c                   current value.  Note that "zeta" represents an
c                   indentation (as in Jager's 1999 article), rather than
c                   an overlap (as in Jager's 2005 book).
c    Fn_s()         list of normal forces along the effective load path
c                   (Jager's Fn(zeta_star_k) in the 1999 paper)
c    p_s()          list of slopes along the effective load path
c                   (Jager's tan_beta_k in the 1999 paper, or "p" in the book).
c                   A list of 2-vectors.
c    listk()        array of pointers to the locations within the link-list,
c                   listJ, for the load path information of individual contacts
c
      include 'param-dempla-0.2.2.f'
c
c     implicit double precision(a-h,o-z)
c
      double precision A_1, Cn, de_p, de_prime, de_prime2, d_Ft, 
     x                 d_xi, d_xi_mag, d_xi_mag2, 
     x                 d_zeta,
     x                 dzeta2, dzeta3, 
     x                 Ebar,
     x                 f, fk2, f2, 
     x                 Fn, Fn_o, Fn_old, Fn_s, Fn_sk, Fn_s0, Fn_s1,
     x                 Ft, Ft_old, Ft_s,
     x                 kappa, offset, offset2, 
     x                 p, p2, p_s, p_s0, p_s1, p_s2, palpha, pi, pmag,
     x                 R, RJag, rad_i, rad_j, radius2, 
     x                 tol, tol_f, 
     x                 zeta, zeta_o, zeta_old,
     x                 zeta_s, zeta_s0, zeta_s1, zeta_sk
      integer*4 i, i_minus_1,
     x          ipt5,
     x          listJ, listk,
     x          nlist2, nlistJ, nremov
      integer*2 iremov,islip2, rve
      logical lDone, lElast,
     x        lJcone, lJsphr, lJgen, lFn_s
c
      dimension de_prime(2), d_Ft(2), d_xi(2),
     x          Ft(2), Ft_old(2),
     x          offset(2), p(2)
c
c     parameter (Zero=0, mp=129000, mlistJ=1*mp, mlist2=20*mp/2)
c     parameter (Zero=0,mp=10648, mlistJ=200*mp, mlist2=20*mp/2,mrve=4)
c     parameter (Zero=0, mp=10648, mlistJ=800*mp, mlist2=20*mp/2)
c     parameter (Zero=0, mp=10648, mlistJ=8000*mp, mlist2=20*mp/2)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----capture the values of the parameters "mlist2" and "mlistJ" so 
c     that we can later check whether they match the values in the 
c     file param-dempla-0.2.2.f
      nlist2 = mlist2
      nlistJ = mlistJ
c
c-----numerical constants
      pi = 3.14159265358979323846d0
c
c-----contrary to the paper, all modifications of the linked lists
c     will be done outside (not inside) of this subroutin.  This change
c     will facilitate parallelization of the code
c
c-----the number of elements removed from the linked list (as on lines
c     52 and 78)
      nremov = 0
c
c-----"i" represents the current (most recent) leg of the equivalent load
c     path.  It actually points to an appropriate starting location within
c     the link-list "listJ".  Retrieve this location for the particular
c     contact "ipt5".
      i = listk(ipt5,rve)
c
c-----small tolerances, described near the end of Section 2 of paper [3]
      tol = 1.0d-12
c     tol_z = tol*max(max(zeta,zeta_s(i)), 1.0d-8)
c     tol_z = tol*max(zeta,zeta_s(i))
c     tol_z2 = tol_z**2
c
c-----initialize islip, which will later take on this meaning:
c     islip=0 elastic;  islip=1 full slip;  islip=2 micro-slip (Jager)
      islip2(ipt5,rve) = 0
c
c-----change the names of Fnold and Ftold so that new values do not get
c     passed back to the calling unit (as would otherwise happen for 
c     f77 Fortran)
c     Fn_old = Fnold
c     Ft_old = Ftold
c
c-----the original tangential force, which will be used to compute the
c     change in elastic energy of the contact.  Because Ft_old, Fn_old,
c     and zeta_old can be changed by the algorithm, we should save them now.
c     We save the previous forces as Ft_s and Fn_o.
c     Ft_s(ipt5,1,1) = Ft_old(1)
c     Ft_s(ipt5,1,2) = Ft_old(2)
c     Fn_o(ipt5) = Fn_s(i)
c     zeta_o(ipt5) = zeta_s(i)
c
c-----"zeta" is the (input) value of the new indentation (half of the particle
c     overlap).  In Jager's 1999 paper [2], this is referred to as "zeta_k".
c     In Jager's book, it is referred to as half of "zeta_i":
c     zeta = overlap / 2.d0
c
      if(zeta .le. 0.) then
c-------The particles are not touching.  No contact force.
c       Line 4 and 5, Fig. 2 of [3]
        Fn = 0.
        Ft(1) = 0.
        Ft(2) = 0.
c
c-------Flush the three lists of load-path data for this contact: zeta_s(), 
c       Fn_s(), tan_b().  Then set i=0.
c-------Line 6, Fig. 2 of [3], also Fig. 7.
c-------set a flag for flushing the list within subroutin forces
        iremov(ipt5,rve) = -1
c
c-----Line 7, Fig. 2 of [3]
      else
c-------The particles are touching.  Compute the tangential contact force.
c
c       Line 8, Fig. 2 of [3]
c
c-------the Hertz normal contact force. This force will depend upon the
c       contact contour
        if(lJsphr) then
c---------as an effective (average) radius, we use the Johnson approach,
c         but instead of Johnson's R_star (R*), we use twice this value
          R = 2.d0 * (rad_i*rad_j) / (rad_i + rad_j)
c---------store this value for using later in subroutin "Jager3D_etc" to
c         compute the elastic energy of the tangential force
          RJag(ipt5,rve) = R
c
c---------for spherical asperities. Line 13, Fig. 2 of [3]
          Fn = Ebar * (sqrt(zeta * R))**3 / R
        elseif(lJcone) then
c---------for cone asperities (see [4])
          Fn = (3.d0 / 2.d0 / pi) * Ebar * zeta**2 / A_1
        elseif(lJgen) then
c---------for general (power law) asperities (see [4])
          Fn = Cn * zeta**(1.d0 + 1.d0/palpha)
        endif
c
c-------The previous normal force, which is stored at the top of the stack 
c       of the equivalent load history.  Lines 11 and 21, Fig. 2 of [3]
c       Fn_old = Fn_s(i);
        Fn_old = Fn_s(i,rve)
c
c-------the increment of normal indentation.  The difference between the 
c       current and previous indentations.  The previous value is stored 
c       at the top of the stack of the equivalent load history.
c       Line 9, Fig. 2 of [3]
        d_zeta = zeta - zeta_s(i,rve)
        zeta_old = zeta_s(i,rve)
c
c       Line 10, Fig. 2 of [3]
        if(      abs(d_zeta) .le. 0.
     x     .and. abs(d_xi(1)) .le. 0.
     x     .and. abs(d_xi(2)) .le. 0.) then
c---------No movement at the contact, neither normal movement nor tangential
c         movement.  Therefore, no change in the contact force.
          Fn = Fn_old
          Ft(1) = Ft_old(1)
          Ft(2) = Ft_old(2)
        else
c---------we have some contact movement.  Compute the tangential contact force
c         using Jager's method
c
c---------the squared magnitude of the tangential displacement
          d_xi_mag2 = d_xi(1)**2 + d_xi(2)**2
c
c---------the squared friction coefficient
c         f2 = f**2
c
c---------a tolerance for increments of contact force
          tol_f = tol * max(Fn, Fn_old)
c
c---------check wether the displacement increment is elastic. See top of 
c         page 187 in Jager's 1999 paper, or Eq. 7.26a in Jager's 2005 book.
c
c---------the following "if" requires that the second condition is NOT 
c         evaluated when the first condition is false.  This approach is 
c         used with most Fortran compilers or can be specified as an 
c         option when starting the compiler.  With Matlab and Octave, 
c         this is accomplished with the double "&&" operator
c
          if(d_zeta .gt. 0.
     x       .and. ((d_xi_mag2 / d_zeta**2) .lt. fk2)) then
c-----------the tangential displacement is elastic.  This corresponds to
c           Case 1 on page 187 of Jager's 1999 paper ([2] i.e., proceed with 
c           Eq. 19).  In Jager's 2005 book, this corresponds to the first 
c           case in Eq. 7.26b.
c
c           Line 17, Fig. 2 of [3]
            if(d_xi_mag2 .gt. 0.) then
c-------------the loading direction in zeta-xi space
              p(1) = d_xi(1) / d_zeta / kappa
              p(2) = d_xi(2) / d_zeta / kappa
            else
c-------------the tangential displacement is so small, we have zero change 
c             in tangential force.
              p(1) = 0.
              p(2) = 0.
            endif
c
c-----------the increment of tangential force, relative to the previous 
c           point on the equivalent loading path. Line 18, Fig. 2 of [3]
            d_Ft(1) = (Fn - Fn_s(i,rve)) * p(1)
            d_Ft(2) = (Fn - Fn_s(i,rve)) * p(2)
c
c-----------identify this leg of the equivalent loading path as elastic, for
c           possible approximation later
            lElast = .true.
          else
c-----------the displacement is inelastic and some slip will occur within a 
c           contact annulus
            lElast = .false.
c
c-----------either micro-slip or full slip (Jager)
            islip2(ipt5,rve) = 2
c
c-----------we loop here to establish the equivalent loading path, 
c           eliminating (when appropriate) past branches of the path. 
c           We use a do--until loop, which is permitted in Fortran and
c           Octave, although it is not allowed in standard Matlab.
c
   30       continue
c-------------until lDone
c
c-------------Line 23, Fig. 3 of [3]
              if(i .gt. Zero) then
                i_minus_1 = listJ(i,rve)
              endif
c
c-------------note that dT/dN > f, so the slope "p" has will eventually 
c             be set equal to the friction coefficient "f", as in 
c             Eq. 7.27d of Jager's book [1].
c
c-------------find "delta e prime" as in Eq. 7.27d [1].  Here, zeta_s means
c             "zeta star" in Jager's notation.  Note that this
c             indentation increment ends at the current indentation (zeta)
c             and begins at the previous zeta_s ("zeta star") value along the
c             equivalent load path, rather than at the previous indentation.
c
c             Line 24, Fig. 3 of [3]
              de_prime(1) = d_xi(1)/kappa
     x                      - p_s(i,1,rve)*(zeta - zeta_s(i,rve))
              de_prime(2) = d_xi(2)/kappa
     x                      - p_s(i,2,rve)*(zeta - zeta_s(i,rve))
c
c-------------the squared magnitude of de_prime
              de_prime2 = de_prime(1)**2 + de_prime(2)**2
c
c-------------under some circumstances, Fn_s will have been previosuly 
c             computed, an there will be no need to recompute.  Assume 
c             this is not the case.
              lFn_s = .false.
c
cccf          if(de_prime2 .lt. tol_z2) then
c-------------Line 26, Fig. 3 of [3]
              if(de_prime2 .le. 0.) then
c---------------a minimal amount of tangential movement.  Avoid division by 
c               zero in subsequent calculations.
c               Line 26, Fig. 3 of [3]
                zeta_sk = zeta
              else
c
c---------------the squared magnitude of Jager's "p_i_minus_1"
                p_s2 = p_s(i,1,rve)**2 + p_s(i,2,rve)**2
c
c---------------Line 28, Fig. 3 of [3]
                if(abs(f2 - p_s2).lt.tol) then
CCCG            if(abs(f2 - p_s2).le.0.) then
c-----------------Both the current and previous displacement increments were
c                 inelastic (on a yield cone).
c
c-----------------we now check the current load increment (which we 
c                 already know will cause yielding) to determine whether it
c                 will produce inelastic loading or inelastic unloading
c                 Line 29, Fig. 3 of [3]
                  dzeta2 = zeta_s(i,rve) - zeta_s(i_minus_1,rve)
                  offset(1) = d_xi(1)/kappa + p_s(i,1,rve)*dzeta2
                  offset(2) = d_xi(2)/kappa + p_s(i,2,rve)*dzeta2
c
c-----------------squared radius of the load increment (relative at the current
c                 indentation, zeta), relative to the yield cone axis
                  offset2 = offset(1)**2 + offset(2)**2
c
c-----------------squared radius of the yield cone at the current 
c                 indentation zeta
                  dzeta3 = zeta - zeta_s(i_minus_1,rve)
                  radius2 = (f*dzeta3)**2
c
                  if(offset2 .gt. radius2) then
c-------------------the tangential movement produces further inelastic 
c                   loading and will expand the previous yield cone.  
c                   Although Jager's Eq. 2.27b [1] will apply (in principle), 
c                   it will involve a division by zero (since f2 - p_s2 = 0).
c                   Circumvent this problem by placing zeta_sk at the apex 
c                   of the cone.  
c                   Line 31, Fig. 3 of [3]
                    zeta_sk = zeta_s(i_minus_1,rve)
c
c-------------------no need to compute Fn_s later
                    lFn_s = .true.
c
                  else
c-------------------the tangential movement will produce inelastic unloading,
c                   creating a new (unloading) yield cone within the previous 
c                   (loading) yield cone.
c
c                   Line 34, Fig. 3 of [3]
c
c-------------------the dot product of de_prime and "p_i_minus_1"
                    de_p = de_prime(1)*p_s(i,1,rve)
     x                     + de_prime(2)*p_s(i,2,rve)
c
c-------------------apply Eq. 7.27b in Jager's book.  The following form of 
c                   the equation applies when f^2 = p^2 and de*p is negative
                    zeta_sk = zeta + 0.5d0 * de_prime2 / de_p
                  endif
                else
c-----------------apply Eq. 7.27b in Jager's book [1]
c
c-----------------the dot product of de_prime and "p_i_minus_1"
                  de_p = de_prime(1)*p_s(i,1,rve)
     x                   + de_prime(2)*p_s(i,2,rve)
c
c-----------------Eq. 2.27b of [3], Line 37, Fig. 3 of [3]
                  zeta_sk = zeta
     x                      - 1.d0 / (sqrt(  (de_p / de_prime2)**2
     x                                     + (f2 - p_s2) / de_prime2 )
     x                                - de_p / de_prime2)
                endif
              endif
c
c-------------find the normal force Fn_sk that corresponds to indentation 
c             zeta_sk.  Note that the particle indentation zeta is half 
c             the overlap
ccch          if(zeta_sk .ge. tol_z) then
              if(zeta_sk .ge. 0.) then
c---------------slip occurs within an annular area
c               Line 40, Fig. 3 of [3]
c
                if(lFn_s) then
c-----------------use previously computed value
                  Fn_sk = Fn_s(i_minus_1,rve)
                else
c-----------------compute fresh value of Fn_sk (Fn star)
                  if(lJsphr) then
                    Fn_sk = Ebar * (sqrt(zeta_sk * R))**3 / R
                  elseif(lJcone) then
                    Fn_sk = (3.d0 / 2.d0 / pi) * Ebar * zeta_sk**2
     x                      / A_1
                  elseif(lJgen) then
                    Fn_sk = Cn * zeta_sk**(1.d0 + 1.d0/palpha)
                  endif
                endif
              else
c---------------the apex of the yield cone is very nearly at 
c               zero (indentation), or the apex is at a negative
c               (indentation).  Assign a large negative value to 
c               Fn_sk, so that the equivalent loading path will be 
c               reset in subsequent code.  Line 43, Fig. 3 of [3]
                Fn_sk = -1.d0 / tol_f
              endif
c
              lDone = .true.
ccci???       if(zeta_sk .lt. zeta_s(i)-tol_z) then
              if(zeta_sk .lt. zeta_s(i,rve)) then
c---------------we must eliminate a leg of the equivalent loading path, 
c               as in Case 3, page 187 of Jager's 1999 article [2]
c
c---------------Case 3, page 187 [2]
                if(i .gt. Zero) then
c-----------------we have more than one leg of the equivalent loading path.  
c                 This would be false, for example, if the the contact is 
c                 new and the initial movement produces sliding, or if full
c                 slip has been developed at the siding (in which case, 
c                 i would equal 1)
c
c                 Line 47, Fig. 3 of [3]
c
                  zeta_old = max(zeta_sk, zeta_s(i_minus_1,rve))
                  Fn_old = max(Fn_sk, Fn_s(i_minus_1,rve))
                  Ft_old(1) = Ft_old(1)
     x                        - p_s(i,1,rve)*(Fn_s(i,rve) - Fn_old)
                  Ft_old(2) = Ft_old(2)
     x                        - p_s(i,2,rve)*(Fn_s(i,rve) - Fn_old)
                  d_xi(1) = d_xi(1) 
     x                      + p_s(i,1,rve)*kappa
     x                        *(zeta_s(i,rve) - zeta_old)
                  d_xi(2) = d_xi(2) 
     x                      + p_s(i,2,rve)*kappa
     x                        *(zeta_s(i,rve) - zeta_old)
c
cccj              if(Fn_sk .le. Fn_s(i_minus_1)+tol_f) then
                  if(Fn_sk .le. Fn_s(i_minus_1,rve)) then
c-------------------eliminate one leg of the equivalent loading path,
c                   Line 50, Fig. 3 of [3]
c
c-------------------now, remove that leg, by setting values in the linked
c                   list to zero (line 52, and Fig. 7)
c
c-------------------rather than removing the leg here, we will remove it
c                   within subroutin forces
c
c-------------------modify the linked list (Fig. 7)
c-------------------we will eliminate the leg outside of this subroutin
c                   (and within subroutin forces)
                    nremov = nremov + 1
c
c-------------------point the head of the list to the next rve in the list
                    i = listJ(i,rve)
c
c-------------------continue through the "until" loop again to determine 
c                   whether another leg of the load path must be removed
                    lDone = .false.
                  else
c-------------------slide back the previous rve on the equivalent load path
c                   (for example, point 3 to point 2a in Fig. 4b)
c
c-------------------now, slide back that rve, as on Line 55 of [3]
c-------------------do not do this within this subroutin
c-------------------perform this step within subroutin forces
                    Fn_s1(ipt5,rve) = Fn_sk
                    zeta_s1(ipt5,rve) = zeta_sk
                    p_s1(ipt5, 1,rve) = p_s(i,1,rve)
                    p_s1(ipt5, 2,rve) = p_s(i,2,rve)
                  endif
                endif
              else
                zeta_old = zeta_sk
              endif
            if(.not.lDone) goto 30
c
            iremov(ipt5,rve) = nremov
c
            if(i.eq.Zero) then
c-------------full slip has developed at the contact
              Fn_sk = 0.
              Fn_old = 0.
              Ft_old(1) = 0.
              Ft_old(2) = 0.
c
c-------------full slip
              islip2(ipt5,rve) = 1
c
c-------------the tangential contact force will be aligned with the tangential
c             contact movement
              d_xi_mag = sqrt(d_xi(1)**2 + d_xi(2)**2)
              p(1) = f * d_xi(1) / d_xi_mag
              p(2) = f * d_xi(2) / d_xi_mag
            else
              if(abs(zeta - zeta_sk).gt.0.) then
c---------------use Eq. 7.26b of Jager's book to calculate the slope "p sub i"
                p(1) = (d_xi(1)/kappa
     x                 + p_s(i,1,rve)*(zeta_old - zeta_sk))
     x                   / (zeta - zeta_sk)
                p(2) = (d_xi(2)/kappa
     x                 + p_s(i,2,rve)*(zeta_old - zeta_sk))
     x                   / (zeta - zeta_sk)
              else
c---------------a variation from
                p(1) = f * d_xi(1)/sqrt(d_xi(1)**2 + d_xi(2)**2)
                p(2) = f * d_xi(2)/sqrt(d_xi(1)**2 + d_xi(2)**2)
              endif
            endif
c
            p2 = p(1)**2 + p(2)**2
c           if(p2.gt.(f2+tol)) then
              pmag = sqrt(p2)
              p(1) = p(1) * f / pmag
              p(2) = p(2) * f / pmag
c           endif
c
c-----------Eq. 7.25b of Jager's book [1] and Case 2, page 187 of the 1999 
c           paper [2].  Line 67, Fig. 2 of [3]
            d_Ft(1) = p(1)*(Fn - Fn_sk) - p_s(i,1,rve)*(Fn_old - Fn_sk)
            d_Ft(2) = p(2)*(Fn - Fn_sk) - p_s(i,2,rve)*(Fn_old - Fn_sk)
          endif
c
c---------add increment of tangent force. Line 69, Fig. 2 of [3]
          Ft(1) = Ft_old(1) + d_Ft(1)
          Ft(2) = Ft_old(2) + d_Ft(2)
c
c---------add this leg to the equivalent loading path. Lines 70 and
c         71, Fig. 2 of [3]
c
c---------the leg will be added outside of this subroutin to
c         enable parallelization
c
c---------add the final condition to the linked list, Line 71, Fig. 2 of [3]
c
c---------now, add that final condition, Line 71, Fig. 2 of [3]
c
c---------we will add the final condition outside of this subroutin (and
c         in subroutin forces) to enable parallelization
          zeta_s0(ipt5,rve) = zeta
          Fn_s0(ipt5,rve) = Fn
          p_s0(ipt5,1,rve) = p(1)
          p_s0(ipt5,2,rve) = p(2)
c
        endif
      endif
c
c-----save the final tangential force, so that it can be used for
c     computing the tangential elastic energy
c     Ft_s(ipt5,2,1) = Ft(1)
c     Ft_s(ipt5,2,2) = Ft(1)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
c
      subroutine Jager3D_etc(Ebar, A_1, palpha, Cn, kappa,
     x                       f2, pdif2,
     x                       lJsphr, lJcone, lJgen,
     x                       dpnrg2, lApprox, lJagEl, ltogl,
     x                       rve)
c
      include 'param-dempla-0.2.2.f'
c
c     implicit double precision(a-h,o-z)
c
      double precision A_1, Cn,
     x                 d_Xi_el,
     x                 dFn, dpnrg2, dpnrg2a,
     x                 Ebar,
     x                 f2,
     x                 Fn_o, Fn_s, Fn_s0, Fn_s1,
     x                 Ft_s,
     x                 kappa,
     x                 p_s, p_s0, p_s1, palpha, pdif2, pi,
     x                 RJag, Slope,
     x                 tol, tol_f, tol_f2,
     x                 zeta_av, zeta_o, zeta_s, zeta_s0, zeta_s1
      integer*4 i, i4, i_minus_1, i_minus_2, 
     x          listJ, listk
      integer*2 iremov,islip2, rve
      logical lApprox, lJagEl, ltogl,
     x        lJcone, lJsphr, lJgen
c
      dimension d_Xi_el(2)
c
c     parameter (Zero=0, mp=10648, mlistJ=1*mp, mlist2=20*mp/2)
c     parameter (Zero=0,mp=10648, mlistJ=200*mp, mlist2=20*mp/2,mrve=4)
c     parameter (Zero=0, mp=10648, mlistJ=800*mp, mlist2=20*mp/2)
c     parameter (Zero=0, mp=10648, mlistJ=8000*mp, mlist2=20*mp/2)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----This subroutin finishes what had begun in subroutin Jager_3D.
c     It performs two tasks, both of which are optional
c      1) when lApprox=.true, it approximates the Jager equivalent 
c         load path by removing legs of the path that are closely 
c         aligned.  This process is described in Section 3.1 of 
c         paper [3] and in Fig. 6
c      2) when lJagEl=.true, it estimates the tangential elastic 
c         energy stored in the contacts
c
c-----see the preface of subroutin Jager3D for a description of the
c     variables used in this subroutin
c
c    INPUT
c    pdif2          when lApprox=true, give the maximum squared difference 
c                   of two neighboring slopes along the effective load path.
c                   When the difference is less than pdif2, the slopes 
c                   (legs) are combined
c    lApprox        logical variable, whether to approximate the elastic
c                   legs of the equivalent load history
c    lJagEl         logical variable, whether to compute the tangential
c                   elastic energy at the contacts
c    Ebar           elastic constant = (8.d0/3.d0) * (G/(1.d0-nu)) for finding
c                   the normal contact force
c    A_1            the slope A_1 of the cone.  Usually, 0 < A_1 << 1.
c                   This is the slope that the cone's surface makes with a 
c                   plane that is perpendicular to the cone's central axis.
c    kappa          Jager's ratio normal and tangential stiffness 
c                   = (2-nu) / (2*(1-nu))
c    f              contact friction coefficient
c    f2             square of contact friction coefficient: f^2
c    fk2            (f * kappa)^2
c    lJsphr         logical variable, whether the contacting surfaces are
c                   spherical
c    lJcone         logical variable, whether the contacting surfaces are
c                   conical
c    RJag()         average of the radii of the two particles (used with
c                   spherical contacts, lJsphr=.true.)
c    zeta_s0()      new contact values
c    zeta_s1()      
c    Fn_s0()
c    Fn_s1()
c    p_s0()
c    iremov()       number of legs to be removed from the equivalent load
c                   history
c    listk()        array of pointers to the locations within the link-list,
c                   listJ, for the load path information of individual contacts
c
c Both input and output.  The following data defines the equivalent load
c history.  Held in the fortran "common" block named "Jager"
c    zeta_s()       list of indentations along the effective load path
c                   (Jager's zeta_star).  This list contains the historical
c                   values.  One purpose of the subroutin is to compute the
c                   current value.  Note that "zeta" represents an
c                   indentation (as in Jager's 1999 article), rather than
c                   an overlap (as in Jager's 2005 book).
c    Fn_s()         list of normal forces along the effective load path
c                   (Jager's Fn(zeta_star_k) in the 1999 paper)
c    p_s()          list of slopes along the effective load path
c                   (Jager's tan_beta_k in the 1999 paper, or "p" in the book).
c                   A list of 2-vectors.
c    listk()        array of pointers to the locations within the link-list,
c                   listJ, for the load path information of individual contacts
c
c    OUTPUT
c    dpnrg2         change in elastic energy of contact due to the tangential
c                   force
c
c-----small tolerances, described near the end of Section 2 of paper [3]
      tol = 1.0d-12
c
      pi = 3.14159265358979323846d0
c
      if(lApprox .and. ltogl) then
        do 141 i4 = 1,mlist2
c---------if this contact still exists...
          if(listk(i4,rve).ne.Zero) then
c-----------head of the most recent leg of the equivalent load path
            i = listk(i4,rve)
c
c-----------optional: approximate the equivalent load path by combining 
c           neighboring legs that are both elastic and have nearly the 
c           same slope.
c
c-----------See Fig. 6 of [3]
c
c-----------the previous leg of the equivalent load path
            i_minus_1 = listJ(i,rve)
c
            tol_f = tol * Fn_s(i,rve)
            tol_f2 = tol_f**2
c
c-----------repeat (1) unless we are currently on the first leg of the
c           equivalent load path, (2) the previous leg was elastic (as 
c           determined by the squared magnitude of its slope "p", 
c           and (3) the current and previous leg have nearly the same slope,
c           as determined by the difference of the two "p" slopes.
c    x            .and.((p_s(i,1)**2 + p_s(i,2)**2)
c    x                   .lt. (f2 - tol_f2))
            do 20 while( (i_minus_1 .ne. Zero)
     x            .and.islip2(i4,rve).eq.0
     x            .and.((p_s(i_minus_1,1,rve)**2
     x                   + p_s(i_minus_1,2,rve)**2) 
     x                   .lt. (f2 - tol_f2))
     x            .and.((p_s(i_minus_1,1,rve) - p_s(i,1,rve))**2
     x                   + (p_s(i_minus_1,2,rve)
     x                      - p_s(i,2,rve))**2 .lt. pdif2))
c
c-------------pointer to the past slope
              i_minus_2 = listJ(i_minus_1,rve)
c
c-------------pointer to the linked list heading
              listJ(i,rve) = listJ(Zero,rve)
c-------------pointer to the first vacancy in the linked list
              listJ(Zero,rve) = i
c-------------pointer to the linked list for the current contact
              listk(i4,rve) = i_minus_1
c
c-------------compute the average slope of the two previous legs
              p_s(i_minus_1,1,rve) = (  p_s(i,1,rve)
     x                              * (Fn_s(i,rve)
     x                                 - Fn_s(i_minus_1,rve))
     x                            + p_s(i_minus_1,1,rve)
     x                              * (Fn_s(i_minus_1,rve)
     x                                 - Fn_s(i_minus_2,rve)))
     x                           / (Fn_s(i,rve) - Fn_s(i_minus_2,rve))
              p_s(i_minus_1,2,rve) = (  p_s(i,2,rve)
     x                              * (Fn_s(i,rve)
     x                                 - Fn_s(i_minus_1,rve))
     x                            + p_s(i_minus_1,2,rve)
     x                              * (Fn_s(i_minus_1,rve)
     x                                 - Fn_s(i_minus_2,rve)))
     x                           / (Fn_s(i,rve) - Fn_s(i_minus_2,rve))
c
c-------------replace the previous zeta* and Fn* values
              zeta_s(i_minus_1,rve) = zeta_s(i,rve)
              Fn_s(i_minus_1,rve) = Fn_s(i,rve)
c
c-------------vacate the information of this removed leg
              p_s(i,1,rve) = 0.
              p_s(i,2,rve) = 0.
              zeta_s(i,rve) = 0.
              Fn_s(i,rve) = 0.
c
c-------------the new current leg
              i = i_minus_1
c
c-------------pointer to the previous slope
              i_minus_1 = listJ(i,rve)
   20       continue
          endif
  141   continue
      endif
c
c
      if(lJagEl) then
c-------compute the change in elastic energy of the contact due to tangential
c       force and and movement.  The tangential elastic stiffness is equal
c       to the normal stiffness divided by kappa.  The Slope is a compliance.
c
        dpnrg2 = 0.
c
        do 142 i4 = 1,mlist2
c---------if this contact still exists...
          if(listk(i4,rve).ne.Zero) then
c-----------head of the most recent leg of the equivalent load path
            i = listk(i4,rve)
c
            dFn = Fn_s(i,rve) - Fn_o(i4,rve)
            if(abs(dFn) .gt.
     x         abs(10.d0*tol*(Fn_s(i,rve) + Fn_o(i4,rve)))) then
              Slope = (zeta_s(i,rve) - zeta_o(i4,rve)) / dFn
            else
              zeta_av = (zeta_s(i,rve) + zeta_o(i4,rve)) / 2.d0
c
c-------------the Hertz normal contact stiffness. This stiffness will depend upon the
c             contact contour
              if(lJsphr) then
c---------------for spherical asperities. Line 13, Fig. 2 of [3]
                Slope = 1.5d0 * Ebar * sqrt(zeta_av * RJag(i4,rve))
              elseif(lJcone) then
c---------------for cone asperities (see [4])
                Slope = 2.d0 * (3.d0 / 2.d0 / pi) * Ebar * zeta_av / A_1
              elseif(lJgen) then
c---------------for general (power law) asperities (see [4])
                Slope = Cn * (1.d0 + 1.d0/palpha) 
     x                     * zeta_av**(1.d0/palpha)
              endif
c
c-------------a compliance, not a stiffness
              if(Slope.ne.0.) then
                Slope = 1.d0 / Slope
              endif
            endif
c
c-----------elastic tangential movement
            d_Xi_el(1) = kappa * (Ft_s(i4,2,1,rve)
     x                            - Ft_s(i4,1,1,rve)) * Slope
            d_Xi_el(2) = kappa * (Ft_s(i4,2,2,rve)
     x                            - Ft_s(i4,1,2,rve)) * Slope
c
c-----------change in elastic energy.  A factr of (2 particles) * (1/2 avg)
            dpnrg2a =  d_Xi_el(1)*(Ft_s(i4,2,1,rve) +Ft_s(i4,1,1,rve))
     x               + d_Xi_el(2)*(Ft_s(i4,2,2,rve) +Ft_s(i4,1,2,rve))
c
            dpnrg2 = dpnrg2 + dpnrg2a
          endif
  142   continue
      endif
c
      return
      end
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      double precision function gamma(z)
c
c       Double Precision FORTRAN code for the gamma function
c       by Reinaldo Baretti Machn , Alfonso Baretti Huertas
c       http://www1.uprh.edu/rbaretti/GammaFunction7dic2010.htm
c
        implicit real*8(a-h,o-z)
        data ti,nstep /0.d0,20001/
c
        f(t)=t**(z-1.d0)*dexp(-t)
        tf=30.d0
        dt=(tf-ti)/dfloat(nstep)
        sum=dt**z/z -dt**(z+1.d0)/(z+1.d0)
        do 10 i=2,nstep,2
          t=ti+dt*dfloat(i)
          sum=sum+(dt/3.d0)*(f(t-dt)+ 4.d0*f(t) +f(t+dt))
  10    continue
        gamma=sum
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine findk(kshape, lcircl, loval, lelips, lspher, 
     x                 lovoid, lnobby, lbumpy)
c-------A correction to determine "kshape" from dumpin data
c
        integer*2 kshape
        logical lbumpy, lcircl, loval, lelips, lspher, lovoid, lnobby
c
        if(lcircl) then
c---------circular (2D) disks
          kshape = 1
        elseif(loval) then
c---------four-arc (2D) ovals
          kshape = 2
        elseif(lelips) then
c---------elliptical (2D) disks
          kshape = 3
        elseif(lspher) then
c---------spheres (3D)
          kshape = 4
        elseif(lovoid) then
c---------ovoid (3D) particles
          kshape = 5
        elseif(lnobby) then
c---------nobby (2D) particles
          kshape = 6
        elseif(lbumpy) then
c---------bumpy (3D) particles
          kshape = 7
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine models(rve)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve,TempUnit
        double precision C_11
c
        character*80 fmodl1
c
c-------explanation of file numbers.  For each rve, we reserve 5 file
c       numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
        TempUnit = 10 + 5*rve + 0
c
        if(istart(rve).eq.1 .or. istart(rve).eq.2) then
          if(imodel(rve).eq.0) then
c-----------this contact model is the simplest one: linear contact springs,
c           both normal and tangential, with or without friction.  No
c           need to read any special data, since it is all included in
c           the RunFile.
            continue
          elseif(imodel(rve).eq.1) then
c-----------this contact model is the one suggested by S. Joseph Antony:
c           a general piece-wise normal-force potential, for which the
c           data may have been collected from Atomic Force Microscopy (AFM)
c           experiments.
c
c-----------we must read the data: long-range inter-particle force vs. particle
c           separation.  This relationship is given for discrete separations,
c           and we will simply (linearly interpolate) between these
c           separations to find the force at other separations.
c
c-----------first we will ask for the name of the file that gives
c           the data
            print *,' Name of a force-separation data file:'
            read (*,600) fmodl1
c
c-----------open the file. . . .
            open(unit=TempUnit,file=fmodl1,status='old')
c
c-----------the data is arranged as two columns as follows:
c              Line 1:  mvers (=1) (INTEGER)
c              Line 2:  number of remaining lines (INTEGER)
c              Line 3:  separation-force data (DOUBLE DOUBLE), where
c           the first column gives a separation.  The second column gives
c           the long-range inter-particle compressive (repulsive) force 
c           at that separation.  
c           You should use dimensional units that are consistent 
c           with all other data (particle mass, and particle 
c           size).  The data is arranged in the order of the 
c           largest separation (first row) to zero separation (last row).  
c           That is, the data must be placed in the proper order.
c           The final separation should be zero, and the first force should
c           be zero (otherwise, you may experience instabilities).
c
c           Note: when the separation between two particles is negative,
c           then we use the stiffness, kn, constained in the RunFile
c
c-----------the file version (=1, at present)
            read(TempUnit,*) mvers
c
c-----------the number of separation-force lines
            read(TempUnit,*) nsepf(0)
c
c-----------limit on the number of separation-force lines
            if(nsepf(0).gt.lc2) then
              write(ScrUnit(rve),*) 'Parameter lc2 is too small.  '
              write(ScrUnit(rve),*) 'Too many separation-force lines.'
              stop
            endif
c
c-----------the separation-force data
            do 10 iline = 0,nsepf(0)-1
              read(TempUnit,*) psep(iline,0), pforce(iline,0)
   10       continue
c
            close(unit=TempUnit)
c           
          elseif(imodel(rve).eq.2) then
c-----------this contact model is a small variation of "imodel=1"
c           described above.  Unlike the previous model, imodel=2 allows
c           for a long-range force that depends upon particle size.
c
c-----------first we will ask for the name of the file that gives
c           the data
            write(*,*) ' Name of a force-separation data file:'
            read (*,600) fmodl1
c
c-----------open the file. . . .
            open(unit=TempUnit,file=fmodl1,status='old')
c
c           The input file is like that for "imodel=1", except that the
c           single file contains the separation-vs-force data for several
c           particle diameters.  The file is organized as follows:
c             Line 1:  mvers (=100) (INTEGER)
c             Line 2:  number of particle diameters (INTEGER)
c             Line 3:  1st particle diameter
c             Line 4:  number of lines for the 1st diameter (=lines_1, INTEGER)
c             Lines 5 to 5+lines_1-1: separation-force data (DOUBLE DOUBLE)
c                      for the 1st diameter
c             Line 6+lines_1: 2nd particle diameter
c             Line 6+lines_1: number of lines for the 2nd diameter
c                      (=lines_2, INTEGER)
c             Line 3+lines_1+lines_2: separation-force data (DOUBLE DOUBLE)
c                      for the 2nd diameter
c
c-----------the file version (=100, at present)
            read(TempUnit,*) mvers
c
c-----------the number of diameters
            read(TempUnit,*) ndiams(rve)
c
c-----------limit on the number of diameters
            if(ndiams(rve).gt.ldiams) then
              write(*,*) 'Parameter ldiams is too small.  '
              write(*,*) 'Too many diameters in separation-force lines.'
            endif
c
            do 20 idiam = 0,ndiams(rve)-1
              read(TempUnit,*) sepdia(idiam)
c
c-------------the number of separation-force lines
              read(TempUnit,*) nsepf(idiam)
c
c-------------limit on the number of separation-force lines
              if(nsepf(idiam).gt.lc2) then
                write(ScrUnit(rve),*) 'Parameter lc2 is too small.  '
                write(ScrUnit(rve),*)
     x            'Too many separation-force lines.'
                stop
              endif
c
c-------------the separation-force data
              do 22 iline = 0,nsepf(idiam)-1
                read(TempUnit,*) psep(iline,idiam), pforce(iline,idiam)
   22         continue
   20       continue
c
            close(unit=TempUnit)
c
          elseif(imodel(rve).eq.3 .or. imodel(rve).eq.4) then
c-----------this contact model is an inelastic and incrementally non-linear 
c           contact model suggested by S. Joseph Antony
c
c-----------first we will ask for the name of the file that gives
c           the data
            write(ScrUnit(rve),*)
     x        ' Name of a force-separation data file:'
            read (*,600) fmodl1
c
            open(unit=TempUnit,file=fmodl1,status='old')
c
c-----------the file version (=200, at present)
            read(TempUnit,*) mvers
c
c-----------the slope (stiffness) of the long-range force-separation plot.
c           Note that when 'knseph' is positive, the force is attractive.
c           Also, this slope is for force vs. separation, although the
c           slope kn for the contact force is for force vs. indentation,
c           where indentation = -0.5*separation.  That is, the slope
c           knseph would be half of kn for a continuous force behavior.
            read(TempUnit,*) knseph(rve)
c
            if(imodel(rve).eq.4) then
c-------------if the particles touch and then separate, the long-range
c             force-separation stiffness changes to knsep2.  This can be
c             set equal to "knseph" if desired
              read(TempUnit,*) knsep2(rve)
            elseif(imodel(rve).eq.3) then
              knsep2(rve) = knseph(rve)
            endif
c
c-----------The separation at which the attractive force becomes active
c           when the particle approach each other
            read(TempUnit,*) psep1(rve)
c
c-----------The separation at which the attractive force becomes inactive
c           when the particle are separated from each other
            read(TempUnit,*) psep2(rve)
            close(unit=TempUnit)
c
          elseif(imodel(rve).eq.5) then
c-----------a Hertz-Mindlin contact model, with friction.  The model is
c           based upon descriptions by Thornton and Randall (1988) and by
c           Dobry, Ng, Petrakis, and Seridi (1990).
c           When using this model, you must supply values of the shear
c           modulus (G), Poissons ratio (nu), and friction 
c           coefficient (frict).  G, nu, and frict are input in the
c           RunFile in place of kn, kratio, and frict.
            G(rve) = kn(rve)
            nu(rve) = kratio(rve)
          elseif(     imodel(rve).eq.6 .or. imodel(rve).eq.7 
     x           .or. imodel(rve).eq.8 .or. imodel(rve).eq.9) then
c-----------a general version of the Hertz-Mindlin model, with friction. The
c           model is based upon the work of Jager.  The model allows for
c           arbitrary normal and tangential motions (full 3D contact motion),
c           and allows an arbitrary number of tangential loading-unloading
c           reversal cycles with arbitrary accompanying normal motions.
c              J. Jager, New Solutions in Contact Mechanics, WIT Press, 
c              Southampton, UK, 2005.
c
c              In particular, Chapters 4 and 7 in the above book 
c              (see pp. 128 & 129).
c
c              The following article gives a 2D version of the algorithm 
c              with some excellent examples:
c
c              J. Jager, "Uniaxial deformation of a random packing of 
c              particles," Archive of Applied Mechanics, 1999, Vol 69, 181-203.
c           The model is implemented in subroutin Jager3D
c
c           With imodel=6, we use the conventional contact between two
c           spherical surfaces.
c
c           With imodel=7, we use the less conventional contact between
c           two conical surfaces (in Jager's 1999 paper, parameter
c           alpha = 1).
c
c           With imodel=9, we use Jager's ceneral contact shape, a solid
c           of revolution z = A_alpha * r ^ alpha (the variables Aalpha
c           and alpha = palpha)
c
c           When using this model, you must supply values of the shear
c           modulus (G), Poissons ratio (nu), and friction 
c           coefficient (frict).  G, nu, and frict are input in the
c           RunFile in place of kn, kratio, and frict.
            G(rve) = kn(rve)
            nu(rve) = kratio(rve)
c
c-----------You must also supply a value of an approximating parameter, in
c           order to implement and approximation, suggested by Kuhn, that
c           will reduce the strorage requirements for the Jager model.  The
c           RunFile can contain a value of "pdif" which is the minimum allowed
c           difference in slopes of two successive legs along the equivalent
c           load path.  When pdif=0, we do not apply the approximation.
c           When pdif is large (i.e. when it exceeds twice the friction
c           coefficient "frict"), then the approximation is consistently
c           applied, leading to an equivalent load path that consists of
c           a series of plastic legs.
            lApprox(rve) = pdif(rve) .gt. 0.
            pdif2(rve) = pdif(rve)**2
c
c-----------small number for determining the quaternion for the initial 
c           orientation of the contact xi-plane
            tolQ = 1.d-8
c
            if(imodel(rve).eq.7) then
c-------------for a conical profile at the contact (imodel=7), we need
c             the slope A_1 of the cone.  Usually, 0 < A_1 << 1
              A_1(rve) = A_1(rve)
              palpha(rve) = 0.
            elseif(imodel(rve).eq.9) then
c-------------for a general surface of revolution contact (imodel=9), we
c             need the coefficient A_alpha, which is previously read from
c             the RunFile as A_1
              A_1(rve) = A_1(rve)
              palpha(rve) = palpha(rve)
            elseif(imodel(rve).eq.6 .or. imodel(rve).eq.8) then
c-------------the standard spherical profile at the contact (imodel=6), 
c             as in Cattaneo-Mindlin-Deresiewicz theory.  Also includes
c             an approximate rolling model (imodel=8)
              A_1(rve) = 0.
              palpha(rve) = 0.
            endif
c
            if(imodel(rve).eq.8) then
c-------------With a Jager contact and an approximation of Kalker rolling,
c             interpolate Kalker's C_11 data for the particular Poisson
c             ratio of this simulation.  Lagrange quadratic interpolation
              C_11 =   
     x            3.40d0 * (nu(rve)-0.25d0) * (nu(rve)-0.50d0)
     x                   / (0.00d0-0.25d0) / (0.00d0-0.50d0)
     x          + 4.12d0 * (nu(rve)-0.00d0) * (nu(rve)-0.50d0)
     x                   / (0.25d0-0.00d0) / (0.25d0-0.50d0)
     x          + 5.20d0 * (nu(rve)-0.00d0) * (nu(rve)-0.25d0)
     x                   / (0.50d0-0.00d0) / (0.50d0-0.25d0)
c
c-------------some factors that will save some later operations
              C_11nu(rve) = 8.d0 * frict(rve)
     x                       / (C_11 * (1.d0 - nu(rve)))
            endif
          endif
        elseif(istart(rve).eq.3) then
c---------the StartFile is a "C"-type restart file
          if(imodel(rve).eq.6 .or. imodel(rve).eq.7
     x       .or. imodel(rve).eq. 8 .or. imodel(rve).eq.9) then
c-----------Jager contact
c
c-----------Even when starting with a Restart file, we can specify the
c           the value of pdif within the RunFile
            lApprox(rve) = pdifsv(rve) .gt. 0.
            pdif2(rve) = pdifsv(rve)**2
c
            if(imodel(rve).eq.6 .or. imodel(rve).eq.8) then
c-------------spherical contacting surfaces.  Set this cone parameter to zero
              A_1(rve) = 0.
              palpha(rve) = 0.
            elseif(imodel(rve).eq.7) then
              palpha(rve) = 0.
            endif
          endif
        endif
c
        return
  600   format(a80)
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model0(kn, seprat0, knmax)
        double precision kn, knmax, seprat0
c
        seprat0 = 0.
        knmax = kn
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model1(kn, pforce, psep, lc2, ldiams,
     x                       nsepf, rad, sep, 
     x                       seprat0, knmax,
     x                       ScrUnit, rve, mrve)
        integer*2 lc2, ldiams, mrve, rve, nsepf, ScrUnit
        double precision kn, knmax, kntry, pforce, psep, 
     x                   rad, sep, seprat0
c
        dimension nsepf(0:ldiams),
     x            pforce(0:lc2,0:ldiams), psep(0:lc2,0:ldiams)
        dimension ScrUnit(0:mrve)
c
c-------check that the input data is in the proper order:
        do 10 i = 0,nsepf(0)-2
          if(psep(i,0).gt.psep(i+1,0)) then
            write(ScrUnit(rve),*) 
     x        '***** force-separation data in wrong order *****'
            stop
          endif
c
c---------find the maximum stiffness
          kntry = -(pforce(i+1,0) - pforce(i,0)) / 
     x             (psep(i+1,0) - psep(i,0))
          knmax = max(knmax, kntry)
   10   continue
c
c-------note that kn is an indentation stiffness
        knmax = max(kn, 2.d0*knmax)
c
c-------seprat0 is the maximum separation at which a contact force can exist
        seprat0 = psep(nsepf(0)-1,0)
c
c-------check the input value "sep"
        sep = max(sep, (rad + 0.5d0*seprat0)*(sep/rad))
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model2(kn, pforce, psep, lc2, ldiams, mp,
     x                       ndiams, np, nsepf, 
     x                       sep, sepdia, seprat0, knmax, radsep, rad,
     x                       ScrUnit, rve, mrve)
        integer*2 lc2, ldiams, mrve, ndiams, rve, nsepf, ScrUnit
        integer*4 igrain, mp
        double precision kn, knmax, kntry, pforce, psep,
     x                   rad, radsep, sep, sepdia, seprat0
c
        dimension nsepf(0:ldiams),
     x            pforce(0:lc2,0:ldiams), psep(0:lc2,0:ldiams),
     x            rad(mp,0:mrve), sepdia(0:ldiams)
        dimension ScrUnit(0:mrve)
c
        seprat0 = -1.d0
c
c-------check that the diameters are in the proper order, from smallest
c       to largest
        do 20 idiam = 0,ndiams-2
          if(sepdia(idiam).gt.sepdia(idiam+1)) then
            write(ScrUnit(rve),*) 
     x        '***** force-separation diameters in wrong order *****'
            stop
          endif
   20   continue
c
c-------check that the range of diameters in the separation-force data
c       encompasses the range of diameters in the D-file
        do 40 igrain = 1,np
          if(2.d0*rad(igrain,rve).lt.sepdia(0) .or.
     x       2.d0*rad(igrain,rve).gt.sepdia(ndiams-1)) then
            write(ScrUnit(rve),*)
     x        '****force-separation diameter range too small*****'
            stop
          endif
   40   continue
c
        do 10 idiam = 0,ndiams-1
c---------check that the input data is in the proper order:
          do 12 i = 0,nsepf(0)-2
            if(psep(i,idiam).gt.psep(i+1,idiam)) then
              write(ScrUnit(rve),*) 
     x          '***** force-separation data in wrong order *****'
              stop
            endif
c
c-----------find the maximum stiffness
            kntry = -(pforce(i+1,idiam) - pforce(i,idiam)) /
     x               (psep(i+1,idiam) - psep(i,idiam))
            knmax = max(knmax, kntry)
   12     continue
c
c---------note that kn is an indentation stiffness
          knmax = max(kn, 2.d0*knmax)
c
c---------seprat0 is the maximum separation at which a contact force can exist
          seprat0 = max(seprat0, psep(nsepf(0)-1,idiam))
   10   continue
c
c-------check the input value "sep"
        sep = max(sep, (radsep + 0.5d0*seprat0)*(sep/radsep))
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model34(kn, knmax, knseph, knsep2,
     x                        psep2, 
     x                        rad, sep, seprat0,
     x                        ifn_togl, istart, mlist2,
     x                        rve,mrve)
        integer*2 ifn_togl, istart, mrve, rve
        integer*4 i4, mlist2
        double precision kn, knmax, knsep2, knseph, 
     x                   psep2, rad, sep, seprat0
c
        dimension ifn_togl(0:mlist2,0:mrve)
c        
        if(istart.eq.1 .or. istart.eq.2) then
          do 71 i4 = 0,mlist2
            ifn_togl(i4,rve) = 0
   71     continue
        endif
c
c-------note that kn is an indentation stiffness
        knmax = max(kn, 2.d0*knseph, 2.d0*knsep2)
c
        seprat0 = psep2
c
c-------check the input value "sep"
        sep = max(sep, (rad + 0.5d0*seprat0)*(sep/rad))
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model5(G, nu, frict, seprat0, knmax, mvers,
     x           palpha)
        integer*4 mvers
        double precision G, frict, knmax, nu, palpha, seprat0
c
        seprat0 = 0.
        knmax = 0.
        G = G
        nu = nu
        mvers = mvers
        frict = frict
        palpha = 0.
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model6(G, nu, frict, A_1, seprat0, knmax, mvers,
     x           palpha)
        integer*4 mvers
        double precision A_1, G, frict, knmax, nu, palpha, seprat0
c
        seprat0 = 0.
        knmax = 0.
        G = G
        nu = nu
        mvers = mvers
        frict = frict
        A_1 = 0.
        palpha = 0.
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model7(G, nu, frict, A_1, seprat0, knmax, mvers,
     x           palpha)
        integer*4 mvers
        double precision A_1, G, nu, frict, knmax, palpha, seprat0
c
        seprat0 = 0.
        knmax = 0.
        G = G
        nu = nu
        mvers = mvers
        frict = frict
        A_1 = A_1
        palpha = 0.
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model8(G, nu, frict, A_1, seprat0, knmax, mvers,
     x           palpha)
        integer*4 mvers
        double precision A_1, G, frict, knmax, nu, palpha, seprat0
c
        seprat0 = 0.
        knmax = 0.
        G = G
        nu = nu
        mvers = mvers
        frict = frict
        A_1 = 0.
        palpha = 0.
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model9(G, nu, frict, A_1, seprat0, knmax, mvers,
     x           palpha)
        integer*4 mvers
        double precision A_1, G, nu, frict, knmax, palpha, seprat0
c
        seprat0 = 0.
        knmax = 0.
        G = G
        nu = nu
        mvers = mvers
        frict = frict
        A_1 = A_1
        palpha = palpha
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine init_model10(lsinh, ptol, dele, temprt, n1, 
     x                        lambda, etargt)
c
        double precision ptol, dele, temprt, n1, lambda, etargt
        logical lsinh
c
        lsinh = .true.
c
c-------tolerance on calculation of sinh dashpot force
        ptol = 0.0001d0
c-------free energy of activation (J/mole) for sinh dashpot
        dele = 105.d+3
c-------temperature (Kelvin) for sinh dashpot
        temprt = 293.d0
c-------bonds/N for sinh dashpot
        n1 = 1.00d+9
c-------length scale (m) for sinh dashpo
        lambda = 2.80d-10
c-------deformation increment when igoal=2 (sinh dashpot)
        etargt = 0.40d-05
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine fn_model0(knh, ovrlap, fnfar, fnnear)
        double precision fnfar, fnnear, knh, ovrlap
c
c-------a linear (spring) contact
        fnnear = ovrlap*knh
        fnfar = 0.
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      double precision function fn_interp(ovrlap, 
     x                                    psep0, pforce0, seprat0, lc2,
     x                                    ScrUnit, rve, mrve)
c
        integer*2 i,lc2, mrve, rve, ScrUnit
        double precision ovrlap, pforce0, psep0, seprat0
c
        dimension pforce0(0:lc2), psep0(0:lc2)
        dimension ScrUnit(0:mrve)
c
        fnnear = 0.
c
c-------find the range of force-separations of the current separation
        i = 1
        do 10 while(-ovrlap.gt.psep0(i) .and. i.ne.lc2)
          i = i + 1
   10   continue
c
        if(-ovrlap.gt.seprat0 .or. i.eq.lc2) then
          write(ScrUnit(rve),*)
     x      '****** Error 1 in subroutin fn_model1 *******'
          stop
        endif
c
c-------interpolate to find the long-range force
        fn_interp = pforce0(i-1)
     x              + (-ovrlap - psep0(i-1))
     x                 * (pforce0(i) - pforce0(i-1))
     x                 / (psep0(i) - psep0(i-1))
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine fn_model1(knh, ovrlap, seprat0, pforce, psep,
     x                     lc2, ldiams, fnfar, fnnear,
     x                     ScrUnit, rve, mrve)
        integer*2 lc2, ldiams, mrve, rve, ScrUnit
        double precision fnfar, fnnear, knh, 
     x                   ovrlap, pforce, psep, seprat0
c
        dimension pforce(0:lc2,0:ldiams), psep(0:lc2,0:ldiams)
        dimension ScrUnit(0:mrve)
c
c-------the original overlap is the overlap of the two particles'
c       force fields.  We now find the actual overlap at touching
        ovrlap = ovrlap - seprat0
c
        if(ovrlap.gt.0.) then
c---------the particles are touching
c
c---------the part of the inter-particle force due to the particles touching
          fnnear = ovrlap*knh
c
c---------the long-range force
          fnfar = pforce(0,0)
        else
c
          fnnear = 0.
c
c---------find the range of force-separations of the current separation
          i = 1
          do 10 while(-ovrlap.gt.psep(i,0) .and. i.ne.lc2)
            i = i + 1
   10     continue
c
          if(-ovrlap.gt.seprat0 .or. i.eq.lc2) then
            write(ScrUnit(rve),*)
     x        '****** Error 1 in subroutin fn_model1 *******'
            stop
          endif
c
c---------interpolate to find the long-range force
          fnfar = pforce(i-1,0) 
     x            + (-ovrlap - psep(i-1,0))
     x               * (pforce(i,0) - pforce(i-1,0))
     x               / (psep(i,0) - psep(i-1,0))
c
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine fn_model2(diam, knh, ovrlap, seprat0, pforce, psep,
     x                     lc2, ldiams, nsepf, fnfar, fnnear, 
     x                     sepdia)
        integer*2 lc2, ldiams, itop, nsepf
        double precision diam, fnfar, fnnear, knh, 
     x                   ovrlap, pforce, psep, sepdia, seprat0
c
        dimension nsepf(0:ldiams),
     x            pforce(0:lc2,0:ldiams), psep(0:lc2,0:ldiams),
     x            sepdia(0:ldiams)
c
c-------find the reference diameter the actual diameter "diam"
        itop = 1
        do 10 while(diam.gt.sepdia(itop) .and. itop.ne.ldiams)
          itop = itop + 1
   10   continue
c
c-------the original overlap is the overlap of the two particles'
c       force fields.  We now find the actual overlap at touching
        ovrlap = ovrlap - seprat0
c
c-------determine whether the two particles are affected by the
c       long-range force (is their separation too large?)
        sepmax = psep(nsepf(itop-1)-1,itop-1)
     x     + (diam - sepdia(itop-1))
     x     * (psep(nsepf(itop)-1,itop) - psep(nsepf(itop-1)-1,itop-1))
     x     / (sepdia(itop) - sepdia(itop-1))
c
        if(ovrlap.gt.0.) then
c---------the particles are touching
c
c---------the part of the inter-particle force due to the particles touching
          fnnear = ovrlap*knh
c
c---------the long-range force (iterpolate between two input diameters)
          fnfar = pforce(0,itop-1)
     x            + (diam - sepdia(itop-1))
     x            * (pforce(0,itop) - pforce(0,itop-1))
     x            / (sepdia(itop) - sepdia(itop-1))
        elseif(-ovrlap .lt. sepmax) then
c---------the particles are not touching, but they experience
c         a long-range force
c
c---------the short range contact force is zero
          fnnear = 0.
c
c---------we need to interpolate in two ways:
c           1) for each of the input diameters, we find the long-range
c              force for the given separation
c           2) for the two forces, we interpolate for the actual diameter
c
c---------find the range of force-separations of the current separation
c         for the LOWER input diameter
          i = 1
          do 12 while(-ovrlap.gt.psep(i,itop-1) .and. i.ne.lc2)
            i = i + 1
   12     continue
c
c---------interpolate to find the long-range force
          fnfar1 = pforce(i-1,itop-1) 
     x             + (-ovrlap - psep(i-1,itop-1))
     x                * (pforce(i,itop-1) - pforce(i-1,itop-1))
     x                / (psep(i,itop-1) - psep(i-1,itop-1))
c
c---------find the range of force-separations of the current separation
c         for the UPPER input diameter
          i = 1
          do 14 while(-ovrlap.gt.psep(i,itop-1) .and. i.ne.lc2)
            i = i + 1
   14     continue
c
c---------interpolate to find the long-range force
          fnfar2 = pforce(i-1,itop)
     x             + (-ovrlap - psep(i-1,itop))
     x                * (pforce(i,itop) - pforce(i-1,itop))
     x                / (psep(i,itop) - psep(i-1,itop))
c
c---------finally, interpolate for the actual diameter
          fnfar = fnfar1
     x            + (diam - sepdia(itop-1))
     x            * (fnfar2 - fnfar1)
     x            / (sepdia(itop) - sepdia(itop-1))
c
        else
c---------the particles are out of range of a long-range force
          fnnear = 0.
          fnfar = 0.
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine fn_model34(fnfar, fnnear, knh, knsep2, knseph, ovrlap,
     x                     psep1, psep2, ifn_togl)
c
        integer*2 ifn_togl
        double precision fnfar, fnnear, knh, knsep2, knseph, ovrlap, 
     x                   psep1, psep2, seprt
c
        if(ovrlap.gt.0.) then
c---------the particles are touching
          fnfar = 0.
          fnnear = ovrlap*knh
c
c---------make sure that we're on the "2" branch of the long-range force curve,
c         so that if particles separate, the long-range force will be 
c         "turned on" at stiffness "knsep2"
          ifn_togl = 2
        else
c---------the particles are separated
          fnnear = 0.
c
          seprt = -ovrlap
          if(ifn_togl.eq.2) then
c-----------the long-range repulsion has already been "turned on" at the
c           stiffness "knsep2"
            if(seprt.gt.psep2) then
c-------------the separation exceeds "psep2", so "turn off" the repulsion
              fnfar = 0.
              ifn_togl = 0
            else
c-------------the separation does not exceed "psep2", so compute the repulsion
c             from the long-range stiffness "knseph"
              fnfar = ovrlap*knsep2
            endif
          elseif(ifn_togl.eq.1) then
c-----------the long-range repulsion has already been "turned on" at the
c           stiffness "knseph"
            if(seprt.gt.psep2) then
c-------------the separation exceeds "psep2", so "turn off" the repulsion
              fnfar = 0.
              ifn_togl = 0
            else
c-------------the separation does not exceed "psep2", so compute the repulsion
c             from the long-range stiffness "knseph"
              fnfar = ovrlap*knseph
            endif
          else
c-----------the long-range repulsion has already been "turned off"
            if(seprt.lt.psep1) then
c-------------the particle separation is now less than "psep1", so "turn on"
c             the repulsion
              fnfar = ovrlap*knseph
              ifn_togl = 1
            else
c-------------the particle separation is still greater than "psep1", so 
c             the long-range repulsion is zero
              fnfar = 0.
            endif
          endif
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine Hertz(rad_i, rad_j, ovrlap, Ebar, fn, R, a)
c
c-------compute the normal force of a Hertz-type contact:
c       input
c         rad_i,rad_j    radii of curvatures of the two particles at contact
c         ovrlap         the overlap of the two particles
c         Ebar          elastic constant = (8.d0/3.d0) * (G/(1.d0-nu))
c
c       output
c         fn             normal contact force (compression positive)
c         R              effective radius of curvature
c         a              contact radius
c
        double precision a,Ebar,fn,ovrlap,R,rad_i,rad_j
c
c-------as an effective (average) radius, we use the Thornton approach,
c       but instead of Thornton's R*, we use twice this value
        R = 2.d0 * (rad_i*rad_j) / (rad_i + rad_j)
        if(ovrlap .le. 0.) then
          fn = 0.
          a = 0.
        else
          a = sqrt(ovrlap * R / 2.d0)
          fn = Ebar * a**3 / R
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine bubble(gamm, u_atm, u_wo, Hcc, C_w, S_o, D_o, N_o,
     x                  J_F, u_w, u_vap, u_wcav, D, S_now,
     x                  K_s, poros0, Q, dm_stress,
     x                  Dlast, itask)
c
c-----this subroutin computes pore water pressure and water inflow, using
c     a model that assumes a uniform bubble diameter
c
c-----Input
c     gamm =      surface tension between water and gas, N/m
c     u_atm =     atmospheric pressure, Pa
c     u_wo =      initial water pressure, relative to atmospheric pressure, 
c                 from the simulation RunFile, Pa
c     Hcc =       dimensionless Henrys coefficient
c     C_w =       water compressibility, 1/Pa
c     S_o =       initial saturation, from the simulation RunFile
c     D_o =       initial bubble diameter, m, from the simulation RunFile.
c                 This value is only used when S_o<1.0 & N_o=0.
c     N_o =       number of bubbles per unit of pore fluid volume.  This value
c                 is used (and must be supplied) when S_o=1.0.  When S_o<1.0,
c                 N_o is used in place of D_o, when N_o~=0
c     J_F =       Jacobian of the fluids deformation gradient
c     u_w =       water pressure (should be given when itask=2)
c     u_vap =     (absolute) water vapor pressure (function of temperature)
c     u_wcav =    when S_o=1, we can give a (non-zero) water pressure below
c                 which bubbles will cavitate
c     D =         the (solved) value of the bubble diameter
c     K_s =       bulk modulus of the solid grains
c     poros0 =    initial porosity
c     Q =         volumetric inflow (influx) of fluid per unit of original
c                 volume (should be input when itask=1)
c     dm_stress = change between initial and current mean effective stress,
c                 (1/3)*sigma_kk
c     Dlast =     bubble diameter, m, from the previous call. A starting value
c                 for the iteration
c     itask =     (1) if water pressure is to be solved for a given
c                     volume strain
c                 (2) if volume strain is to be solved for a given
c                     water pressure
c
c-----Output
c     D =     the computed particle diameter, m
c     u_w =   the compute water pressure, relative to atmospheric pressure, Pa,
c             (output when itask=1)
c     Q =     the computed volumetric inflow of pore fluid (output when itask=2)
c     S_now = final saturation
c
      implicit double precision (a-h,o-z)

      double precision a, Acoef, b, c, C_w,
     x                 D, D_o, D_osat, D_otmp, 
     x                 delD, denom, Dlast, dm_stress,
     x                 f, fp, fpp, gamm, Hcc, J_F, K_s,
     x                 N_o, PolyD, PolyDp, PolyDpp, poros0, pi,
     x                 Q, Q_t, S_now, S_o,
     x                 u_atm, u_vap, u_w, u_wcav, u_wo, u_woa, 
     x                 u_wta
c
      integer*2 i, itask, j, k, norder
      logical ldislv,lsubth
c
      dimension a(10), b(10), c(10), PolyD(10), PolyDp(10), PolyDpp(10)
c
c-----the coefficients of polynomials in D, in the order of the 
c     largest to smallest (zeroth) power of D
      do 10 k = 1,10
        a(k) = 0.
        b(k) = 0.
        c(k) = 0.
        PolyD(k) = 0.
        PolyDp(k) = 0.
        PolyDpp(k) = 0.
   10 continue
c
      eps = 2.d-16
      pi = 3.14159265358979323846d0
c
c-----when ldislv=true, all bubbles are dissolved (or we are assuming that
c     no bubbles can exist).  When ldislv=false, bubbles are present and we
c     are to assume that they might cavitate with a decrease in water pressure.
      ldislv = S_o .ge. 1.d0 - eps
c
c-----initial bubble diameter, for computing current saturation
      D_osat = D_o
c
c-----if unsaturated and D_o is given, then use D_o to compute N_o.  Otherwise,
c     if unsaturated, use N_o to compute D_o
      if(.not.ldislv .and. D_o.gt.eps) then
        N_o = (1.d0 - S_o) / (pi/6.d0 *D_o**3)
        D_otmp = D_o
      elseif(.not.ldislv) then
        D_otmp = ((1.d0 - S_o) / (N_o * pi/6.d0))**(1.d0/3.d0)
        D_osat = D_otmp
      else
c-------a default value, to avoid division by zero during iteration
        D_otmp = 0.0001d0
        D_osat = 0.
      endif
c
c-----convert from gage pressure to absolute pressure
      u_woa = u_wo + u_atm
c
      if(itask.eq.1) then
c-------we will solve for the water pressure for a given volumetric
c       strain of the pore fluid
c
        lsubth = .false.
c
        if(.not.ldislv 
     x     .or. (ldislv .and. u_wcav.lt.u_wo .and. Hcc.ge.eps)) then
c---------bubbles are possibly present.  Solve their current diameter.
c
          if(.not.ldislv) then
c-----------the initial product m*R*T, where m is molar content of air
c           in both liquid and gas phases per unit of original void volume
            Acoef = (u_woa - u_vap + 4.d0*gamm/D_otmp)*(1.d0 - S_o)
     x              + Hcc*S_o*u_woa
          else
c-----------the pore fluid is saturated, but it contains some dissolved gas.
c           Compute the m*R*T product for the dissolved gas
            Acoef = Hcc*S_o*(u_wcav + u_atm)
          endif
c
c---------whether water pressure is below the threshold level, thus permitting
c         undissolved bubbles
          lsubth = .true.
c
          if(.not.ldislv .and. Hcc .ge. eps) then
c-----------threshold water pressure at which all bubbles are dissolved
            u_wta = (1.d0/S_o/Hcc) * Acoef
c
c-----------threshold inflow at which all bubbles are dissolved
            denom = poros0*(S_o*(1.d0 - (u_wta - u_woa)*C_w))
            Q_t = (1.d0/denom)
     x            *(J_F 
     x              - (1.d0-poros0)
     x                *(1.d0+dm_stress/K_s - (u_wta - u_woa)/K_s)
     x              - denom)
c
c-----------undissolved bubbles are possible
            lsubth = Q .lt. Q_t
c
c-----------an initial estimate of bubble diameter
            if(lsubth .and. Dlast.le.eps) then
              Dlast = 0.01d0 * D_otmp
            endif
          elseif(ldislv .and. u_wcav.ne.0.) then
c-----------the absolute cavitation pressure is the threshold water pressure
            u_wta = u_wcav + u_atm
c
c-----------threshold inflow at which all bubbles are dissolved
            denom = poros0*(S_o*(1.d0 - (u_wta - u_woa)*C_w))
            Q_t = (1.d0/denom)
     x            *(J_F 
     x              - (1.d0-poros0)
     x                *(1.d0+dm_stress/K_s - (u_wta - u_woa)/K_s)
     x              - denom)
c
c-----------undissolved bubbles are possible
            lsubth = Q .lt. Q_t
c
c-----------an initial estimate of bubble diameter
            if(lsubth .and. Dlast.eq.0.) then
              Dlast = 0.001d0 * (6.d0/pi/N_o)**(1.d0/3.d0)
            endif
          elseif(ldislv .and. u_wcav.eq.0.) then
c-----------when u_wcav is set to 0, cavitation is precluded and ignored
            lsubth = .false.
          endif
c
          if(lsubth) then
c-----------bubbles have not fully dissolved
c
c-----------initialize polynomial components.  These are the non-u_w 
c           coefficients of D in the mole-balance equation
            a(1) = 0.
            a(2) = 0.
            a(3) = 0.
            a(4) = -u_vap*N_o*(pi/6.d0)
            a(5) = 4*gamm*N_o*(pi/6.d0)
            a(6) = 0.
            a(7) = -Acoef
c
c-----------initialize polynomial components:
c             b(1)*D^4 + b(2)*D^3 + b(3)*D^2 + b(4)*D^1 + b(5) = 0.
c           these are the u_w coefficients of D in the mole-balance equation
            b(1) = N_o*(pi/6.d0)
            b(2) = 0.
            b(3) = 0.
            b(4) = Hcc*S_o
c
c-----------initialize polynomial components
c             c(1)*D^3 + c(2)*D^2 + c(3)*D^1 + c(4) = 0.
            denom = (1.d0 - poros0)/K_s + poros0*S_o*C_w*(1.d0+Q)
            c(1) = (1.d0/denom) * poros0*(1.d0+Q)*N_o*(pi/6.d0)
            c(2) = 0.
            c(3) = 0.
            c(4) = u_woa 
     x             + (1.d0/denom)
     x               *(-J_F
     x                 + poros0*(1.d0+Q)*S_o
     x                 + (1.d0 - poros0)*(1.d0+dm_stress/K_s))
c
c-----------PolyD = conv(b,c) + a:
c             Add polynomial "a" to the product of polynomials b*c
            do 20 k = 1,(4+4-1)
              PolyD(k) = 0.
              do 22 j = max(1,k+1-4),min(k,5)
                PolyD(k) = PolyD(k) + b(j)*c(k-j+1)
   22         continue
              PolyD(k) = PolyD(k) + a(k)
   20       continue
c
            norder = 6
c
c-----------coefficients of the derivative polynomial, for use in Newtons
c           iteration method
            do 24 k = 1,norder+1
              PolyDp(k) = (norder+1-k)*PolyD(k)
   24       continue
c
c-----------coefficients of the second derivative polynomial, as used in
c           second-order Newtons (Halleys) iteration method
            do 26 k = 1,norder
              PolyDpp(k) = (norder-k)*PolyDp(k)
   26       continue
c
c-----------start with the previous diameter as the initial guess.  Use Newtons
c           second-order (Halleys) iteration method to solve for the 
c           unknown bubble diameter D.
            D = Dlast
            do 30 i = 1,20
              f = PolyD(norder+1)
              fp = 0.
              do 32 k = 1,norder
                f = f + PolyD(k)*D**(norder+1-k)
   32         continue
c
c-------------the derivative at current D trial
              fp = PolyDp(norder)
              do 34 k = 1,norder-1
                fp = fp + PolyDp(k)*D**(norder-k)
   34         continue
c
c-------------second derivate at current D trial
              fpp = PolyDpp(norder-1)
              do 36 k = 1,norder-2
                fpp = fpp + PolyDpp(k)*D**(norder-1-k)
   36         continue
c
c-------------Halleys adjusment
              delD = (2.d0*f*fp)/(2.d0*fp**2 - f*fpp)
              D = D - delD
c
c-------------exit the iteration cycle when sufficient precision is achieved
              if(abs(delD/D_otmp) .lt. eps) then
                goto 31
              endif
   30       continue
   31       continue
          else
c-----------threshold water pressure is reached.  No bubbles remain
            ldislv = .true.
          endif
        endif
c
        if(ldislv .and. .not.lsubth) then
c---------all bubbles are dissolved.  Use D=0 and Eq. (25) to find the 
c         absolute water pressure
          D = 0.
          denom = (1.d0 - poros0)/K_s + poros0*S_o*C_w*(1.d0+Q)
          u_wa = u_woa 
     x           + (1.d0/denom)
     x             *(-J_F + poros0*(1.d0+Q)*S_o
     x                    + (1.d0 - poros0)*(1.d0 + dm_stress/K_s))
        else
c---------use D and Eq. (25) to find the absolute water pressure
          u_wa = c(4)
          do 38 k = 1,3
            u_wa = u_wa + c(k)*D**(4-k)
   38     continue
        endif
c
c-------the pore water pressure can not be smaller than the vapor pressure
c       of water
        u_wa = max(u_wa, u_vap)
c
c-------the gage water pressure
        u_w = u_wa - u_atm
c
      elseif(itask.eq.2) then
c-------given the water pressure, solve for a given volumetric
c       strain of the pore fluid
c
c-------absolute water pressure
        u_wa = u_w + u_atm
c
        if(.not.ldislv 
     x     .or. (ldislv .and. u_wcav.lt.u_wo .and. Hcc.ge.eps)) then
c---------the water pressure is sufficiently small, so that bubble exist
c
          if(.not.ldislv) then
c-----------the initial product m*R*T, where m is molar content of air
c           in both liquid and gas phases per unit of original void volume
             Acoef = (u_woa -u_vap + 4.d0*gamm/D_otmp)*(1.d0 - S_o)
     x               + Hcc*S_o*u_woa
          else
c-----------the pore fluid is saturated, but it contains some dissolved gas.
c           Compute the m*R*T product for the dissolved gas
            Acoef = Hcc*S_o*(u_wcav + u_atm)
          endif
c
c---------whether water pressure is below the threshold level, thus permitting
c         undissolved bubbles
          lsubth = .true.
c
          if(.not.ldislv .and. Hcc .ge. eps) then
c-----------threshold water pressure at which all bubbles are dissolved
            u_wta = (1.d0/S_o/Hcc) * Acoef
c
c-----------undissolved bubbles are possible
            lsubth = u_wa .lt. u_wta
c
c-----------an initial estimate of bubble diameter
            if(lsubth .and. Dlast.le.eps) then
              Dlast = 0.01d0 * D_otmp
            endif
          elseif(ldislv .and. u_wcav.ne.0.) then
c-----------the absolute cavitation pressure is the threshold water pressure
            u_wta = u_wcav + u_atm
c
c-----------undissolved bubbles are possible
            lsubth = u_wa .lt. u_wta
c
c-----------an initial estimate of bubble diameter
            if(lsubth .and. Dlast.eq.0.) then
              Dlast = 0.001d0 * (6.d0/pi/N_o)**(1.d0/3.d0)
            endif
          elseif(ldislv .and. u_wcav.eq.0.) then
c-----------when u_wcav is set to 0, cavitation is precluded and ignored
            lsubth = .false.
          endif
c
          if(lsubth) then
c-----------bubbles are possibly present
c
c-----------polynomial coefficients, in the order of largest to smallest powers
c           of D:
c           PolyD(1)*D^4 +PolyD(2)*D^3 +PolyD(3)*D^2 +PolyD(4)*D^1 +PolyD(5) =0
            PolyD(1) = (u_wa-u_vap)*N_o*(pi/6.d0)
            PolyD(2) = 4*gamm*N_o*(pi/6.d0)
            PolyD(3) = 0.
            PolyD(4) = -Acoef + Hcc*S_o*u_wa
c
c-----------polynomial order
            norder = 3
c
c-----------coefficients of the derivative polynomial
            do 40 k = 1,norder
              PolyDp(k) = (norder+1-k)*PolyD(k)
   40       continue
c
c-----------start with the previous diameter as the initial guess.  Use Newtons
c           method to solve for the unknown bubble diameter D.
            D = Dlast
            do 42 i = 1,20
              f = PolyD(norder+1)
              fp = 0.
              do 44 k = 1,norder
                f = f + PolyD(k)*D**(norder+1-k)
                fp = fp + PolyDp(k)*D**(norder-k)
   44         continue
c
c-------------Newtons adjustment
              delD = f/fp
              D = D - delD
c
c-------------exit iteration when sufficient precision is achieved
              if(abs(delD/D_otmp) .lt. eps) then
                goto 43
              endif
   42       continue
   43       continue
          else
c-----------water pressure exceeds the threshold pressure.  Bubbles are fully
c           disolved
            D = 0.
            ldislv = .true.
          endif
        endif
c
        if(ldislv .and. .not.lsubth) then
c---------all bubbles are dissolved
          D = 0.
          denom = poros0*(S_o*(1.d0-(u_w-u_wo)*C_w))
        else
          denom = poros0
     x            *(S_o*(1.d0-(u_w-u_wo)*C_w) + N_o*(pi/6.d0)*D**3)
        endif
c
c-------use Eq. (25) to solve for Q
        Q = (1.d0/denom)
     x      *(J_F 
     x        - (1.d0-poros0)
     x          *(1.d0 + dm_stress/K_s - (u_w-u_wo)/K_s) 
     x        - denom)
      endif
c
c-----the current saturation
      S_now = S_o + N_o*(pi/6.d0)*(D_osat**3 - D**3)
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine platns(rve)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 rve
c
c---------are platens to be added to the sides of the assembly?
          lplatn = .false.
c
c---------initialize all particles as being free (no fixity, as with platens)
c         lxfix(1,0) = .false.
c         lxfix(2,0) = .false.
c         lxfix(3,0) = .false.
          lthfix(1,0,rve) = .false.
          lthfix(2,0,rve) = .false.
          lthfix(3,0,rve) = .false.
c
c---------initialize the directions in which platens are applied
          ldirec(1) = .false.
          ldirec(2) = .false.
          ldirec(3) = .false.
c
          xcelle(1,rve) = xcell(1,1,rve)
          xcelle(2,rve) = xcell(2,2,rve)
          xcelle(3,rve) = xcell(3,3,rve)
c
          do 180 i = 1,ndim1
            xcelle(i,rve) = xcelle(i,rve) / xcell(i,i,rve)
  180     continue
c
        return
      end
c
c
c=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\
c
c The next 580 lines of code are for generating random numbers.  This code
c was written and compiled by Barry W. Brown and James Lovato of the 
c University of Texas.  I obtained this code from the Netlib project
c (http://www.netlib.org/).  According to the README file that accompanies
c their "Ranlib" code, the following legalities apply:
c
c                              LEGALITIES
c
c  Code that appeared in an ACM publication is subject to their
c  algorithms policy:
c
c     Submittal of an algorithm for publication in one of the ACM
c     Transactions implies that unrestricted use of the algorithm within a
c     computer is permissible.  General permission to copy and distribute
c     the algorithm without fee is granted provided that the copies are not
c     made or distributed for direct commercial advantage.  The ACM
c     copyright notice and the title of the publication and its date appear,
c     and notice is given that copying is by permission of the Association
c     for Computing Machinery. To copy otherwise, or to republish, requires
c     a fee and/or specific permission.
c  
c      Krogh, F. Algorithms Policy. ACM Tran. Math. Softw. 13(1987),
c      183-186.
c
c  We place the Ranlib code that we have written in the public domain.
c  
c                                   NO WARRANTY
c  
c       WE PROVIDE ABSOLUTELY NO WARRANTY OF ANY KIND EITHER EXPRESSED OR
c       IMPLIED, INCLUDING BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
c       MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK
c       AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD
c       THIS PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
c       SERVICING, REPAIR OR CORRECTION.
c  
c       IN NO EVENT SHALL THE UNIVERSITY OF TEXAS OR ANY OF ITS COMPONENT
c       INSTITUTIONS INCLUDING M. D. ANDERSON HOSPITAL BE LIABLE TO YOU FOR
c       DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER SPECIAL,
c       INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
c       INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA OR
c       ITS ANALYSIS BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD
c       PARTIES) THE PROGRAM.
c  
c       (Above NO WARRANTY modified from the GNU NO WARRANTY statement.)
c
c=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\
c
c
      REAL FUNCTION randof()
cc    renamed from the original ranf()
C**********************************************************************
C
C     REAL FUNCTION RANF()
C                RANDom number generator as a Function
C
C     Returns a random floating point number from a uniform distribution
C     over 0 - 1 (endpoints of this interval are not returned) using the
C     current generator
C
C     This is a transcription from Pascal to Fortran of routin
C     Uniform_01 from the paper
C
C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
C     with Splitting Facilities." ACM Transactions on Mathematical
C     Software, 17:98-111 (1991)
C
C**********************************************************************
C     .. External Functions ..
      INTEGER ignlgi
      EXTERNAL ignlgi
C     ..
C     .. Executable Statements ..
C
C     4.656613057E-10 is 1/M1  M1 is set in a data statement in IGNLGI
C      and is currently 2147483563. If M1 changes, change this also.
C
      randof = ignlgi()*4.656613057E-10
cc    renamed from the original ranf()
      RETURN

      END
      SUBROUTINE setall(iseed1,iseed2)
C**********************************************************************
C
C      SUBROUTINE SETALL(ISEED1,ISEED2)
C               SET ALL random number generators
C
C     Sets the initial seed of generator 1 to ISEED1 and ISEED2. The
C     initial seeds of the other generators are set accordingly, and
C     all generators states are set to these seeds.
C
C     This is a transcription from Pascal to Fortran of routin
C     Set_Initial_Seed from the paper
C
C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
C     with Splitting Facilities." ACM Transactions on Mathematical
C     Software, 17:98-111 (1991)
C
C
C                              Arguments
C
C
C     ISEED1 -> First of two integer seeds
C                                   INTEGER ISEED1
C
C     ISEED2 -> Second of two integer seeds
C                                   INTEGER ISEED1
C
C**********************************************************************
C     .. Parameters ..
      INTEGER numg
      PARAMETER (numg=32)
C     ..
C     .. Scalar Arguments ..
      INTEGER iseed1,iseed2
      LOGICAL qssd
C     ..
C     .. Scalars in Common ..
      INTEGER a1,a1vw,a1w,a2,a2vw,a2w,m1,m2
C     ..
C     .. Arrays in Common ..
      INTEGER cg1(numg),cg2(numg),ig1(numg),ig2(numg),lg1(numg),
     +        lg2(numg)
      LOGICAL qanti(numg)
C     ..
C     .. Local Scalars ..
      INTEGER g,ocgn
      LOGICAL qqssd
C     ..
C     .. External Functions ..
      INTEGER mltmod
      LOGICAL qrgnin
      EXTERNAL mltmod,qrgnin
C     ..
C     .. External Subroutins ..
      EXTERNAL getcgn,initgn,inrgcm,setcgn
C     ..
C     .. Common blocks ..
      COMMON /globe/m1,m2,a1,a2,a1w,a2w,a1vw,a2vw,ig1,ig2,lg1,lg2,cg1,
     +       cg2,qanti
C     ..
C     .. Save statement ..
      SAVE /globe/,qqssd
C     ..
C     .. Data statements ..
      DATA qqssd/.FALSE./
C     ..
C     .. Executable Statements ..
C
C     TELL IGNLGI, THE ACTUAL NUMBER GENERATOR, THAT THIS ROUTINE
C      HAS BEEN CALLED.
C
      qqssd = .TRUE.
      CALL getcgn(ocgn)
C
C     Initialize Common Block if Necessary
C
      IF (.NOT. (qrgnin())) CALL inrgcm()
      ig1(1) = iseed1
      ig2(1) = iseed2
      CALL initgn(-1)
      DO 10,g = 2,numg
          ig1(g) = mltmod(a1vw,ig1(g-1),m1)
          ig2(g) = mltmod(a2vw,ig2(g-1),m2)
          CALL setcgn(g)
          CALL initgn(-1)
   10 CONTINUE
      CALL setcgn(ocgn)
      RETURN

      ENTRY rgnqsd(qssd)
C**********************************************************************
C
C     SUBROUTINE RGNQSD
C                    Random Number Generator Query SeeD set?
C
C     Returns (LOGICAL) QSSD as .TRUE. if SETALL has been invoked,
C     otherwise returns .FALSE.
C
C**********************************************************************
      qssd = qqssd
      RETURN

      END
      SUBROUTINE initgn(isdtyp)
C**********************************************************************
C
C     SUBROUTINE INITGN(ISDTYP)
C          INIT-ialize current G-e-N-erator
C
C     Reinitializes the state of the current generator
C
C     This is a transcription from Pascal to Fortran of routin
C     Init_Generator from the paper
C
C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
C     with Splitting Facilities." ACM Transactions on Mathematical
C     Software, 17:98-111 (1991)
C
C
C                              Arguments
C
C
C     ISDTYP -> The state to which the generator is to be set
C
C          ISDTYP = -1  => sets the seeds to their initial value
C          ISDTYP =  0  => sets the seeds to the first value of
C                          the current block
C          ISDTYP =  1  => sets the seeds to the first value of
C                          the next block
C
C                                   INTEGER ISDTYP
C
C**********************************************************************
C     .. Parameters ..
      INTEGER numg
      PARAMETER (numg=32)
C     ..
C     .. Scalar Arguments ..
      INTEGER isdtyp
C     ..
C     .. Scalars in Common ..
      INTEGER a1,a1vw,a1w,a2,a2vw,a2w,m1,m2
C     ..
C     .. Arrays in Common ..
      INTEGER cg1(numg),cg2(numg),ig1(numg),ig2(numg),lg1(numg),
     +        lg2(numg)
      LOGICAL qanti(numg)
C     ..
C     .. Local Scalars ..
      INTEGER g
C     ..
C     .. External Functions ..
      LOGICAL qrgnin
      INTEGER mltmod
      EXTERNAL qrgnin,mltmod
C     ..
C     .. External Subroutins ..
      EXTERNAL getcgn
C     ..
C     .. Common blocks ..
      COMMON /globe/m1,m2,a1,a2,a1w,a2w,a1vw,a2vw,ig1,ig2,lg1,lg2,cg1,
     +       cg2,qanti
C     ..
C     .. Save statement ..
      SAVE /globe/
C     ..
C     .. Executable Statements ..
C     Abort unless random number generator initialized
      IF (qrgnin()) GO TO 10
      WRITE (*,*) ' INITGN called before random number generator ',
     +  ' initialized -- abort!'
      STOP ' INITGN called before random number generator initialized'

   10 CALL getcgn(g)
      IF ((-1).NE. (isdtyp)) GO TO 20
      lg1(g) = ig1(g)
      lg2(g) = ig2(g)
      GO TO 50

   20 IF ((0).NE. (isdtyp)) GO TO 30
      CONTINUE
      GO TO 50
C     do nothing
   30 IF ((1).NE. (isdtyp)) GO TO 40
      lg1(g) = mltmod(a1w,lg1(g),m1)
      lg2(g) = mltmod(a2w,lg2(g),m2)
      GO TO 50

   40 STOP 'ISDTYP NOT IN RANGE'

   50 cg1(g) = lg1(g)
      cg2(g) = lg2(g)
      RETURN

      END
      INTEGER FUNCTION mltmod(a,s,m)
C**********************************************************************
C
C     INTEGER FUNCTION MLTMOD(A,S,M)
C
C                    Returns (A*S) MOD M
C
C     This is a transcription from Pascal to Fortran of routin
C     MULtMod_Decompos from the paper
C
C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
C     with Splitting Facilities." ACM Transactions on Mathematical
C     Software, 17:98-111 (1991)
C
C
C                              Arguments
C
C
C     A, S, M  -->
C                         INTEGER A,S,M
C
C**********************************************************************
C     .. Parameters ..
      INTEGER h
      PARAMETER (h=32768)
C     ..
C     .. Scalar Arguments ..
      INTEGER a,m,s
C     ..
C     .. Local Scalars ..
      INTEGER a0,a1,k,p,q,qh,rh
C     ..
C     .. Executable Statements ..
C
C     H = 2**((b-2)/2) where b = 32 because we are using a 32 bit
C      machine. On a different machine recompute H
C
      IF (.NOT. (a.LE.0.OR.a.GE.m.OR.s.LE.0.OR.s.GE.m)) GO TO 10
      WRITE (*,*) ' A, M, S out of order in MLTMOD - ABORT!'
      WRITE (*,*) ' A = ',a,' S = ',s,' M = ',m
      WRITE (*,*) ' MLTMOD requires: 0 < A < M; 0 < S < M'
      STOP ' A, M, S out of order in MLTMOD - ABORT!'

   10 IF (.NOT. (a.LT.h)) GO TO 20
      a0 = a
      p = 0
      GO TO 120

   20 a1 = a/h
      a0 = a - h*a1
      qh = m/h
      rh = m - h*qh
      IF (.NOT. (a1.GE.h)) GO TO 50
      a1 = a1 - h
      k = s/qh
      p = h* (s-k*qh) - k*rh
   30 IF (.NOT. (p.LT.0)) GO TO 40
      p = p + m
      GO TO 30

   40 GO TO 60

   50 p = 0
C
C     P = (A2*S*H)MOD M
C
   60 IF (.NOT. (a1.NE.0)) GO TO 90
      q = m/a1
      k = s/q
      p = p - k* (m-a1*q)
      IF (p.GT.0) p = p - m
      p = p + a1* (s-k*q)
   70 IF (.NOT. (p.LT.0)) GO TO 80
      p = p + m
      GO TO 70

   80 CONTINUE
   90 k = p/qh
C
C     P = ((A2*H + A1)*S)MOD M
C
      p = h* (p-k*qh) - k*rh
  100 IF (.NOT. (p.LT.0)) GO TO 110
      p = p + m
      GO TO 100

  110 CONTINUE
  120 IF (.NOT. (a0.NE.0)) GO TO 150
C
C     P = ((A2*H + A1)*H*S)MOD M
C
      q = m/a0
      k = s/q
      p = p - k* (m-a0*q)
      IF (p.GT.0) p = p - m
      p = p + a0* (s-k*q)
  130 IF (.NOT. (p.LT.0)) GO TO 140
      p = p + m
      GO TO 130

  140 CONTINUE
  150 mltmod = p
C
      RETURN

      END
      SUBROUTINE inrgcm()
C**********************************************************************
C
C     SUBROUTINE INRGCM()
C          INitialize Random number Generator CoMmon
C
C
C                              Function
C
C
C     Initializes common area  for random number  generator.  This saves
C     the  nuisance  of  a  BLOCK DATA  routin  and the  difficulty  of
C     assuring that the routin is loaded with the other routins.
C
C**********************************************************************
C     .. Parameters ..
      INTEGER numg
      PARAMETER (numg=32)
C     ..
C     .. Scalars in Common ..
      INTEGER a1,a1vw,a1w,a2,a2vw,a2w,m1,m2
C     ..
C     .. Arrays in Common ..
      INTEGER cg1(numg),cg2(numg),ig1(numg),ig2(numg),lg1(numg),
     +        lg2(numg)
      LOGICAL qanti(numg)
C     ..
C     .. Local Scalars ..
      INTEGER i
      LOGICAL qdum
C     ..
C     .. External Functions ..
      LOGICAL qrgnsn
      EXTERNAL qrgnsn
C     ..
C     .. Common blocks ..
      COMMON /globe/m1,m2,a1,a2,a1w,a2w,a1vw,a2vw,ig1,ig2,lg1,lg2,cg1,
     +       cg2,qanti
C     ..
C     .. Save statement ..
      SAVE /globe/
C     ..
C     .. Executable Statements ..
C     V=20;                            W=30;
C
C     A1W = MOD(A1**(2**W),M1)         A2W = MOD(A2**(2**W),M2)
C     A1VW = MOD(A1**(2**(V+W)),M1)    A2VW = MOD(A2**(2**(V+W)),M2)
C
C   If V or W is changed A1W, A2W, A1VW, and A2VW need to be recomputed.
C    An efficient way to precompute a**(2*j) MOD m is to start with
C    a and square it j times modulo m using the function MLTMOD.
C
      m1 = 2147483563
      m2 = 2147483399
      a1 = 40014
      a2 = 40692
      a1w = 1033780774
      a2w = 1494757890
      a1vw = 2082007225
      a2vw = 784306273
      DO 10,i = 1,numg
          qanti(i) = .FALSE.
   10 CONTINUE
C
C     Tell the world that common has been initialized
C
      qdum = qrgnsn(.TRUE.)
      RETURN

      END
      SUBROUTINE getcgn(g)
      INTEGER g
C**********************************************************************
C
C      SUBROUTINE GETCGN(G)
C                         Get GeNerator
C
C     Returns in G the number of the current random number generator
C
C
C                              Arguments
C
C
C     G <-- Number of the current random number generator (1..32)
C                    INTEGER G
C
C**********************************************************************
C
      INTEGER curntg,numg
      SAVE curntg
      PARAMETER (numg=32)
      DATA curntg/1/
C
      g = curntg
      RETURN

      ENTRY setcgn(g)
C**********************************************************************
C
C     SUBROUTINE SETCGN( G )
C                      Set GeNerator
C
C     Sets  the  current  generator to G.    All references to a generat
C     are to the current generator.
C
C
C                              Arguments
C
C
C     G --> Number of the current random number generator (1..32)
C                    INTEGER G
C
C**********************************************************************
C
C     Abort if generator number out of range
C
      IF (.NOT. (g.LT.0.OR.g.GT.numg)) GO TO 10
      WRITE (*,*) ' Generator number out of range in SETCGN:',
     +  ' Legal range is 1 to ',numg,' -- ABORT!'
      STOP ' Generator number out of range in SETCGN'

   10 curntg = g
      RETURN

      END
      INTEGER FUNCTION ignlgi()
C**********************************************************************
C
C     INTEGER FUNCTION IGNLGI()
C               GeNerate LarGe Integer
C
C     Returns a random integer following a uniform distribution over
C     (1, 2147483562) using the current generator.
C
C     This is a transcription from Pascal to Fortran of routin
C     Random from the paper
C
C     L'Ecuyer, P. and Cote, S. "Implementing a Random Number Package
C     with Splitting Facilities." ACM Transactions on Mathematical
C     Software, 17:98-111 (1991)
C
C**********************************************************************
C     .. Parameters ..
      INTEGER numg
      PARAMETER (numg=32)
C     ..
C     .. Scalars in Common ..
      INTEGER a1,a1vw,a1w,a2,a2vw,a2w,m1,m2
C     ..
C     .. Arrays in Common ..
      INTEGER cg1(numg),cg2(numg),ig1(numg),ig2(numg),lg1(numg),
     +        lg2(numg)
      LOGICAL qanti(numg)
C     ..
C     .. Local Scalars ..
      INTEGER curntg,k,s1,s2,z
      LOGICAL qqssd
C     ..
C     .. External Functions ..
      LOGICAL qrgnin
      EXTERNAL qrgnin
C     ..
C     .. External Subroutins ..
      EXTERNAL getcgn,inrgcm,rgnqsd,setall
C     ..
C     .. Common blocks ..
      COMMON /globe/m1,m2,a1,a2,a1w,a2w,a1vw,a2vw,ig1,ig2,lg1,lg2,cg1,
     +       cg2,qanti
C     ..
C     .. Save statement ..
      SAVE /globe/
C     ..
C     .. Executable Statements ..
C
C     IF THE RANDOM NUMBER PACKAGE HAS NOT BEEN INITIALIZED YET, DO SO.
C     IT CAN BE INITIALIZED IN ONE OF TWO WAYS : 1) THE FIRST CALL TO
C     THIS ROUTINE  2) A CALL TO SETALL.
C
      IF (.NOT. (qrgnin())) CALL inrgcm()
      CALL rgnqsd(qqssd)
      IF (.NOT. (qqssd)) CALL setall(1234567890,123456789)
C
C     Get Current Generator
C
      CALL getcgn(curntg)
      s1 = cg1(curntg)
      s2 = cg2(curntg)
      k = s1/53668
      s1 = a1* (s1-k*53668) - k*12211
      IF (s1.LT.0) s1 = s1 + m1
      k = s2/52774
      s2 = a2* (s2-k*52774) - k*3791
      IF (s2.LT.0) s2 = s2 + m2
      cg1(curntg) = s1
      cg2(curntg) = s2
      z = s1 - s2
      IF (z.LT.1) z = z + m1 - 1
      IF (qanti(curntg)) z = m1 - z
      ignlgi = z
      RETURN

      END
      LOGICAL FUNCTION qrgnin()
C**********************************************************************
C
C     LOGICAL FUNCTION QRGNIN()
C               Q Random GeNerators INitialized?
C
C     A trivial routin to determine whether or not the random
C     number generator has been initialized.  Returns .TRUE. if
C     it has, else .FALSE.
C
C**********************************************************************
C     .. Scalar Arguments ..
      LOGICAL qvalue
C     ..
C     .. Local Scalars ..
      LOGICAL qinit
C     ..
C     .. Entry Points ..
      LOGICAL qrgnsn
C     ..
C     .. Save statement ..
      SAVE qinit
C     ..
C     .. Data statements ..
      DATA qinit/.FALSE./
C     ..
C     .. Executable Statements ..
      qrgnin = qinit
      RETURN

      ENTRY qrgnsn(qvalue)
C**********************************************************************
C
C     LOGICAL FUNCTION QRGNSN( QVALUE )
C               Q Random GeNerators Set whether iNitialized
C
C     Sets state of whether random number generator is initialized
C     to QVALUE.
C
C     This routin is actually an entry in QRGNIN, hence it is a
C     logical function.  It returns the (meaningless) value .TRUE.
C
C**********************************************************************
      qinit = qvalue
      qrgnsn = .TRUE.
      RETURN

      END
c
c=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\=\
c
c End Subroutins for Using Measuring Micro-Deformations
c|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
c
c
c|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
c Start Subroutins for Studying Srain Gradient Effects
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      SUBROUTINE DSORT (DX, DY, N, KFLAG)
C***BEGIN PROLOGUE  DSORT
C***PURPOSE  Sort an array and optionally make the same interchanges in
C            an auxiliary array.  The array may be sorted in increasing
C            or decreasing order.  A slightly modified QUICKSORT
C            algorithm is used.
C***LIBRARY   SLATEC
C***CATEGORY  N6A2B
C***TYPE      DOUBLE PRECISION (SSORT-S, DSORT-D, ISORT-I)
C***KEYWORDS  SINGLETON QUICKSORT, SORT, SORTING
C***AUTHOR  Jones, R. E., (SNLA)
C           Wisniewski, J. A., (SNLA)
C***DESCRIPTION
C
C   DSORT sorts array DX and optionally makes the same interchanges in
C   array DY.  The array DX may be sorted in increasing order or
C   decreasing order.  A slightly modified quicksort algorithm is used.
C
C   Description of Parameters
C      DX - array of values to be sorted   (usually abscissas)
C      DY - array to be (optionally) carried along
C      N  - number of values in array DX to be sorted
C      KFLAG - control parameter
C            =  2  means sort DX in increasing order and carry DY along.
C            =  1  means sort DX in increasing order (ignoring DY)
C            = -1  means sort DX in decreasing order (ignoring DY)
C            = -2  means sort DX in decreasing order and carry DY along.
C
C***REFERENCES  R. C. Singleton, Algorithm 347, An efficient algorithm
C                 for sorting with minimal storage, Communications of
C                 the ACM, 12, 3 (1969), pp. 185-187.
C***ROUTINES CALLED  XERMSG
C***REVISION HISTORY  (YYMMDD)
C   761101  DATE WRITTEN
C   761118  Modified to use the Singleton quicksort algorithm.  (JAW)
C   890531  Changed all specific intrinsics to generic.  (WRB)
C   890831  Modified array declarations.  (WRB)
C   891009  Removed unreferenced statement labels.  (WRB)
C   891024  Changed category.  (WRB)
C   891024  REVISION DATE from Version 3.2
C   891214  Prologue converted to Version 4.0 format.  (BAB)
C   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
C   901012  Declared all variables; changed X,Y to DX,DY; changed
C           code to parallel SSORT. (M. McClain)
C   920501  Reformatted the REFERENCES section.  (DWL, WRB)
C   920519  Clarified error messages.  (DWL)
C   920801  Declarations section rebuilt and code restructured to use
C           IF-THEN-ELSE-ENDIF.  (RWC, WRB)
C***END PROLOGUE  DSORT
C     .. Scalar Arguments ..
      INTEGER KFLAG, N
C     .. Array Arguments ..
      DOUBLE PRECISION DX(*), DY(*)
C     .. Local Scalars ..
      DOUBLE PRECISION R, T, TT, TTY, TY
      INTEGER I, IJ, J, K, KK, L, M, NN
C     .. Local Arrays ..
      INTEGER IL(21), IU(21)
C     .. External Subroutines ..
c     EXTERNAL XERMSG
C     .. Intrinsic Functions ..
      INTRINSIC ABS, INT
C***FIRST EXECUTABLE STATEMENT  DSORT
      NN = N
      IF (NN .LT. 1) THEN
c        CALL XERMSG ('SLATEC', 'DSORT',
c    +      'The number of values to be sorted is not positive.', 1, 1)
         write(*,*)
     x     'SLATEC DSORT The number of values to be sorted is'
         RETURN
      ENDIF
C
      KK = ABS(KFLAG)
      IF (KK.NE.1 .AND. KK.NE.2) THEN
c        CALL XERMSG ('SLATEC', 'DSORT',
c    +      'The sort control parameter, K, is not 2, 1, -1, or -2.', 2,
c    +      1)
         write(*,*)
     x     'SLATEC DSORT The sort control parameter, K, is not 2'
         RETURN
      ENDIF
C
C     Alter array DX to get decreasing order if needed
C
      IF (KFLAG .LE. -1) THEN
         DO 10 I=1,NN
            DX(I) = -DX(I)
   10    CONTINUE
      ENDIF
C
      IF (KK .EQ. 2) GO TO 100
C
C     Sort DX only
C
      M = 1
      I = 1
      J = NN
      R = 0.375D0
C
   20 IF (I .EQ. J) GO TO 60
      IF (R .LE. 0.5898437D0) THEN
         R = R+3.90625D-2
      ELSE
         R = R-0.21875D0
      ENDIF
C
   30 K = I
C
C     Select a central element of the array and save it in location T
C
      IJ = I + INT((J-I)*R)
      T = DX(IJ)
C
C     If first element of array is greater than T, interchange with T
C
      IF (DX(I) .GT. T) THEN
         DX(IJ) = DX(I)
         DX(I) = T
         T = DX(IJ)
      ENDIF
      L = J
C
C     If last element of array is less than than T, interchange with T
C
      IF (DX(J) .LT. T) THEN
         DX(IJ) = DX(J)
         DX(J) = T
         T = DX(IJ)
C
C        If first element of array is greater than T, interchange with T
C
         IF (DX(I) .GT. T) THEN
            DX(IJ) = DX(I)
            DX(I) = T
            T = DX(IJ)
         ENDIF
      ENDIF
C
C     Find an element in the second half of the array which is smaller
C     than T
C
   40 L = L-1
      IF (DX(L) .GT. T) GO TO 40
C
C     Find an element in the first half of the array which is greater
C     than T
C
   50 K = K+1
      IF (DX(K) .LT. T) GO TO 50
C
C     Interchange these elements
C
      IF (K .LE. L) THEN
         TT = DX(L)
         DX(L) = DX(K)
         DX(K) = TT
         GO TO 40
      ENDIF
C
C     Save upper and lower subscripts of the array yet to be sorted
C
      IF (L-I .GT. J-K) THEN
         IL(M) = I
         IU(M) = L
         I = K
         M = M+1
      ELSE
         IL(M) = K
         IU(M) = J
         J = L
         M = M+1
      ENDIF
      GO TO 70
C
C     Begin again on another portion of the unsorted array
C
   60 M = M-1
      IF (M .EQ. 0) GO TO 190
      I = IL(M)
      J = IU(M)
C
   70 IF (J-I .GE. 1) GO TO 30
      IF (I .EQ. 1) GO TO 20
      I = I-1
C
   80 I = I+1
      IF (I .EQ. J) GO TO 60
      T = DX(I+1)
      IF (DX(I) .LE. T) GO TO 80
      K = I
C
   90 DX(K+1) = DX(K)
      K = K-1
      IF (T .LT. DX(K)) GO TO 90
      DX(K+1) = T
      GO TO 80
C
C     Sort DX and carry DY along
C
  100 M = 1
      I = 1
      J = NN
      R = 0.375D0
C
  110 IF (I .EQ. J) GO TO 150
      IF (R .LE. 0.5898437D0) THEN
         R = R+3.90625D-2
      ELSE
         R = R-0.21875D0
      ENDIF
C
  120 K = I
C
C     Select a central element of the array and save it in location T
C
      IJ = I + INT((J-I)*R)
      T = DX(IJ)
      TY = DY(IJ)
C
C     If first element of array is greater than T, interchange with T
C
      IF (DX(I) .GT. T) THEN
         DX(IJ) = DX(I)
         DX(I) = T
         T = DX(IJ)
         DY(IJ) = DY(I)
         DY(I) = TY
         TY = DY(IJ)
      ENDIF
      L = J
C
C     If last element of array is less than T, interchange with T
C
      IF (DX(J) .LT. T) THEN
         DX(IJ) = DX(J)
         DX(J) = T
         T = DX(IJ)
         DY(IJ) = DY(J)
         DY(J) = TY
         TY = DY(IJ)
C
C        If first element of array is greater than T, interchange with T
C
         IF (DX(I) .GT. T) THEN
            DX(IJ) = DX(I)
            DX(I) = T
            T = DX(IJ)
            DY(IJ) = DY(I)
            DY(I) = TY
            TY = DY(IJ)
         ENDIF
      ENDIF
C
C     Find an element in the second half of the array which is smaller
C     than T
C
  130 L = L-1
      IF (DX(L) .GT. T) GO TO 130
C
C     Find an element in the first half of the array which is greater
C     than T
C
  140 K = K+1
      IF (DX(K) .LT. T) GO TO 140
C
C     Interchange these elements
C
      IF (K .LE. L) THEN
         TT = DX(L)
         DX(L) = DX(K)
         DX(K) = TT
         TTY = DY(L)
         DY(L) = DY(K)
         DY(K) = TTY
         GO TO 130
      ENDIF
C
C     Save upper and lower subscripts of the array yet to be sorted
C
      IF (L-I .GT. J-K) THEN
         IL(M) = I
         IU(M) = L
         I = K
         M = M+1
      ELSE
         IL(M) = K
         IU(M) = J
         J = L
         M = M+1
      ENDIF
      GO TO 160
C
C     Begin again on another portion of the unsorted array
C
  150 M = M-1
      IF (M .EQ. 0) GO TO 190
      I = IL(M)
      J = IU(M)
C
  160 IF (J-I .GE. 1) GO TO 120
      IF (I .EQ. 1) GO TO 110
      I = I-1
C
  170 I = I+1
      IF (I .EQ. J) GO TO 150
      T = DX(I+1)
      TY = DY(I+1)
      IF (DX(I) .LE. T) GO TO 170
      K = I
C
  180 DX(K+1) = DX(K)
      DY(K+1) = DY(K)
      K = K-1
      IF (T .LT. DX(K)) GO TO 180
      DX(K+1) = T
      DY(K+1) = TY
      GO TO 170
C
C     Clean up
C
  190 IF (KFLAG .LE. -1) THEN
         DO 200 I=1,NN
            DX(I) = -DX(I)
  200    CONTINUE
      ENDIF
      RETURN
      END
c
c End Subroutins for Studying Srain Gradient Effects
c|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
c
c
c|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
c Start Subroutins for Studying Creep Effects
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine sinhf(fn,
     x                timer,coef4,coef5,coef7,dftabc,
     x                ds1,dsold,
     x                dtreal,fnold1,ft,ftolds,fttot,ptol,
     x                rtouch,kthhz,viscc,dviscc,ltouch,itrack,
     x                igrain,jgrain,ScrUnit,rve,mrve)
c
c-------I used this so-call "sinh dashpot" for some very early
c       studies of creep in granular materials.  I don't know if
c       it still works.
c
c-------the subroutin computes the tangential force with a
c       "sinh dashpot"
c
        implicit double precision(a-h,o-z)
        double precision abbsnh,abcsh,alpbet,alpha,alphai,amag,
     x                   apower,asnh,below,beta2,beta2sh,
     x                   coef4,coef5,coef7,
     x                   csh,csho,dftabc,ds1,dso,dsold,dtreal,dviscc,
     x                   ex,exi,fn,fnold1,ft,ftim,fttot,ftnew,ftolds,
     x                   h,hi,kthhz,
     x                   power,powerq,ptol,rtouch,snh,snh1,snho,timer,
     x                   viscc,z,zo,z0,z1,zm
c
        integer*4 itrack,igrain,jgrain
        integer*2 itimes,iexit,mrve,rve,ScrUnit
        logical lab,lold,lh,ltouch
c
        dimension dftabc(3),dso(3),ft(3),ftim(3),ftolds(3),
     x            fttot(3),itrack(4,0:mrve)
        dimension ScrUnit(0:mrve)
c
        lab = .true.
        lold = .false.
        lh = .false.
        itimes = 0
        iexit = 0
        z0 = 0.
        dviscc = 0.
c
        ftoldm = sqrt(ftolds(1)**2 + ftolds(2)**2 
     x                + ftolds(3)**2)
        coef6 = coef4/fn
        if(ftoldm.ne.0.) then
c---------note that dtreal has a different context outside of this subroutin
          dso(1) = kthhz*dsold*ftolds(1)*dtreal/ftoldm
          dso(2) = kthhz*dsold*ftolds(2)*dtreal/ftoldm
          dso(3) = kthhz*dsold*ftolds(3)*dtreal/ftoldm
        else
          dso(1) = 0.
          dso(2) = 0.
          dso(3) = 0.
        endif
c
        ftim(1) = ftolds(1) + dftabc(1) - dso(1)
        ftim(2) = ftolds(2) + dftabc(2) - dso(2)
        ftim(3) = ftolds(3) + dftabc(3) - dso(3)
c
        amag = sqrt(ftim(1)**2 + ftim(2)**2 + ftim(3)**2)
        if(amag.eq.0.) then
c---------note that dtreal has a different context outside of this subroutin
          z = 0.
          ftnew = 0.
          ds1 = dsold*dtreal
        else
c---------note that dtreal has a different context outside of this subroutin
          if(ltouch) then
            amag = amag*rtouch
            alpha = 2.d0*coef7*dtreal*rtouch/amag
            beta2 = coef6*amag
            z = log(2.d0/abs(alpha)) / abs(beta2)
          else
            alpha = coef7*dtreal/amag
            beta2 = coef6*amag
c
            if(ftoldm.ne.0.) then
              z = ftoldm*fn/fnold1/amag
            else
c-----------an existing contact, but one with no tangential force
c           (usually corresponds to t=0 when startup is with an
c           E or D file).
              z = 1.d0
            endif
          endif
c
          if(alpha.eq.0.) then
            z = 1.d0
            goto 65
          endif
c
          beta2sh = beta2*beta2*0.5d0
          alpbet = alpha*beta2
c
c---------a trap in the event that z has been assigned an 
c         initial value less than zero.  A new value is assigned, 
c         based on approximate solutions of  alpha*sinh(beta2*z) = 1 :
          if(z.lt.0.) then
            if(abs(alpha).lt.1.d0) then
              itrack(1,rve) = itrack(1,rve) + 1
              z = log(2.d0/abs(alpha))/abs(beta2)
            else
              alphai = 1.d0/alpha
              if(abs(alphai).gt.1d-16) then
                z = (alphai - alphai**3 / 6.d0) / beta2
              else
                z = alphai/beta2
              endif
            endif
            if(z.ge.1.d0) then
              z = 1.d0
            elseif(z.lt.0.) then
              z = .00001d0
            endif
          endif
c
c---------a trap in the event that z has been assigned an 
c         initial value of one or greater
          if(z.ge.1.d0) z = 1.d0 - 1.d0/(1.d0 + 1.d0/alpbet)
c
          if(z.ge.1.d0) then
c---------another trap in case z is still .ge. 1.  
c         This might occur when alpbet is very small.
c
  159       if(z.eq.1.d0) z = 1.d0 - (1.d0 - z0)*0.5d0
c-----------set z to a value less than one, and use 
c           direct iteration to arrive closer to the solution.
            z0 = z
            zm = 1.d0 - z
            z1 = abs(beta2)*zm + 1.d0
            itrack(1,rve) = itrack(1,rve) + 1
            if(zm.gt.0.) then
              hi = -(z1 / (zm*(abs(beta2)*z - 
     x                         log(2.d0*zm/abs(alpha))))) +
     x              0.5d0/(zm*z1)
              z = z + 1.d0/hi
              if(abs(z0-z) .gt. 0.05d0*abs(z)) goto 159
            endif
          endif
c
c---------Newton's second order method . . .
c
  160     continue
c
c---------compute the argument, 'power', of the hyperbolic sine 
c         and cosine of beta2*z ("power").  When computing 
c         sinh(power), if previous values have already been computed 
c         (lold = 1), use the previous value of sinh(power) and 
c         the identity sinh(z + h) = sinh(z)cosh(h) + sinh(h)cosh(z).
c
          lh = .true.
          if(lold) then
            power = beta2*h
            apower = abs(power)
            csho = csh
            snho = snh
            if(apower.gt.83.d0) then
              power = beta2*z
              apower = abs(power)
              lold = .false.
            endif
          else
            power = beta2*z
            apower = abs(power)
          endif
c
c---------yet another trap that is entered when Newton's second 
c         order method has not converged after 5 iterations, 
c         or if exp(power) will lead to numeric overflow.
c
          if((itimes.eq.0 
     x        .and. (apower.gt.83.d0 .or. apower.eq.0.))
     x        .or. itimes.eq.6) then
            if(abs(alpha).lt.1.d0) then
              if(z.gt.0. .and. z.lt.1.d0) then
                z = log(2.d0*(1.d0-z)/abs(alpha))/abs(beta2)
              else
                itrack(1,rve) = itrack(1,rve) + 1
                z = log(2.d0/abs(alpha))/abs(beta2)
c here
              endif
            else
              alphai = 1.d0/alpha
              if(abs(alphai).gt.1d-16) then
                z = (alphai - alphai**3 / 6.d0) / beta2
              else
                z = alphai/beta2
              endif
            endif
c
            if(z.ge.1.d0) then
              z = 1.d0
            elseif(z.lt.0.) then
              z = .00001d0
            endif
            power = beta2*z
            apower = abs(power)
            lold = .false.
          endif
c
          if(apower.gt.83.d0) then
c---------a trap to avoid numeric overflow
            zo = z
            lold = .false.
            lh = .false.
c
            if(z.lt.0..or.z.ge.1.d0) then
              z = 0.
            else
              itrack(2,rve) = itrack(2,rve) + 1
              z = (log(2.d0*(1.d0-z)/abs(alpha)) 
     x             + 0.25d0*(alpha/(1.d0-z))**2)/abs(beta2)
              h = z - zo
              goto 64
            endif
c
            if(z.ge.1.d0) then
              z = 1.d0 - (1.d0 -z0)*0.50d0
              z0 = z
              zm = 1.d0 - z
              z1 = abs(beta2)*zm + 1.d0
              itrack(2,rve) = itrack(2,rve) + 1
              if(zm.gt.0.) then
                hi = -(z1 / (zm*(abs(beta2)*z - 
     x                       log(2.d0*zm/abs(alpha))))) +
     x               0.5d0/(zm*z1)
                h = 1.d0/hi
              endif
            endif
c---------compute sinh(power) and cosh(power), using approximate 
c         methods whenever possible
          elseif(apower.lt.1.d-30) then
            snh = 0.
            csh = 1.d0
          elseif(apower.lt.0.00025d0) then
c-----------use Taylor's series
            powerq = power**2
            snh = power
            csh = 1.d0 + powerq * 0.5d0
            if(apower.gt.2.5d-8) then
              snh = snh + powerq*power/6.d0
              csh = csh + powerq**2 / 24.d0
            endif
          else
c-----------use the intrinsic functions
            itrack(3,rve) = itrack(3,rve) + 1
            ex = exp(power)
            if(ex.eq.0.) then
              h = 2.d0/beta2
              lh = .false.
            else
              exi = 1.d0/ex
              snh = (ex - exi) * 0.5d0
              csh = (ex + exi) * 0.5d0
            endif
          endif
c
          if(lh) then
            if(lold) then
              snh1 = snh*csho + csh*snho
              csh = csh*csho + snh*snho
              snh = snh1
            else
              lold = .true.
            endif
c
            if(iexit.ge.1) goto 65
c
c-----------find the next value of z
            abcsh = 1.d0 + alpbet*csh
            asnh = alpha*snh
            abbsnh = beta2sh*asnh
            below = z - 1.d0 + asnh
            if(below.eq.0.) then
              h = 0.
            else
              hi = -(abcsh/below) + abbsnh/abcsh
            h = 1.d0/hi
            endif
          endif
c
          z = z + h
c
c---------the number of iterations
          itimes = itimes + 1
c
c---------check whether convergence has been achieved
   64     if(abs(h).gt.ptol*abs(z)) then
            if(itimes.gt.150.or.iexit.gt.10) then
c-------------the force did not converge after 150 iterations
              write(ScrUnit(rve),920) ftolds(1),ftolds(2),ftolds(3),
     x                     dsold,alpha,beta2,
     x                     igrain,jgrain,timer
            else
              goto 160
            endif
          else
            iexit = iexit + 1
            goto 160
          endif
c
   65     ftnew = amag*z
c
          if(.not.ltouch) then
c-  --------note that dtreal has a different context outside of this subroutin
c           ds1 = 2.d0*(amag - ftnew) / kthz
            ds1 = dtreal*coef5*sinh(coef4*ftnew/fn)
          elseif(rtouch.ne.0.) then
c           ds1 = (amag - ftnew)/kthz/rtouch
            ds1 = dtreal*coef5*sinh(coef4*ftnew/fn)
          elseif(lh) then
            ds1 = coef5*snh
          else
            ds1 = 0.
          endif
        endif
c
        ft(1) = ftim(1)*z
        ft(2) = ftim(2)*z
        ft(3) = ftim(3)*z
c
        fttot(1) = ft(1)
        fttot(2) = ft(2)
        fttot(3) = ft(3)
c
        if(.not.ltouch) then
          dviscc = 0.5d0*(ftoldm*dsold*dtreal
     x                   + ftnew*ds1)
        else
          dviscc = ftnew*ds1*rtouch
        endif
c
        viscc = viscc + dviscc
c
        return
c
  920 format(' The viscous slip did not converge after 150 iterations'
     x,/,' ftij/w = 1 - alpha*sinh(beta2*ftij/w)'
     x,/,' w=ftold+(dct-ds1old)*kth, alpha=c5/w, beta2=w*c6.'
     x,/,4x,'ftold =',3(1pd14.7),/,7x,'dct =',1pd14.7
     x,/,5x,'ds1old =',1pd14.7,/,10x,'w =',1pd14.7
     x,/,6x,'alpha =',1pd14.7,/,7x,'beta2 =',1pd14.7
     x,/,' contact between particles',i4,' and',i4,' at time',1pd14.7)
      end
c
c End Subroutins for Studying Creep Effects
c|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine wrkJag(znrgy1,znrgy2,rve)
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      double precision dXi(2),Ft_a(2),Ft_b(2),rmean2,znrgy1,znrgy2
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
      integer*4 i4,igrain,jgrain,ipt1,ipt3,j4,listJ,listk
      integer*2 iremov,islip2,rve
      logical ltouch
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-------compute the elastic energy in the set of Jager contacts
c
c-------we now approximate the elastic energy in the contact. This will
c       be done by considering each step of the equivalent load history
c       (working backwards through the history), as shown in Fig. 4b
c       of [3]. The elastic deformation during the actual load history
c       is equal to the elastic deformation along the equivalent history.
c       (The paper [3] states the cumulative total deformation is
c       the same as that of the equivalent history, which is wrong.)
c       We will approximate the elastic energy as the sum of increments
c       associated with each leg of the equivalent history.  The first
c       part of Eq. 4 of [3] gives the elastic displacement $\Delta\xi$
c       for each leg of the history.  The first part of Eq. 8 gives
c       the change in tangential force.  We will use Eq. 8 to find
c       the tangential force at each end of a leg of the history.
c       We use the average of the two forces, and muliply the average
c       force by the elastic displacement (as a dot product).  The method
c       is only approximate, since the relation between $\zeta$
c       and $F_n$ (which are used to find the tangential force and 
c       displacement) is a non-linear relation (see Eq. 1).
c
        znrgy1 = 0.
        znrgy2 = 0.
c
        do 820 igrain = 1,np(rve)
c
c---------the pointer to the first particle's location within the linked list.  
          ipt1 = igrain
c
c---------in this "do 90" loop, we search through the linked list for all
c         of the near-neighbors of igrain
          do 221 while (list2(ipt1,rve).ne.0)
c
c-----------the next pointer in igrain's list
            ipt1 = list2(ipt1,rve)
c
            jgrain = list1(ipt1,rve)
c
c-----------the pointer to the location of contact informaton in various
c           arrays.  ipt3 points to a particle pair that is in contact.
            ipt3 = liste(ipt1,rve)
c
c-----------were the two particles NOT touching at t-dt?
            ltouch = ipt3.eq.0
c
            if(.not.ltouch) then
c-------------if ipt=3, then set ipt5=3 as well
              if(.not.lconvx(rve)) then
c---------------with non-convex particles, we must look through the 
c               array "list" for all instance of contacts between the 
c               two particles
                j4 = liste(ipt1,rve)
c
                do 802 while (j4.ne.0)
                  Ft_b(1) = ftold(1,j4,rve)
                  Ft_b(2) = ftold(2,j4,rve)
                  i4 = listk(j4,rve)
c
c-----------------potential (elastic) energy stored in normal contact spring.
c                 No need to compute.
                  if(.false. .and. i4.ne.Zero) then
                    if(lJager(rve)) then
c---------------------Hertz-Mindlin contact between spherical surfaces.
c                     We must find the radius "R" in eq. 1 of [3].  We will
c                     use the values of Fn and zeta to find R
c                        Fn = Ebar * (sqrt(zeta * R))**3 / R
                      rmean2 = (Fn_s(i4,rve)/Ebar(rve))**2
     x                         / zeta_s(i4,rve)**3
c
c---------------------potential (elastic) energy stored in normal contact spring
                      znrgy1 = znrgy1
     x                      + Ebar23n(rve)
     x                        * (Fn_s(i4,rve)**5 / rmean2)**(1.d0/3.d0)
                    elseif(lJagr2(rve)) then
c---------------------Hertz-Mindlin contact between conical surfaces
                      znrgy1 = znrgy1
     x                         + Ebar43n(rve) * sqrt(Fn_s(i4,rve)**3)
                    elseif(lJagr4(rve)) then
c---------------------Hertz-Mindlin contact between surfaces having a general
c                     power-law profile
                      znrgy1 = znrgy1 
     x                         + Cn_1(rve)
     x                           * Fn_s(i4,rve)**
     x                              ((2.d0*palpha(rve)+1.d0)
     x                               /(palpha(rve)+1.d0))
                    endif
                  endif
c
                  do 227 while (i4.ne.Zero)
c-------------------Eq. 8_1 in the Jager paper (step 18 in the algorithm)
                    Ft_a(1) = Ft_b(1)
     x                        - p_s(i4,1,rve)
     x                          *(Fn_s(i4,rve)
     x                            - Fn_s(listJ(i4,rve),rve))
                    Ft_a(2) = Ft_b(2)
     x                        - p_s(i4,2,rve)
     x                          *(Fn_s(i4,rve)
     x                            - Fn_s(listJ(i4,rve),rve))
c-------------------Eq. 4_1 in the Jager paper (step 17 in the algorithm)
                    dXi(1) = p_s(i4,1,rve)*kappa(rve)
     x                       *(zeta_s(i4,rve)
     x                         - zeta_s(listJ(i4,rve),rve))
                    dXi(2) = p_s(i4,2,rve)*kappa(rve)
     x                       *(zeta_s(i4,rve)
     x                         - zeta_s(listJ(i4,rve),rve))
c
c-------------------Integrate Ft * dXi.  Use the average force (factor 0.5).
c                   Multiply by 2.0, since dXi is a half-movement.
                    dznrgy2 =   dXi(1)*(Ft_a(1) + Ft_b(1))
     x                        + dXi(2)*(Ft_a(2) + Ft_b(2))
c
                    znrgy2 = znrgy2 + dznrgy2
c
                    if(abs(dznrgy2).gt.8.e-10) then
                      continue
                    endif
c
                    Ft_b(1) = Ft_a(1)
                    Ft_b(2) = Ft_a(2)
c
                    i4 = listJ(i4,rve)
  227             continue
                  j4 = listf0(j4,rve)
  802           continue
              else
c---------------with convex particles, only one contact
c
c---------------We scan through the equivalent history of this contact.
c               Ft_b is the tangential force (in the local frame) at the
c               end of a history segment. Ft_a is the force at the start
c               of the segment.  We integrate Ft * dXi along this path.
                Ft_b(1) = ftold(1,ipt3,rve)
                Ft_b(2) = ftold(2,ipt3,rve)
                i4 = listk(ipt3,rve)
c
c---------------potential (elastic) energy stored in normal contact spring.
c               No need to compute
                if(.false. .and. i4.ne.Zero) then
                  if(lJager(rve)) then
c-------------------Hertz-Mindlin contact between spherical surfaces.
c                   We must find the radius "R" in eq. 1 of [3].  We will
c                   use the values of Fn and zeta to find R
c                      Fn = Ebar * (sqrt(zeta * R))**3 / R
                    rmean2 = (Fn_s(i4,rve)/Ebar(rve))**2
     x                       / zeta_s(i4,rve)**3
c
c-------------------potential (elastic) energy stored in normal contact spring
                    znrgy1 = znrgy1 
     x                       + Ebar23n(rve) 
     x                         * (Fn_s(i4,rve)**5 /rmean2)**(1.d0/3.d0)
                  elseif(lJagr2(rve)) then
c-------------------Hertz-Mindlin contact between conical surfaces
                    znrgy1 = znrgy1
     x                       + Ebar43n(rve) * sqrt(Fn_s(i4,rve)**3)
                  elseif(lJagr4(rve)) then
c-------------------Hertz-Mindlin contact between surfaces having a general
c                   power-law profile
                    znrgy1 = znrgy1
     x              + Cn_1(rve)
     x                *Fn_s(i4,rve)**((2.d0*palpha(rve)+1.d0)
     x                                      / (palpha(rve)+1.d0))
                  endif
                endif
c
                do 223 while (i4.ne.Zero)
c-----------------Eq. 8_1 in the Jager paper (step 18 in the algorithm)
                  Ft_a(1) = Ft_b(1) 
     x                      - p_s(i4,1,rve)
     x                        *(Fn_s(i4,rve)
     x                          - Fn_s(listJ(i4,rve),rve))
                  Ft_a(2) = Ft_b(2)
     x                      - p_s(i4,2,rve)
     x                        *(Fn_s(i4,rve)
     x                          - Fn_s(listJ(i4,rve),rve))
c-----------------Eq. 4_1 in the Jager paper (step 17 in the algorithm)
                  dXi(1) = p_s(i4,1,rve)*kappa(rve)
     x                     *(zeta_s(i4,rve)
     x                       - zeta_s(listJ(i4,rve),rve))
                  dXi(2) = p_s(i4,2,rve)*kappa(rve)
     x                     *(zeta_s(i4,rve)
     x                       - zeta_s(listJ(i4,rve),rve))
c
c-----------------Integrate Ft * dXi.  Use the average force (factor 0.5).
c                 Multiply by 2.0, since dXi is a half-movement.
                  dznrgy2 =   dXi(1)*(Ft_a(1) + Ft_b(1))
     x                      + dXi(2)*(Ft_a(2) + Ft_b(2))
c
                  znrgy2 = znrgy2 + dznrgy2
c
c-----------------reset the force at the end of the next segment
                  Ft_b(1) = Ft_a(1)
                  Ft_b(2) = Ft_a(2)
c
                  i4 = listJ(i4,rve)
  223           continue
              endif
            endif
  221     continue
  820   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine dummmy(rve)
c
c-----this subroutin consolidates the linked lists that are used with
c     the Jager contact model.  It removes holes in the linked lists and
c     reduces their length to a minimum
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4
      integer*4 listk, listJ, ilistJ
      integer*2 iremov,islip2,rve
c
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----consolidate the Jager linked lists.  Otherwise, use this subroutin
c     to take a consolidated list and append list pointers
c     if(lshrtn(rve)) then
c-------initialize scratch space
        do 10 i4 = Zero,mlistJ
c         listJS(i4) = 0
c         zeta_sS(i4) = 0.
c         Fn_sS(i4) = 0.
c         p_sS(i4,1) = 0.
c         p_sS(i4,2) = 0.
   10   continue
c
        ilistJ = 0
c     endif
c
c-----Use this subroutin to take a consolidated list and append list pointers
c
c-----embed internal pointers within the list
      do 140 i4 = listJ(Zero,rve),mlistJ-1
        listJ(i4,rve) = i4 + 1
  140 continue
c
      listJ(mlistJ,rve) = -1
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine consol(rve,nlistJ)
c
c-----this subroutin consolidates the linked lists that are used with
c     the Jager contact model.  It removes holes in the linked lists and
c     reduces their length to a minimum
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,igrain,jgrain,ipt1,ipt3,j4
      integer*4 listk, listJ, listJS, ilistJ, nlistJ
      integer*2 iremov,islip2,rve
      logical lJ1, ltouch
c
      double precision Fn_sS, p_sS, zeta_sS
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
      dimension listJS(Zero:mlistJ), 
     x          Fn_sS(Zero:mlistJ), p_sS(Zero:mlistJ,2), 
     x          zeta_sS(Zero:mlistJ)
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----consolidate the Jager linked lists.  Otherwise, use this subroutin
c     to take a consolidated list and append list pointers
      if(ishrtn(rve).eq.1) then
c-------initialize scratch space
        do 10 i4 = Zero,mlistJ
          listJS(i4) = 0
          zeta_sS(i4) = 0.
          Fn_sS(i4) = 0.
          p_sS(i4,1) = 0.
          p_sS(i4,2) = 0.
   10   continue
c
        ilistJ = 0
c
        do 100 igrain = 1,np(rve)
          ipt1 = igrain
          do 90 while (list2(ipt1,rve).ne.0)
            ipt1 = list2(ipt1,rve)
            jgrain = list1(ipt1,rve)
            ipt3 = liste(ipt1,rve)
c
c-----------were the two particles NOT touching at t-dt?
            ltouch = ipt3.eq.0
c
            if(.not.ltouch) then
c-------------if ipt=3, then set ipt5=3 as well
              if(.not.lconvx(rve)) then
c---------------with non-convex particles, we must look through the 
c               array "list" for all instance of contacts between the 
c               two particles
                j4 = liste(ipt1,rve)
c
                do 802 while (j4.ne.0)
                  i4 = listk(j4,rve)
                  lJ1 = .true.
c
                  do 227 while (i4.ne.Zero)
                    ilistJ = ilistJ + 1
                    if(lJ1) then
c---------------------for the top link list of this contact, 
c                     change the pointer listk
                      listk(j4,rve) = ilistJ
                      lJ1 = .false.
                    endif
c
c-------------------we create reordered and shortened lists. For example,
c                   creating zeta_sS to replace zeta_s, etc.:w
                    zeta_sS(ilistJ) = zeta_s(i4,rve)
                    Fn_sS(ilistJ) = Fn_s(i4,rve)
                    p_sS(ilistJ,1) = p_s(i4,1,rve)
                    p_sS(ilistJ,2) = p_s(i4,2,rve)
c
                    if(listJ(i4,rve).ne.Zero) then
                      listJS(ilistJ) = ilistJ + 1
                    else
                      listJS(ilistJ) = Zero
                    endif
c
                    i4 = listJ(i4,rve)
  227             continue
                  j4 = listf0(j4,rve)
  802           continue
              else
c---------------with convex particles, only one contact
                i4 = listk(ipt3,rve)
                lJ1 = .true.
c
                do 223 while (i4.ne.Zero)
                  ilistJ = ilistJ + 1
                  if(lJ1) then
                    listk(ipt3,rve) = ilistJ
                    lJ1 = .false.
                  endif
c
                  zeta_sS(ilistJ) = zeta_s(i4,rve)
                  Fn_sS(ilistJ) = Fn_s(i4,rve)
                  p_sS(ilistJ,1) = p_s(i4,1,rve)
                  p_sS(ilistJ,2) = p_s(i4,2,rve)
c
                  if(listJ(i4,rve).ne.Zero) then
                    listJS(ilistJ) = ilistJ + 1
                  else
                    listJS(ilistJ) = Zero
                  endif
c
                  i4 = listJ(i4,rve)
  223           continue
              endif
            endif
   90     continue
  100   continue
c
c-------erase entries in the original linked lists
        do 110 i4 = Zero,mlistJ
          listJ(i4,rve) = 0
          zeta_s(i4,rve) = 0.
          Fn_s(i4,rve) = 0.
          p_s(i4,1,rve) = 0.
          p_s(i4,2,rve) = 0.
  110   continue
c
c-------replace entries in the linked lists
        do 120 i4 = Zero,ilistJ
          listJ(i4,rve) = listJS(i4)
          zeta_s(i4,rve) = zeta_sS(i4)
          Fn_s(i4,rve) = Fn_sS(i4)
          p_s(i4,1,rve) = p_sS(i4,1)
          p_s(i4,2,rve) = p_sS(i4,2)
  120   continue
c
c-------pointer to the next available location in the list
        listJ(Zero,rve) = ilistJ + 1
      endif
c
c-----Use this subroutin to take a consolidated list and append list pointers
c
c-----embed internal pointers within the list
      do 140 i4 = listJ(Zero,rve),mlistJ-1
        listJ(i4,rve) = i4 + 1
  140 continue
c
      listJ(mlistJ,rve) = -1
c
      return
      end
c
c
      subroutine convrt(rve)
c
c-------this subroutin converts an older style of linked list (which used
c       variable ipt2 to mark the sart of unused space) to a newer
c       sytle that internally keeps track of the next unused space
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*4 i4,i4a,ipt1,listeo
        integer*2 rve
c
        dimension listeo(0:mlist2)
c
c-------with the older style of linked list, "ipt2" was the next
c       available location in list2(), and all positions in list2()
c       >=ipt2 were also available
        do 100 i4=ipt2,mlist-1
          list2(i4,rve) = i4 + 1
  100   continue
c
c-------the last unused space points to "-1", and will be used to
c       indicate that the linked list is expended and is insufficiently
c       large
        list2(mlist,rve) = -1
c
c-------the next available space is stored as list2(0)
        list2(0,rve) = ipt2
c
        if(lconvx(rve)) then
c---------for convex particles, which formerly used a listb() structure
          do 102 i4 = 0,mlist2
c-----------pointer to the location of contact information within
c           lists such as fnold(), etc.
            liste(i4,rve) = 0
c-----------lists of the component parts of the two particles for
c           composite particles
            listf1(i4,rve) = 0
            listf2(i4,rve) = 0
  102     continue
c
c---------initialize linked list
          do 104 i4 = 1,mlist2
            listf0(i4-1,rve) = i4
  104     continue
          listf0(mlist2,rve) = -1
c
          do 110 ipt1 = mfirst+1,mlist
c-----------convert to the new list type by placing the older listb()
c           information into a liste() list
            if(listb(ipt1,rve).ne.0) then
              liste(ipt1,rve) = listb(ipt1,rve)
              i4a = ipt1 - 1
              do 112 while(listf0(i4a,rve).ne.0)
                i4a = i4a -1
  112         continue
              listf0(i4a,rve) = listf0(ipt1,rve)
c-------------do we need to set listf1 and listf2 for ovals and ovoids?
              listf0(ipt1,rve) = 0
            endif
  110     continue
        else
c---------for non-convex composite particles, we remove the intermediate
c         listb() references, mapping list2() directly to the lists of
c         contact information
          do 122 ipt1=0,mlist2
            listeo(ipt1) = liste(ipt1,rve)
  122     continue
c
          do 120 ipt1 = mfirst+1,mlist
            if(listb(ipt1,rve).eq.0) then
              liste(ipt1,rve) = 0
            else
              liste(ipt1,rve) = listeo(listb(ipt1,rve))
            endif
  120     continue
        endif
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine stratn(rve)
c
c-----this subroutin straightens the equivalent load histories
c     of Jager contacts, so that each history has a single branch.
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 i4,i4tmp,igrain,jgrain,ipt1,ipt5
      integer*4 listk, listJ
      integer*2 rve
      integer*2 iremov,islip2
c
      double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s, p_s, p_s0, p_s1,
     x                 RJag,
     x                 zeta_o, zeta_s0, zeta_s1, zeta_s
c
c-----a common block for sharing information with the subroutins 
c     Jager3D and Jagr3D2, which are used with Jager's generalization 
c     of the Hertz-Mindlin contact
      common /Jager/ zeta_s(Zero:mlistJ,0:mrve), 
     x               Fn_s(Zero:mlistJ,0:mrve),
     x               p_s(Zero:mlistJ,2,0:mrve),
     x               zeta_s0(0:mlist2,0:mrve), 
     x               zeta_s1(0:mlist2,0:mrve),
     x               Fn_s0(0:mlist2,0:mrve), 
     x               Fn_s1(0:mlist2,0:mrve),
     x               p_s0(0:mlist2,2,0:mrve), 
     x               p_s1(0:mlist2,2,0:mrve),
     x               RJag(0:mlist2,0:mrve),
     x               Fn_o(0:mlist2,0:mrve),
     x               Ft_s(0:mlist2,2,2,0:mrve),
     x               zeta_o(0:mlist2,0:mrve),
     x               listJ(Zero:mlistJ,0:mrve), 
     x               listk(Zero:mlist2,0:mrve),
     x               iremov(0:mlist2,0:mrve), 
     x               islip2(0:mlist2,0:mrve)
c
c-----consolidate the Jager linked lists.  Otherwise, use this subroutin
c     to take a consolidated list and append list pointers
c     if(lstratn) then
        do 100 igrain = 1,np(rve)
          ipt1 = igrain
          do 90 while (list2(ipt1,rve).ne.0)
            ipt1 = list2(ipt1,rve)
            jgrain = list1(ipt1,rve)
            ipt5 = liste(ipt1,rve)
c
            do 802 while (ipt5.ne.0)
              i4 = listk(ipt5,rve)
c
              p_s(i4,1,rve) = ftold(1,ipt5,rve) / fnold1(ipt5,rve)
              p_s(i4,2,rve) = ftold(2,ipt5,rve) / fnold1(ipt5,rve)
c
              i4tmp = i4
              i4 = listJ(i4,rve)
              listJ(i4tmp,rve) = Zero
              do 227 while(i4.ne.Zero)
                p_s(i4,1,rve) = 0.
                p_s(i4,2,rve) = 0.
                Fn_s(i4,rve) = 0.
                zeta_s(i4,rve) = 0.
c
                i4tmp = i4
                i4 = listJ(i4,rve)
                listJ(i4tmp,rve) = listJ(Zero,rve)
                listJ(Zero,rve) = i4tmp
  227         continue
              if(lconvx(rve)) then
                ipt5 = 0
              else
                ipt5 = listf0(ipt5,rve)
              endif
  802       continue
   90     continue
  100   continue
c     endif
c
      return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine clonify(rve1,rve2)
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        integer*2 iremov, islip2, rve1,rve2
        integer*4 i, j, k, listk, listJ
        double precision Fn_o, Fn_s, Fn_s0, Fn_s1, Ft_s,
     x                   p_s, p_s0, p_s1, RJag,
     x                   zeta_o, zeta_s0, zeta_s1, zeta_s
c
c-------a common block for sharing information with the subroutins 
c       Jager3D and Jagr3D2, which are used with Jager's generalization 
c       of the Hertz-Mindlin contact
        common /Jager/ zeta_s(Zero:mlistJ,0:mrve),
     x                 Fn_s(Zero:mlistJ,0:mrve),
     x                 p_s(Zero:mlistJ,2,0:mrve),
     x                 zeta_s0(0:mlist2,0:mrve), 
     x                 zeta_s1(0:mlist2,0:mrve),
     x                 Fn_s0(0:mlist2,0:mrve), 
     x                 Fn_s1(0:mlist2,0:mrve),
     x                 p_s0(0:mlist2,2,0:mrve), 
     x                 p_s1(0:mlist2,2,0:mrve),
     x                 RJag(0:mlist2,0:mrve),
     x                 Fn_o(0:mlist2,0:mrve),
     x                 Ft_s(0:mlist2,2,2,0:mrve),
     x                 zeta_o(0:mlist2,0:mrve),
     x                 listJ(Zero:mlistJ,0:mrve),
     x                 listk(Zero:mlist2,0:mrve),
     x                 iremov(0:mlist2,0:mrve), 
     x                 islip2(0:mlist2,0:mrve)
c
        do 10 i =1,3
          ddefh(i,rve2) = ddefh(i,rve1)
          ianch(i,rve2) = ianch(i,rve1)
          ddefho(i,rve2) = ddefho(i,rve1)
          pcrit(i,rve2) = pcrit(i,rve1)
          stranc(i,rve2) = stranc(i,rve1)
          defup(i,rve2) = defup(i,rve1)
          nbox(i,rve2) = nbox(i,rve1)
          xcelle(i,rve2) = xcelle(i,rve1)
          iiso(i,rve2) = iiso(i,rve1)
          do 12 j = 1,3
            ddefme(i,j,rve2) = ddefme(i,j,rve1)
            def(i,j,rve2) = def(i,j,rve1)
            defo(i,j,rve2) = defo(i,j,rve1)
            defold(i,j,rve2) = defold(i,j,rve1)
            dxcell(i,j,rve2) = dxcell(i,j,rve1)
            stress(i,j,rve2) = stress(i,j,rve1)
            stres0(i,j,rve2) = stres0(i,j,rve1)
            strold(i,j,rve2) = strold(i,j,rve1)
            xcell(i,j,rve2) = xcell(i,j,rve1)
            xcelli(i,j,rve2) = xcelli(i,j,rve1)
            xcello(i,j,rve2) = xcello(i,j,rve1)
   12     continue
   10   continue
c
        tolrnc(1,rve2) = tolrnc(1,rve1)
        tolrnc(2,rve2) = tolrnc(2,rve1)
c
        do 20 i = 1,6
          countr(i,rve2) = countr(i,rve1)
   20   continue
c
        do 22 i = 1,7
          icont(i,rve2) = icont(i,rve1)
   22   continue
c
        do 24 i = 0,8
          defv(i,rve2) = defv(i,rve1)
          str(i,rve2) = str(i,rve1)
   24   continue
c
        do 26 i = 1,8
          iknown(i,rve2) = iknown(i,rve1)
          dstres(i,rve2) = dstres(i,rve1)
          ddef(i,rve2) = ddef(i,rve1)
          ip1cnt(i,rve2) = ip1cnt(i,rve1)
          ds(i,rve2) = ds(i,rve1)
          ip2cnt(i,rve2) = ip2cnt(i,rve1)
          streso(i,rve2) = streso(i,rve1)
          qdef(i,rve2) = qdef(i,rve1)
          s(i,rve2) = s(i,rve1)
          stro(i,rve2) = stro(i,rve1)
          streff(i,rve2) = streff(i,rve1)
          strtot(i,rve2) = strtot(i,rve1)
          isolve(i,rve2) = isolve(i,rve1)
          ltotal(i,rve2) = ltotal(i,rve1)
          ivctrl(i,rve2) = ivctrl(i,rve1)
          do 30 j = 1,8
            xi(i,j,rve2) = xi(i,j,rve1)
            yi(i,j,rve2) = yi(i,j,rve1)
            q(i,j,rve2) = q(i,j,rve1)
            qi(i,j,rve2) = qi(i,j,rve1)
            q_alt(i,j,rve2) = q_alt(i,j,rve1)
   30     continue

          do 32 j = 0,lc1
            defrat(i,j,rve2) = defrat(i,j,rve1)
   32     continue
   26   continue
c
        do 36 i = 1,mdim1
          cbeta(i,rve2) = cbeta(i,rve1)
   36   continue
c
        do 38 i = 1,mparts
          cosa(i,1,rve2) = cosa(i,1,rve1)
          cosa(i,2,rve2) = cosa(i,2,rve1)
          cosa(i,3,rve2) = cosa(i,3,rve1)
   38   continue
c
        do 40 i = 0,lc1
          defdot(i,rve2) = defdot(i,rve1)
          finalv(i,rve2) = finalv(i,rve1)
          icontp(i,rve2) = icontp(i,rve1)
          icontr(i,rve2) = icontr(i,rve1)
          idump(i,rve2) = idump(i,rve1)
          igoal(i,rve2) = igoal(i,rve1)
          imicro(i,rve2) = imicro(i,rve1)
          iplot(i,rve2) = iplot(i,rve1)
          ipts2(i,rve2) = ipts2(i,rve1)
          ipts(i,rve2) = ipts(i,rve1)
          krotat(i,rve2) = krotat(i,rve1)
          vrate(i,rve2) = vrate(i,rve1)
c
          do 42 j = 1,8
            defrat(j,i,rve2) = defrat(j,i,rve1)
   42     continue
   40   continue
c
        do 50 i = 0,mlist2
          dsold1(i,rve2) = dsold1(i,rve1)
          fnold1(i,rve2) = fnold1(i,rve1)
          lplold(i,rve2) = lplold(i,rve1)
          f1(i,rve2) = f1(i,rve1)
          f2(i,rve2) = f2(i,rve1)
          liste(i,rve2) = liste(i,rve1)
          listf0(i,rve2) = listf0(i,rve1)
          p1(i,rve2) = p1(i,rve1)
          p2(i,rve2) = p2(i,rve1)
          v1(i,rve2) = v1(i,rve1)
          v2(i,rve2) = v2(i,rve1)
          Tstar(i,rve2) = Tstar(i,rve1)
          ifn_togl(i,rve2) = ifn_togl(i,rve1)
          islip(i,rve2) = islip(i,rve1)
          listf1(i,rve2) = listf1(i,rve1)
          listf2(i,rve2) = listf2(i,rve1)
c
          do 52 j = 1,mdim1
            ftold(j,i,rve2) = ftold(j,i,rve1)
            l_i_old(j,i,rve2) = l_i_old(j,i,rve1)
   52     continue
c
          do 54 j = 1,2
            quad(j,i,rve2) = quad(j,i,rve1)
            cosxl(j,i,rve2) = cosxl(j,i,rve1)
            branch(j,i,rve2) = branch(j,i,rve1)
   54     continue
          c_etas(1,i,rve2) = c_etas(1,i,rve1)
          c_etas(2,i,rve2) = c_etas(2,i,rve1)
          c_etas(3,i,rve2) = c_etas(3,i,rve1)
c
          Qc_old(1,i,rve2) = Qc_old(1,i,rve1)
          Qc_old(2,i,rve2) = Qc_old(2,i,rve1)
          Qc_old(3,i,rve2) = Qc_old(3,i,rve1)
          Qc_old(4,i,rve2) = Qc_old(4,i,rve1)
   50   continue
c
        do 56 i = 1,mlist2
          xi_old(1,i,rve2) = xi_old(1,i,rve1)
          xi_old(2,i,rve2) = xi_old(2,i,rve1)
   56   continue
c
        do 60 i = 1,mstack
          do 62 j = 1,8+mdiff
            dsfals(j,i,rve2) = dsfals(j,i,rve1)
            dsreal(j,i,rve2) = dsreal(j,i,rve1)
   62     continue
   60   continue
c
        do 64 i = 0,mbumps
          b_rad(i,rve2) = b_rad(i,rve1)
          s_rad(i,rve2) = s_rad(i,rve1)
          do 66 j = 1,3
            xlocal(i,j,rve2) = xlocal(i,j,rve1)
   66     continue
   64   continue
c
        do 70 i = 1,mboxes
          boxi(i,1,rve2) = boxi(i,1,rve1)
          boxi(i,2,rve2) = boxi(i,2,rve1)
          boxi(i,3,rve2) = boxi(i,3,rve1)
   70   continue
c
        do 80 i = 0,mbox1-1
          do 82 j = 0,mbox2-1
            do 84 k = 0,mbox3-1
              box(i,j,k,rve2) = box(i,j,k,rve1)
   84       continue
   82     continue
   80   continue
c
        do 86 i = 1,mbx
          iptbx1(i,rve2) = iptbx1(i,rve1)
          iptbx2(i,rve2) = iptbx2(i,rve1)
   86   continue
c
        do 90 i = 1,mcells
          hf(i,rve2) = hf(i,rve1)
   90   continue
c
        do 92 i = mfirst+1,mlist
          list1(i,rve2) = list1(i,rve1)
          listb(i,rve2) = listb(i,rve1)
          do 94 j = -1,mlist3
            list3(i,j,rve2) = list3(i,j,rve1)
   94     continue
   92   continue

        do 100 i = 0,mlist
          list2(i,rve2) = list2(i,rve1)
  100   continue
c
        do 110 i = 1,mp
          aspect(i,rve2) = aspect(i,rve1)
          rad(i,rve2) = rad(i,rve1)
          tempr(i,rve2) = tempr(i,rve1)
          v_p(i,rve2) = v_p(i,rve1)
          vmnt_p(i,rve2) = vmnt_p(i,rve1)
          hv(i,rve2) = hv(i,rve1)
          nabors(i,rve2) = nabors(i,rve1)
          nslidc(i,rve2) = nslidc(i,rve1)
          mass(i,rve2) = mass(i,rve1)
          mnt(i,rve2) = mnt(i,rve1)
          mnt2(i,rve2) = mnt2(i,rve1)
c
          do 112 j = 1,3
            a_vect(j,i,rve2) = a_vect(j,i,rve1)
            gamma_(j,i,rve2) = gamma_(j,i,rve1)
  112     continue
c
          do 114 j = 1,mdim1
            ctheta(j,i,rve2) = ctheta(j,i,rve1)
            dx(j,i,rve2) = dx(j,i,rve1)
            f(j,i,rve2) = f(j,i,rve1)
            vh(j,i,rve2) = vh(j,i,rve1)
            xp(j,i,rve2) = xp(j,i,rve1)
            xmove(j,i,rve2) = xmove(j,i,rve1)
  114     continue
c
          do 116 j = 1,4
            Qp(j,i,rve2) = Qp(j,i,rve1)
            r_piec(j,i,rve2) = r_piec(j,i,rve1)
  116     continue
c
          do 118 j = mdim2,3
            theta(j,i,rve2) = theta(j,i,rve1)
            thmove(j,i,rve2) = thmove(j,i,rve1)
            vhth(j,i,rve2) = vhth(j,i,rve1)
            fth(j,i,rve2) = fth(j,i,rve1)
            ddth(j,i,rve2) = ddth(j,i,rve1)
            dth(j,i,rve2) = dth(j,i,rve1)
  118     continue
  110   continue
c
        dtfctr(rve2) = dtfctr(rve1)
        A_1(rve2) = A_1(rve1)
        adtm(rve2) = adtm(rve1)
        ambtmp(rve2) = ambtmp(rve1)
        athdtm(rve2) = athdtm(rve1)
        avasp(rve2) = avasp(rve1)
        beta(rve2) = beta(rve1)
        betar(rve2) = betar(rve1)
        C_11nu(rve2) = C_11nu(rve1)
        cenrad(rve2) = cenrad(rve1)
        chi1(rve2) = chi1(rve1)
        chi1t(rve2) = chi1t(rve1)
        chia1(rve2) = chia1(rve1)
        chi2(rve2) = chi2(rve1)
        chi2t(rve2) = chi2t(rve1)
        chi3(rve2) = chi3(rve1)
        chi3t(rve2) = chi3t(rve1)
        chi4(rve2) = chi4(rve1)
        chi4t(rve2) = chi4t(rve1)
        chiavg(rve2) = chiavg(rve1)
        chimax(rve2) = chimax(rve1)
        cirrad(rve2) = cirrad(rve1)
        Cn(rve2) = Cn(rve1)
        Cn_1(rve2) = Cn_1(rve1)
        D_o(rve2) = D_o(rve1)
        dampc1(rve2) = dampc1(rve1)
        dampc2(rve2) = dampc2(rve1)
        damp1(rve2) = damp1(rve1)
        damp2(rve2) = damp2(rve1)
        dbegin(rve2) = dbegin(rve1)
        defw(rve2) =  defw(rve1)
        defwold(rve2) =  defwold(rve1)
        dele(rve2) = dele(rve1)
        Dlast(rve2) = Dlast(rve1)
        dpfluid(rve2) = dpfluid(rve1)
        dslide(rve2) = dslide(rve1)
        dslidet(rve2) = dslidet(rve1)
        dt(rve2) = dt(rve1)
        dtinp(rve2) = dtinp(rve1)
        dtreal(rve2) = dtreal(rve1)
        dtrlo(rve2) = dtrlo(rve1)
        dvctrl(rve2) = dvctrl(rve1)
        dxym(rve2) = dxym(rve1)
        Ebar(rve2) = Ebar(rve1)
        Ebar23n(rve2) = Ebar23n(rve1)
        Ebar43n(rve2) = Ebar43n(rve1)
        etargt(rve2) = etargt(rve1)
        fbalsq(rve2) = fbalsq(rve1)
        fdampa(rve2) = fdampa(rve1)
        fk2(rve2) = fk2(rve1)
        fnavg(rve2) = fnavg(rve1)
        fnavg2(rve2) = fnavg2(rve1)
        fpnrgy(rve2) = fpnrgy(rve1)
        frict(rve2) = frict(rve1)
        frict_sav(rve2) = frict_sav(rve1)
        frictm(rve2) = frictm(rve1)
        frictw(rve2) = frictw(rve1)
        frict2(rve2) = frict2(rve1)
        ftsq(rve2) = ftsq(rve1)
        G(rve2) = G(rve1)
        gamm(rve2) = gamm(rve1)
        gmod(rve2) = gmod(rve1)
        Gbar(rve2) = Gbar(rve1)
        h_rho(rve2) = h_rho(rve1)
        Hcc(rve2) = Hcc(rve1)
        Iavg(rve2) = Iavg(rve1)
        iporo(rve2) = iporo(rve1)
        Imean(rve2) = Imean(rve1)
        kappa(rve2) = kappa(rve1)
        K_f(rve2) = K_f(rve1)
        K_s(rve2) = K_s(rve1)
        kbulk(rve2) = kbulk(rve1)
        kn(rve2) = kn(rve1)
        knh(rve2) = knh(rve1)
        knmax(rve2) = knmax(rve1)
        knrgy(rve2) = knrgy(rve1)
        knrgyo(rve2) = knrgyo(rve1)
        knsep2(rve2) = knsep2(rve1)
        knseph(rve2) = knseph(rve1)
        kratio(rve2) = kratio(rve1)
        kt(rve2) = kt(rve1)
        kth(rve2) = kth(rve1)
        kthh(rve2) = kthh(rve1)
        lambda(rve2) = lambda(rve1)
        ldrain(rve2) = ldrain(rve1)
        linitf(rve2) = linitf(rve1)
        lporo(rve2) = lporo(rve1)
        lquez(rve2) = lquez(rve1)
        massav(rve2) = massav(rve1)
        massd(rve2) = massd(rve1)
        massit(rve2) = massit(rve1)
        mntav(rve2) = mntav(rve1)
        mntit(rve2) = mntit(rve1)
        N_o(rve2) = N_o(rve1)
        n1(rve2) = n1(rve1)
        nu(rve2) = nu(rve1)
        ovravg(rve2) = ovravg(rve1)
        ovravgz(rve2) = ovravgz(rve1)
        ovrsav(rve2) = ovrsav(rve1)
        ovrsavz(rve2) = ovrsavz(rve1)
        p_atm(rve2) = p_atm(rve1)
        p_o(rve2) = p_o(rve1)
        p_vap(rve2) = p_vap(rve1)
        p_wcav(rve2) = p_wcav(rve1)
        palpha(rve2) = palpha(rve1)
        pdif(rve2) = pdif(rve1)
        pdifsv(rve2) = pdifsv(rve1)
        pdif2(rve2) = pdif2(rve1)
        pfluid(rve2) = pfluid(rve1)
        pfluido(rve2) = pfluido(rve1)
        picpt1(rve2) = picpt1(rve1)
        picpt2(rve2) = picpt2(rve1)
        pn(rve2) = pn(rve1)
        pnrgy(rve2) = pnrgy(rve1)
        pnrgy1(rve2) = pnrgy1(rve1)
        pnrgy2(rve2) = pnrgy2(rve1)
        pnrgy2o(rve2) = pnrgy2o(rve1)
        pnrgy2o_alt(rve2) = pnrgy2o_alt(rve1)
        poros0(rve2) = poros0(rve1)
        porosn(rve2) = porosn(rve1)
        psep1(rve2) = psep1(rve1)
        psep2(rve2) = psep2(rve1)
        psi(rve2) = psi(rve1)
        ptol(rve2) = ptol(rve1)
        ravg(rve2) = ravg(rve1)
        rdampa(rve2) = rdampa(rve1)
        rfact1(rve2) = rfact1(rve1)
        rfact2(rve2) = rfact2(rve1)
        rho(rve2) = rho(rve1)
        rhoinp(rve2) = rhoinp(rve1)
        rin(rve2) = rin(rve1)
        rmax(rve2) = rmax(rve1)
        rmax2(rve2) = rmax2(rve1)
        rmin(rve2) = rmin(rve1)
        rmsvel(rve2) = rmsvel(rve1)
        rout(rve2) = rout(rve1)
        rpcmin(rve2) = rpcmin(rve1)
        S_now(rve2) = S_now(rve1)
        S_o(rve2) = S_o(rve1)
        satrad(rve2) = satrad(rve1)
        sep(rve2) = sep(rve1)
        seprat0(rve2) = seprat0(rve1)
        slidet(rve2) = slidet(rve1)
        slidet_alt(rve2) = slidet_alt(rve1)
        solidr(rve2) = solidr(rve1)
        spheat(rve2) = spheat(rve1)
        spnrgy(rve2) = spnrgy(rve1)
        srint(rve2) = srint(rve1)
        stravg(rve2) = stravg(rve1)
        strwold(rve2) = strwold(rve1)
        sweep(rve2) = sweep(rve1)
        tclock(rve2) = tclock(rve1)
        tclokm(rve2) = tclokm(rve1)
        tdampa(rve2) = tdampa(rve1)
        tdepf(rve2) = tdepf(rve1)
        temprt(rve2) = temprt(rve1)
        tfact1(rve2) = tfact1(rve1)
        tfact2(rve2) = tfact2(rve1)
        thblsq(rve2) = thblsq(rve1)
        timer(rve2) = timer(rve1)
        tmax(rve2) = tmax(rve1)
        treal(rve2) = treal(rve1)
        u_wcav(rve2) = u_wcav(rve1)
        vcell(rve2) = vcell(rve1)
        vcelli(rve2) = vcelli(rve1)
        vcell0(rve2) = vcell0(rve1)
        vcello(rve2) = vcello(rve1)
        vcellt(rve2) = vcellt(rve1)
        viscbt(rve2) = viscbt(rve1)
        viscct(rve2) = viscct(rve1)
        voidn(rve2) = voidn(rve1)
        volavg(rve2) = volavg(rve1)
        volmin(rve2) = volmin(rve1)
        VolumQ(rve2) = VolumQ(rve1)
        vs(rve2) = vs(rve1)
        vso(rve2) = vso(rve1)
        work1t(rve2) = work1t(rve1)
        workc(rve2) = workc(rve1)
        xpnts(rve2) = xpnts(rve1)
        xseed(rve2) = xseed(rve1)
        title(rve2) = title(rve1)
        cstep(rve2) = cstep(rve1)
        file1(rve2) = file1(rve1)
        file2(rve2) = file2(rve1)
        file3(rve2) = file3(rve1)
        partyp(rve2) = partyp(rve1)
        apend(rve2) = apend(rve1)
        StartFilePath(rve2) = StartFilePath(rve1)
        lanch(rve2) = lanch(rve1)
        lApprox(rve2) = lApprox(rve1)
        laxsym(rve2) = laxsym(rve1)
        lbumpy(rve2) = lbumpy(rve1)
        lcdamp(rve2) = lcdamp(rve1)
        lcircl(rve2) = lcircl(rve1)
        lcirc1(rve2) = lcirc1(rve1)
        lcirc2(rve2) = lcirc2(rve1)
        lcirc3(rve2) = lcirc3(rve1)
        lcirct(rve2) = lcirct(rve1)
        lconvx(rve2) = lconvx(rve1)
        lelips(rve2) = lelips(rve1)
        lflag1(rve2) = lflag1(rve1)
        lfrict(rve2) = lfrict(rve1)
        lgrav(rve2) = lgrav(rve1)
        lHertz(rve2) = lHertz(rve1)
        lhiddn(rve2) = lhiddn(rve1)
        linit(rve2) = linit(rve1)
        linitc(rve2) = linitc(rve1)
        liso(rve2) = liso(rve1)
        liso2(rve2) = liso2(rve1)
        lJager(rve2) = lJager(rve1)
        lJagr2(rve2) = lJagr2(rve1)
        lJagr3(rve2) = lJagr3(rve1)
        lJagr4(rve2) = lJagr4(rve1)
        llast(rve2) = llast(rve1)
        lmove(rve2) = lmove(rve1)
        lnew(rve2) = lnew(rve1)
        lnewc(rve2) = lnewc(rve1)
        lnewdt(rve2) = lnewdt(rve1)
        lnobby(rve2) = lnobby(rve1)
        loval(rve2) = loval(rve1)
        lovoid(rve2) = lovoid(rve1)
        lplotd(rve2) = lplotd(rve1)
        lqcntr(rve2) = lqcntr(rve1)
        lreprt(rve2) = lreprt(rve1)
        lreset(rve2) = lreset(rve1)
        lrotat(rve2) = lrotat(rve1)
        ishrtn(rve2) = ishrtn(rve1)
        lsinh(rve2) = lsinh(rve1)
        lspher(rve2) = lspher(rve1)
        lsphr(rve2) = lsphr(rve1)
        ltheta(rve2) = ltheta(rve1)
        lupdat(rve2) = lupdat(rve1)
        lvctrl(rve2) = lvctrl(rve1)
        lxiold(rve2) = lxiold(rve1)
        itime(rve2) = itime(rve1)
        lfaces(rve2) = lfaces(rve1)
        loopst(rve2) = loopst(rve1)
        medges(rve2) = medges(rve1)
        iouti(rve2) = iouti(rve1)
        ipoint(rve2) = ipoint(rve1)
        ipt4(rve2) = ipt4(rve1)
        nboxes(rve2) = nboxes(rve1)
        ncells(rve2) = ncells(rve1)
        nerror(rve2) = nerror(rve1)
        nfilled(rve2) = nfilled(rve1)
        nnear(rve2) = nnear(rve1)
        np(rve2) = np(rve1)
        npiece(rve2) = npiece(rve1)
        nslide(rve2) = nslide(rve1)
        ntacts(rve2) = ntacts(rve1)
        ntactz(rve2) = ntactz(rve1)
        nupdat4(rve2) = nupdat4(rve1)
        nverts(rve2) = nverts(rve1)
        AUnit(rve2) = AUnit(rve1)
        BUnit(rve2) = BUnit(rve1)
        ErrUnit(rve2) = ErrUnit(rve1)
        nbumps(rve2) = nbumps(rve1)
        ScrUnit(rve2) = ScrUnit(rve1)
        hmodel(rve2) = hmodel(rve1)
        idamp(rve2) = idamp(rve1)
        idumpi(rve2) = idumpi(rve1)
        idef(rve2) = idef(rve1)
        iend(rve2) = iend(rve1)
        ifrctnl(rve2) = ifrctnl(rve1)
        igoala(rve2) = igoala(rve1)
        igoalb(rve2) = igoalb(rve1)
        iheat(rve2) = iheat(rve1)
        imodel(rve2) = imodel(rve1)
        iqcntr(rve2) = iqcntr(rve1)
        istart(rve2) = istart(rve1)
        istep(rve2) = istep(rve1)
        istep2(rve2) = istep2(rve1)
        istepa(rve2) = istepa(rve1)
        istepm(rve2) = istepm(rve1)
        itxt(rve2) = itxt(rve1)
        iupdat(rve2) = iupdat(rve1)
        iupdtm(rve2) = iupdtm(rve1)
        kshape(rve2) = kshape(rve1)
        lpsxcd(rve2) = lpsxcd(rve1)
        ndiams(rve2) = ndiams(rve1)
        nfacts(rve2) = nfacts(rve1)
        niso(rve2) = niso(rve1)
        njoin(rve2) = njoin(rve1)
        nknown(rve2) = nknown(rve1)
        nobs(rve2) = nobs(rve1)
        np1(rve2) = np1(rve1)
        npiecs(rve2) = npiecs(rve1)
        nsolve(rve2) = nsolve(rve1)
        nupdat(rve2) = nupdat(rve1)
c
        lbody(1,rve2) = lbody(1,rve1)
        lbody(2,rve2) = lbody(2,rve1)
c
        do 140 i = 0,mlistJ
          zeta_s(i,rve2) = zeta_s(i,rve1)
          Fn_s(i,rve2) = Fn_s(i,rve1)
          p_s(i,1,rve2) = p_s(i,1,rve1)
          p_s(i,2,rve2) = p_s(i,2,rve1)
          listJ(i,rve2) = listJ(i,rve1)
  140   continue
c
        do 150 i = 0,mlist2
          zeta_s0(i,rve2) = zeta_s0(i,rve1)
          zeta_s1(i,rve2) = zeta_s1(i,rve1)
          Fn_s0(i,rve2) = Fn_s0(i,rve1)
          Fn_s1(i,rve2) = Fn_s1(i,rve1)
          RJag(i,rve2) = RJag(i,rve1)
          Fn_o(i,rve2) = Fn_o(i,rve1)
          zeta_o(i,rve2) = zeta_o(i,rve1)
          listk(i,rve2) = listk(i,rve1)
          iremov(i,rve2) = iremov(i,rve1)
          islip2(i,rve2) = islip2(i,rve1)
c
          p_s0(i,1,rve2) = p_s0(i,1,rve1)
          p_s0(i,2,rve2) = p_s0(i,2,rve1)
          p_s1(i,1,rve2) = p_s1(i,1,rve1)
          p_s1(i,2,rve2) = p_s1(i,2,rve1)
c
          Ft_s(i,1,1,rve2) = Ft_s(i,1,1,rve1)
          Ft_s(i,1,2,rve2) = Ft_s(i,1,2,rve1)
          Ft_s(i,2,1,rve2) = Ft_s(i,2,1,rve1)
          Ft_s(i,2,2,rve2) = Ft_s(i,2,2,rve1)
  150   continue
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine readit2(rve,istartchng,filename1,filename2,extent)
c
c-----this subroutin reads the input files for the simulation
c
      include 'param-dempla-0.2.2.f'
      include 'common-dempla-0.2.2.f'
c
      double precision rfree
      integer*2 extent,i,ibodyf,ifree,istartchng,
     x          rve,nplatn,TempUnit
c
c-----these integers will be too large for integer*2 with large assemblies
      integer*4 igrain,i4
c
      character*400 filename1
      character*400 filename2
      character*800 filename
c
      dimension ibodyf(0:lc1),ifree(100),rfree(100)
c
c-----this subroutin gets necessary input data from two files.  The first
c     file (the RunFile) gives general particle characterists, stress-strain 
c     control parameters, input and output formats, etc.  
c     The second file gives (the StartFile) the starting configuration 
c     of the assembly, with initial particle sizes, orientations, and 
c     positions.
c
c-----explanation of file numbers.  For each rve, we reserve 5 file
c     numbers:
c        unit = 10 + rve*5 + 0  temporary files for input and output
c        unit = 10 + rve*5 + 1  "A"-file, output
c        unit = 10 + rve*5 + 2  "B"-file, output
c        unit = 10 + rve*5 + 3  "S"-file, screen output
c        unit = 10 + rve*5 + 4  "R"-file, error output
c
      TempUnit = 10 + 5*rve + 0
c
c-----read the entire RunFile
c     extent = 0
c
c-----new RunFile format for DEMPLA.  Set .false. for OVAL RunFiles
c     lnewread = .true.
c
c-----open the first input file (the RunFile) . . . .
      open(unit=TempUnit,file=filename1,status='old')
c
c-----read the first line of the RunFile
      read(TempUnit,201) title(rve)
c
c-----read program parameters in the RunFile
      read(TempUnit,203) algori,ivers(rve),ncownt,iout(2),iout(3)
     x           ,istart(rve),iend(rve),idef(rve),iupdtm(rve)
     x           ,icirct
     x           ,imodel(rve),nplatn,nloop1
c
c-----if istartchng>0 then we change the type of StartFile that was
c     given in the RunFile
      if(istartchng.ge.0) then
        istart(rve) = istartchng
      endif
c
c-----whether to use poroelastic analysis, which accounts for
c     pore fluid compressibility and allows the calculation of both
c     total and effective (intergranular) stresses
      iporo(rve) = 0
c
c-----if ivers=3 or ivers=4 (on the 3rd line of the RunFile), then the 
c     RunFile must contain an additional five lines (or more) of integer
c     input.  These are place holders for future options.  I have already 
c     found a use for ifree1, ifree2, and ifree3 (now imodel, nplatn, and
c     nloop1), so I am kluging with "ivers" to add more options
c     in the future.  When ivers=4, then the RunFile must also contain
c     an additional eight lines of floating point input (later ....)
      if(ivers(rve).eq.3 .or. ivers(rve).eq.4 .or. ivers(rve).eq.5 
     x   .or.ivers(rve).eq.6) then
c-------read this additional data from the RunFile
        read(TempUnit,204) iexact,isub,idamp(rve),iheat(rve),icoef
c
        if(ivers(rve).eq.5 .or. ivers(rve).eq.6) then
c---------read this additional data from the RunFile, concerning
c         poroelastic analysis.  If iporo=1, then we computed pore
c         fluid pressure.  When the StartFile is a "D"-file, then
c         we must provide the initial pore fluid pressure, p_o.
c         When the StartFile is a "C"-file, then the pore fluid pressure
c         in inherited from a previous run and is contained in the "C"-file
          read(TempUnit,208) iporo(rve)
        endif
c
        if(ivers(rve).eq.6) then
c---------place-holders for 8 future input variables
          read(TempUnit,209) ifree(11),ifree(12),ifree(13),ifree(14),
     x                ifree(15),ifree(16),ifree(17),ifree(18)
        endif
      elseif(ivers(rve).eq.0 .or. ivers(rve).eq.1) then
        iexact = 0
        isub = 0
        idamp(rve) = 1
        iheat(rve) = 0
        icoef = 0
      else
c-------oops, print an error message and stop
        write(ScrUnit(rve),*) ' '
        write(ScrUnit(rve),*) '**** Error ****.'
        write(ScrUnit(rve),*)
     x    '* The input value of ivers must be 0, 1, 3, or 4'
        write(ScrUnit(rve),*) '* Your value:',ivers(rve)
        stop
      endif
c
c-----now read Double Precision input from the RunFile
      read(TempUnit,205) kn(rve),kratio(rve),frict(rve),frictw(rve)
     x           ,rho(rve),sep(rve)
     x           ,pcrit(1,rve),pcrit(2,rve),pcrit(3,rve)
     x           ,xseed(rve),rmsvel(rve),pdif(rve),tmax(rve)
     x           ,A_1(rve),dt(rve)
c
c-----give default (zero) values to these variables
      gravty(1) = 0.
      gravty(2) = 0.
      gravty(3) = 0.
      rfree(4) = 0.
      rfree(5) = 0.
      rfree(6) = 0.
      rfree(7) = 0.
      rfree(8) = 0.
c
c-----if ivers=4, then read an additional eight lines of floating point input.
c     See the explanation given above.
      if(ivers(rve).eq.4 .or. ivers(rve).eq.5 .or. ivers(rve).eq.6) then
c-------read this additional data from the RunFile
        read(TempUnit,206) gravty(1), gravty(2), gravty(3), 
     x              rfree(4), rfree(5), rfree(6), rfree(7), rfree(8)
        if(     iporo(rve).eq.1 
     x     .or. iporo(rve).eq.2 .or. iporo(rve).eq.3
     x     .or. iporo(rve).eq.4) then
c---------poroelastic information.  Note that if the StartFile is a 
c         "C"-file, then this information (although read) is ignored, 
c         and it is replaced with information in the StartFile
c
c---------initial fluid pressure, with poroelastic analysis
          p_o(rve) = rfree(4)
c---------bulk modulus of the solid grains
          K_s(rve) = rfree(5)
        endif
c
        if(     iporo(rve).eq.1
     x     .or. iporo(rve).eq.2 .or. iporo(rve).eq.3) then
c---------bulk modulus of the pore fluid. For models iporo=2 and iporo=3,
c         this is the bulk modulus of the pore fluid's liquid phase
          K_f(rve) = rfree(6)
        endif
c
        if(     iporo(rve).eq.2 .or. iporo(rve).eq.3 
     x     .or. iporo(rve).eq.4) then
c---------more poroelastic information
c
c---------the pore fluid's saturation wiith the liquid phase
          S_o(rve) = rfree(7)
c
c---------the atmospheric pressure for use with models iporo=2 and iporo=3
          p_atm(rve) = rfree(8)
        endif
      endif
c
      if(ivers(rve).eq.6) then
c---------more information  Note that if the StartFile is a 
c         "C"-file, then this information is ignored, and it is obtained
c         from the StartFile
        read(TempUnit,214) rfree(9), rfree(10), rfree(11), rfree(12), 
     x              rfree(13), rfree(14), rfree(15), rfree(16), 
     x              rfree(17), rfree(18)
c
        if(iporo(rve).eq.3) then
c---------poroelastic information about the pore size, gas dissolution,
c         and surface tension.   Note that if the StartFile is a 
c         "C"-file, then this information (although it is read) is ignored,
c         and it is replace by information in the StartFile
c
c---------dimensionless Henry's coefficient for the dissolution of
c         bubble gas in the liquid phase of the pore fluid
          Hcc(rve) = rfree(9)
c
c---------surface tension at the interface of gas bubbles and liquid
c         phase of the pore fluid
          gamm(rve) = rfree(10)
c
c---------the diameter of gas bubbles, which are assumed to be of equal size
          D_o(rve) = rfree(11)
c
c---------the number/density of gas bubbles per unit of original pore volume
          N_o(rve) = rfree(12)
c
c---------the number/density of gas bubbles per unit of original pore volume
          p_vap(rve) = rfree(13)
c
c---------the number/density of gas bubbles per unit of original pore volume
          p_wcav(rve) = rfree(14)
        endif
      elseif(ivers(rve).lt.6 .and. iporo(rve).ge.3) then
        write(ScrUnit(rve),*) ' '
        write(ScrUnit(rve),*) '**** Error in RunFile ****.'
        write(ScrUnit(rve),*) 
     x    '* With iporo=3, an ivers 3 input file is required'
        write(ScrUnit(rve),*) '* Your value of ivers:', ivers(rve)
        stop
      endif
c
c-----when Jager's generalized contact profile is being used (when imodel = 9,
c     designating a solid of revolution of form z = A_alpha * r ^ alpha),
c     we must read the power alpha = palpha
c     if(imodel(rve).eq.9) then
        read(TempUnit,207) palpha(rve)
c     elseif(imodel(rve).eq.10) then
c       read(TempUnit,207) dtfctr(rve)
c     endif
c
c-----read the stress-strain path, as contained in a series of lines at 
c     the end of the RunFile that describes the manner in which the 
c     deformations and stresses are to be controlled.
      read(TempUnit,210,end=12)
      i4 = 1
c
c-----read a single step of the deformation-stress control data.  Repeat
c     until the end of the file is encountered
   10 continue
        if(ivers(rve).le.4) then
          read(TempUnit,211,end=12) 
     x       icontr(i4,rve),(defrat(j,i4,rve),j=1,6)
     x      ,igoal(i4,rve),krotat(i4,rve)
     x      ,finalv(i4,rve),ipts(i4,rve),idump(i4,rve),iflexc(i4)
     x      ,imicro(i4,rve)
     x      ,ibodyf(i4),defdot(i4,rve),ipts2(i4,rve),iplot(i4,rve)
c
c---------pore fluid pressure parameters
          icontp(i4,rve) = 0
          defrat(8,i4,rve) = 0.
        elseif(ivers(rve).eq.5 .or. ivers(rve).eq.6) then
c---------a newer version of input file, which can control pore fluid pressure
          read(TempUnit,212,end=12) 
     x       icontr(i4,rve),icontp(i4,rve)
     x      ,(defrat(j,i4,rve),j=1,6),defrat(8,i4,rve)
     x      ,igoal(i4,rve),krotat(i4,rve)
     x      ,finalv(i4,rve),ipts(i4,rve),idump(i4,rve),iflexc(i4)
     x      ,imicro(i4,rve)
     x      ,ibodyf(i4),defdot(i4,rve),ipts2(i4,rve),iplot(i4,rve)
        endif
c
c-----advance the segment counter
        i4 = i4 + 1
      goto 10
c
c-----In general, the file unit=TempUnit is for temporary input or output
c     (within a single subroutin), and it is closed immediately after its use
   12 close(unit=TempUnit)
c
c-----the number of input deformation-stress control periods, istepm
      istepm(rve) = i4 - 1
c
c-----check for errors within the input values of the RunFile
      call check1(rve,extent)
c
c-----check whether the parameter lc1 is exceeded (see the 
c     "param-dempla-0.2.2.f" file).  lc1 is the maximum number 
c     of deformation-stress control steps.  This parameter is 
c     used for dimensioning various arrays.
      if(istepm(rve).gt.lc1) then
        write(ScrUnit(rve),*) ' istepm exceeds lc1 in subroutin readit'
        write(ScrUnit(rve),*) 
     x   ' Too many stress-strain control periods in the input file'
        write(ScrUnit(rve),*)  'Try changing lc1 and recompiling?'
        stop
      endif
c
      lxiold(rve) = .false.
c
      if(extent.eq.0) then
c
c-----read the second file (the StartFile) which gives the number, 
c     sizes, and initial positions and orientations of the particles 
c     in their initial configuration.
c
      if(istart(rve).eq.1) then
c-------a "D-type" StartFile file will be read: the initial configuration 
c       is read from a formatted (ASCI) file that gives only the size,
c       positions, and orientations of the particles
c
c-------open the input file
        open(unit=TempUnit,file=filename2,status='old')
c
c-------the first field in the file, 'kshape', contains an integer that 
c       specifies the type of particle that is being used in the assembly
c          kshape=1  circles
c          kshape=2  ovals
c          kshape=3  ellipses
c          kshape=4  spheres
c          kshape=5  ovoids
c          kshape=6  nobbies(2D)
c          kshape=7  bumpies(3D)
c
c-------read the particle shape
        read(TempUnit,300) kshape(rve)
c
c-------circular (2D) disks
        lcircl(rve) = kshape(rve).eq.1
c
c-------four-arc (2D) ovals
        loval(rve) =  kshape(rve).eq.2
c
c-------elliptical (2D) disks
        lelips(rve) = kshape(rve).eq.3
c
c-------spheres (3D)
        lspher(rve) = kshape(rve).eq.4
c
c-------ovoid (3D) particles
        lovoid(rve) = kshape(rve).eq.5
c
c-------nobby (2D) particles that are composed of multiple circles. Non-convex.
        lnobby(rve) = kshape(rve).eq.6
c
c-------bumpy (3D) particles that are composed of multiple spheres. Non-convex.
        lbumpy(rve) = kshape(rve).eq.7
c
c-------check that one of the standard particle types is being used
        if(.not.(     lcircl(rve) .or. loval(rve) .or. lelips(rve) 
     x           .or. lspher(rve) .or. lovoid(rve) 
     x           .or. lnobby(rve) .or. lbumpy(rve))) then
c
c---------oops! an incorrect value of kshape is being used.  Are you
c         sure that you included a line for kshape in your input file?
          write(ScrUnit(rve),*) 'An error in the input file',file2(rve)
          write(ScrUnit(rve),*) 'Invalid particle type.'
          write(ScrUnit(rve),*) 'Does the first line of',
     x      ' the D-file begin with a 1, 2, 3, 4, 5, 6, or 7',
     x      ' in the first 1 ?'
          stop
        endif
c
c-------the problem dimension, either 2D or 3D (ndim1=2 or 3).  'ndim2' is
c       used with rotations as the range ndim2:3.
        if(     lcircl(rve) .or. loval(rve) .or. lelips(rve) 
     x     .or. lnobby(rve)) then
c---------2D circle, oval, ellipse, or nobby particles
          ndim1 = 2
          ndim2 = 3
        elseif(lspher(rve) .or. lovoid(rve) .or. lbumpy(rve)) then
c---------3D sphere, ovoid, or bumpy particles
          ndim1 = 3
          ndim2 = 1
        endif
c
c-------check whether the parameter 'mdim1', which is contained in the
c       'common' file has been properly chosen
        if(      (lspher(rve) .or. lovoid(rve) .or. lbumpy(rve)) 
     x     .and. mdim1.ne.3) then
          write(ScrUnit(rve),*) 
     x      ' A 3-dimensional shape, therefore mdim1 must be 3.'
          write(ScrUnit(rve),*) 
     x      '   Recompile with mdim1=3 and mdim2=1 and try again.'
          stop
        endif
c
c-------the number of particles and the size of the periodic cell
        read(TempUnit,*) np(rve),(xcell(i,i,rve),i=1,3)
c-------the shear-offets of the assembly
        read(TempUnit,*) xcell(1,2,rve),xcell(1,3,rve),xcell(2,3,rve)
c
c-------check whether the program has been compiled for a sufficient
c       number of particles.
c         'np' is the number of particles being used in the simulation
c         'mp' is the max. number of particles for the compile (see
c           the common-0.7.290 file)
c         'mpiece' is the max. number of component piece for the compile
c           (also in the common-0.7.290 file)
c
        if((lcircl(rve) .or. lelips(rve) .or. lspher(rve)) 
     x     .and. np(rve).gt.mp) then
          write(ScrUnit(rve),*)
     x      ' np exceeds mp in the "common" file.'
          write(ScrUnit(rve),*)
     x      '   There are too many particles in the input file.'
          write(ScrUnit(rve),*)
     x      '   Recompile with a larger mp and try again.'
          stop
        elseif(loval(rve) .and. 4*np(rve).gt.mpiece) then
c---------note that an oval particle is composed of 4 component pieces
          write(ScrUnit(rve),*)
     x      ' Ovals are being used, but 4*np .gt. mpiece.'
          write(ScrUnit(rve),*)
     x      '   Recompile with a larger mpiece and try again.'
        elseif(lovoid(rve) .and. 4*np(rve).gt.mpiece) then
c---------note that an oval particle is composed of 3 component pieces,
c         but some data arrays will require four data elements per particle.
          write(ScrUnit(rve),*)
     x      ' Ovoids are being used, but 4*np .gt. mpiece.'
          write(ScrUnit(rve),*)
     x      '   Recompile with a larger mpiece and try again.'
        endif
c
c-------now we continue reading the StartFile, but its contents will depend
c       upon the particle shape
c
        if(loval(rve) .or. lovoid(rve)) then
c---------for these composite particles read the angle 'beta' (in degrees) 
c         which describes how the component pieces are joined
          read(TempUnit,*) beta(rve)
        elseif(lnobby(rve)) then
c---------read the number of satellite circles that surround the central circle
          read(TempUnit,*) nobs(rve)
c---------satrad = (radius of satellite circles) / (input radius)
c         cenrad = (radius of central circle) / (input radius)
          read(TempUnit,*) satrad(rve),cenrad(rve)
        elseif(lbumpy(rve)) then
c---------read the number of satellite spheres that surround a central sphere
          read(TempUnit,*) nbumps(rve)
c---------satrad = (radius of satellite spheres) / (input radius)
c         cenrad = (radius of central sphere) / (input radius)
c         cirrad = (radius of the circumspher on which the satellite spheres
c                   are centered) / (input radius)
          read(TempUnit,*) satrad(rve),cenrad(rve),cirrad(rve)
        endif
c
        if(lcircl(rve) .or. lspher(rve)) then
c---------circular disks or spheres
c
c---------for each particle, read the radius and position
          do 20 igrain = 1,np(rve)
c-----------note the use of the range 1:ndim1, where ndim1 is the dimension
c           of the problem (ndim1=2 for 2D problems, ndim1=3 for 3D problems)
            read(TempUnit,*) rad(igrain,rve),
     x                       (xp(j,igrain,rve),j=1,ndim1)
   20     continue
c
        elseif(loval(rve) .or. lelips(rve)) then
c---------2D ovals or elliptical particles
c
c---------for each oval (or ellipse), read 
c           the lateral radius,
c           the ratio of axial/lateral radii, 
c           the position of the center of the oval (or ellipse), and 
c           the orientation (in degrees) of the axial axis relative to 
c             vertical (measured counter-clockwise).
c
          do 30 igrain = 1,np(rve)
            read(TempUnit,*) rad(igrain,rve),aspect(igrain,rve),
     x                       (xp(j,igrain,rve),j=1,ndim1),
     x                       (theta(j,igrain,rve),j=ndim2,3)
   30     continue
        elseif(lnobby(rve)) then
          do 22 igrain = 1,np(rve)
c-----------note the use of the range 1:ndim1, where ndim1 is the dimension
c           of the problem (ndim1=2 for 2D problems, ndim1=3 for 3D problems)
            read(TempUnit,*) rad(igrain,rve),
     x                       (xp(j,igrain,rve),j=1,ndim1),
     x                       (theta(j,igrain,rve),j=ndim2,3)
   22     continue
c
        elseif(lovoid(rve)) then
c---------3D ovoid particles
c
c---------for each ovoid read the following
c           the revolved radius,
c           the ratio of axial radius / revolved radius (R_1/R_2,
c              (a value greater than zero)
c           the position of the center of the ovoid (X),
c           the orientation (in degrees) of the particle axis
c             relative to the positive x-3 direction, and
c           the orientation (in degrees) of the particle axis about
c             the x-1 axis (measured counter-clockwise)
          do 51 igrain = 1,np(rve)
            read(TempUnit,*) rad(igrain,rve),aspect(igrain,rve),
     x                       (xp(j,igrain,rve),j=1,ndim1),
     x                       (gamma_(j,igrain,rve),j=1,2)
   51     continue
c
        elseif(lbumpy(rve)) then
          do 27 igrain = 1,np(rve)
c-----------3D bumpy particles
c
c-----------for each particle, read the following:
c             - rad, the reference radius, which will be used to scale 
c               the size of the particle
c             - xp, the position of the center of the particle
c             - Qp, quaternion that the gives the orientation of the particle
            read(TempUnit,*) rad(igrain,rve),
     x                       (xp(j,igrain,rve),j=1,3),
     x                       (Qp(j,igrain,rve),j=1,4)
   27     continue
        endif
c
        np2 = np(rve)
c
c-------In general, the file unit=1 is for temporary input or output, and it
c       is closed immediately after its use
        close(unit=TempUnit)
c
      elseif(istart(rve).eq.3) then
c-------the initial configuration will be read from a binary restart file that
c       completely establishes the initial configuration, including
c       contact forces, particle velocities, ect.  This restart file allows
c       this run to continue at precisely the place where a previous run
c       had stopped
c
c-------initialize lbodyf, which designate whether body forces will be
c       applied to control the displacement contour of the assembly
        lbodyf = .false.
c
c-------read a 'restart file'
c       extent = 0
c
c-------convert to character string of proper length
        filename = filename2
        call dumpin(rve,filename,extent)
c
c-------oops!  A correction to determine "kshape" from dumpin data
c       call findk(kshape, lcircl, loval, lelips, lspher, 
c    x             lovoid, lnobby, lbumpy)
c
c-------oops!  A correction to fix some C-file inputs.
c       call fixC(vhth, dth, np, ndim1, ndim2)
      endif
c
c-----this subroutin reads a list of particles that will be constrained
c     to move in accord with the mean deformation field.  They might
c     represent rigid platens
      call platns(rve)
c
c-----read data for a temperature-dependent model.  If the StartFile
c     is a C-file, this data will be embedded in a separate file.
c     If the StartFile is a Dfile, then the data will be located in
c     a separate text-format file
      if(istart(rve).eq.1 .and. iheat(rve).eq.1) then
        call inheat(rve)
      endif
c
c-----this subroutin reads data for various contact-force models.  Whenever
c     the StartFile is a "C"-file, most of the contact parameters are
c     read from the from the StartFile, rather than be computed with this
c     subroutin.  One expection is the pdif parameter, with a Jager contact
      call models(rve)
c
c-----check the StartFile data for errors
      call check2(rve)
c
      endif
c
      return
c
  201 format(a72)
  203 format(12(i16,/),i16)
  204 format(4(i16,/),i16)
  205 format(14(f16.7,/),f16.7)
  206 format( 7(f16.7,/),f16.7)
  207 format(f16.7)
  208 format(i16)
  209 format(7(i16,/),i16)
  210 format(////)
  211 format(i6,6(1x,f9.6),1x,i2,1x,i1,1x,f9.6,1x,i4,1x,i1,1x,i2,1x,i1,
     x       1x,i2,1x,f6.5,1x,i4,1x,i2)
  212 format(i6,1x,i1,
     x       6(1x,f9.6),1x,f9.6,
     x       1x,i2,1x,i1,1x,f9.6,1x,i4,1x,i1,1x,i2,1x,i1,
     x       1x,i2,1x,f6.5,1x,i4,1x,i2)
  214 format( 9(f16.7,/),f16.7)
  300 format(i1)
c
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine WriteInput1(rve,dirname,filename)
c
c-------this subroutin reads the input files for the simulation
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        double precision rfree
        integer*2 iLayer,nplatn,rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain
c
        character*4 strRVE
        character*400 dirname
        character*400 filename
        character*800 message,pathname
c
        dimension ifree(100),rfree(100)
c
c-------this subroutin creates a RunFile that documents the input parameters
c       and stress-strain path for an RVE assembly
c
c-------the layer to which this RVE belongs
        iLayer = LayerRVE(rve)
c
c-------assign value to unused variable
        nplatn = 0
c
        do 10 i = 1,100
          ifree(i) = 0
          rfree(i) = 0.
   10   continue
c
        pathname = dirname(1:LEN_TRIM(dirname))//
     x             'I'//
     x             filename(1:LEN_TRIM(filename))
c
        open(unit=1,file=pathname)
c
        call int2str4(rve,strRVE)
c
c-------read the first line of the RunFile
        message = '103 pseudo-RunFile for the dempla run '//
     x            MainDir(1:LEN_TRIM(MainDir))//
     x            ' of RVE '//
     x            strRVE
        write(1,201) message
c
c-------read program parameters in the RunFile
        write(1,203) algori,ivers(iLayer),ncownt
     x              ,0,0,3,0,0
     x              ,iupdtm(rve)
     x              ,0
     x              ,imodel(rve),nplatn,nloop1
c
  203   format(i8,9x,
     x            ': algori   ',
     x            '| the algorithm for advancing the ',
     x            'particle positions (1 or 2)',/,
     x         i8,9x,
     x            ': ivers    ',
     x            '| add extra input lines (3, 4, 5, or 6)',/,
     x         i8,9x,
     x            ': ncownt ',  
     x            '| fequency for updating non-periodic ',
     x            'boundaries (0)',/,
     x         i8,9x,
     x            ': iout(2)  ',
     x            '| output files with avg. def. and gradients ',
     x            'in layers (0 or 1)',/,
     x         i8,9x,
     x            ': iout(3)  ',
     x            '| output files with avg. stresses within ',
     x            'layers (0 or 1)',/,
     x         i8,9x,
     x            ': istart   '
     x            '| type of file defining the initial configuration ',
     x            '(1, 2, or 3)',/,
     x         i8,9x,
     x            ': iend     ',
     x            '| type of file to be created at end of the run ',
     x            '(0, 1, 2, or 3)',/,
     x         i8,9x,
     x            ': idef     ',
     x            '| reference configuration for reporting ',
     x            'deformations (0)',/,
     x         i8,9x,
     x            ': iupdtm   ',
     x            '| max. no. of time steps between linked-list ',
     x            'updates',/,
     x         i8,9x,
     x            ': icirct   ',
     x            '| compute and regularly update the particle ',
     x            'graph (0 or 1)',/,
     x         i8,9x,
     x            ': imodel   ',
     x            '| model for long-range particle interactions',/,
     x         i8,9x,
     x            ': nplatn   ',
     x            '| number of additional D-files with boundary ',
     x            'particles',/,
     x         i8,9x,
     x            ': nloop1   | minimum number of iteration loops ',
     x            'when algori=2')
c
c-------if ivers=3 or ivers=4 (on the 3rd line of the RunFile), then the 
c       RunFile must contain an additional five lines (or more) of integer
c       input.  These are place holders for future options.  I have already 
c       found a use for ifree1, ifree2, and ifree3 (now imodel, nplatn, and
c       nloop1), so I am kluging with "ivers" to add more options
c       in the future.  When ivers=4, then the RunFile must also contain
c       an additional eight lines of floating point input (later ....)
        if(ivers(iLayer).eq.3 .or. ivers(iLayer).eq.4 
     x     .or. ivers(iLayer).eq.5 .or.ivers(iLayer).eq.6) then
c---------read this additional data from the RunFile
          write(1,204) iexact,isub,idamp(rve),iheat(rve),icoef
c
  204     format(i8,9x,
     x              ': iexact   ',
     x              '| dont use the same mass for every particle',/,
     x           i8,9x,
     x              ': isub     ',
     x              '| number of submerged particles',/,
     x           i8,9x,
     x              ': idamp    ',
     x              '| standard or Potyondy/Cundall damping',/,
     x           i8,9x,
     x              ': iheat    ',
     x              '| temperature-dependent model',/,
     x           i8,9x,
     x              ': icoef    ',
     x              '| enable changing the friction coefficient ',
     x              'during a run')
c
          if(ivers(iLayer).eq.5 .or. ivers(iLayer).eq.6) then
c-----------write this additional data from the RunFile, concerning
c           poroelastic analysis.  If iporo=1, then we computed pore
c           fluid pressure.  When the StartFile is a "D"-file, then
c           we must provide the initial pore fluid pressure, p_o.
c           When the StartFile is a "C"-file, then the pore fluid pressure
c           in inherited from a previous run and is contained in the "C"-file
            write(1,208) iporo(rve)
  208       format(i8,9x,
     x                ': iporo    ',
     x                '| include pore fluid pressure using ',
     x                'poroelasticity')
          endif
c
          if(ivers(iLayer).eq.6) then
c-----------place-holders for 8 future input variables
            write(1,209) 0,0,0,0,0,0,0,0
  209       format(i8,9x,
     x                ': ifree(11)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(12)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(13)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(14)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(15)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(16)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(17)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions',/,
     x             i8,9x,
     x                ': ifree(18)',
     x                '| a free input integer.  ',
     x                'Placeholder for future versions')
          endif
        endif
c
c-------now read Double Precision input from the RunFile
        write(1,205) kn(rve),kratio(rve),frict(rve)
     x           ,frictw(rve)
     x           ,rho(rve),sep(rve)
     x           ,pcrit(1,rve),pcrit(2,rve),pcrit(3,rve)
     x           ,xseed(rve),rmsvel(rve),pdif(rve),tmax(rve)
     x           ,A_1(rve),dt(rve)
c
  205   format(3x,1pe12.4,2x,
     x            ': kn       ',
     x            '| normal contact stiffness (force/indentation)',/,
     x         3x,1pe12.4,2x,
     x            ': kratio   ',
     x            '| ratio of tangential/normal contact stiffnesses',/,
     x         3x,1pe12.4,2x,
     x            ': frict    ',
     x            '| coefficient of friction at particle contacts',/,
     x         3x,1pe12.4,2x,
     x            ': frictw   ',
     x            '| coefficient of friction between particles '
     x            'and wall',/,
     x         3x,1pe12.4,2x,
     x            ': rho      ',
     x            '| the mass density of the particle material',/,
     x         3x,1pe12.4,2x,
     x            ': sep      ',
     x            '| threshold separation during the near-neighbor '
     x            'searches',/,
     x         3x,1pe12.4,2x,
     x            ': pcrit(1) ',
     x            '| viscosity coefficient for translational body '
     x            'damping',/,
     x         3x,1pe12.4,2x,
     x            ': pcrit(2) ',
     x            '| viscosity coefficient for rotational body '
     x            'damping',/,
     x         3x,1pe12.4,2x,
     x            ': pcrit(3) ',
     x            '| viscosity coefficient for contact damping',/,
     x         3x,1pe12.4,2x,
     x            ': xseed    ',
     x            '| seed for assigning random initial velocities '
     x            '(when motion=1)',/,
     x         3x,1pe12.4,2x,
     x            ': rmsvel   ',
     x            '| rms initial velocity (when motion=1)',/,
     x         3x,1pe12.4,2x,
     x            ': pdif     ',
     x            '| parameter for reducing Jager memory demand '
     x            '(when imodel>=6)',/,
     x         3x,1pe12.4,2x,
     x            ': tmax     ',
     x            '| maximum time for the simulation run',/,
     x         3x,1pe12.4,2x,
     x            ': A_1      ',
     x            '| shape factor for conical contact profile (A_1)',/,
     x         3x,1pe12.4,2x,
     x            ': dt       ',
     x            '| time increment')
c
c-------if ivers=4, then read an additional eight lines of floating point input.
c       See the explanation given above.
        if(ivers(iLayer).eq.4 .or. ivers(iLayer).eq.5 
     x     .or. ivers(iLayer).eq.6) then
c---------read this additional data from the RunFile
          write(1,206) gravty(1), gravty(2), gravty(3)
  206     format(3x,1pe12.4,2x,
     x              ': gravty(1)',
     x              '| gravity in x_1 direction',/,
     x           3x,1pe12.4,2x,
     x              ': gravty(1)',
     x              '| gravity in x_2 direction',/,
     x           3x,1pe12.4,2x,
     x              ': gravty(1)',
     x              '| gravity in x_3 direction')
c
          if(     iporo(rve).eq.1 
     x       .or. iporo(rve).eq.2 .or. iporo(rve).eq.3) then

c-----------poroelastic information.  Note that if the StartFile is a 
c           "C"-file, then this information (although read) is ignored, 
c           and it is replaced with information in the StartFile
c
c-----------initial fluid pressure, with poroelastic analysis
            rfree(4) = p_o(rve)
c-----------bulk modulus of the solid grains
            rfree(5) = K_s(rve)
c-----------bulk modulus of the pore fluid. For models iporo=2 and iporo=3,
c           this is the bulk modulus of the pore fluid's liquid phase
            rfree(6) = K_f(rve)
          endif
c
          if(iporo(rve).eq.2 .or. iporo(rve).eq.3) then
c-----------more poroelastic information
c
c-----------the pore fluid's saturation wiith the liquid phase
            rfree(7) = S_o(rve)
c
c-----------the atmospheric pressure for use with models iporo=2 and iporo=3
            rfree(8) = p_atm(rve)
          endif
c
          write(1,207) rfree(4), rfree(5), rfree(6), rfree(7), rfree(8)
  207     format(
     x           3x,1pe12.4,2x,
     x              ': p_o      ',
     x              '| initial fluid pressure of pore liquid',/,
     x           3x,1pe12.4,2x,
     x              ': K_s      ',
     x              '| bulk modulus of grain bodies',/,
     x           3x,1pe12.4,2x,
     x              ': K_f      ',
     x              '| bulk modulus of pore fluid',/,
     x           3x,1pe12.4,2x,
     x              ': S_o      ',
     x              '| initial fluid saturation of pore space '
     x              'at p_o (iporo=2,3)',/,
     x           3x,1pe12.4,2x,
     x              ': p_atm    ',
     x              '| the reference atmospheric pressure '
     x              '(iporo=2,3)')
        endif
c
        if(ivers(iLayer).eq.6) then
c-----------more information  Note that if the StartFile is a 
c           "C"-file, then this information is ignored, and it is obtained
c           from the StartFile
c
          if(iporo(rve).eq.3) then
c-----------poroelastic information about the pore size, gas dissolution,
c           and surface tension.   Note that if the StartFile is a 
c           "C"-file, then this information (although it is read) is ignored,
c           and it is replace by information in the StartFile
c
c-----------dimensionless Henry's coefficient for the dissolution of
c           bubble gas in the liquid phase of the pore fluid
            rfree(9) = Hcc(rve)
c
c-----------surface tension at the interface of gas bubbles and liquid
c           phase of the pore fluid
            rfree(10) = gamm(rve)
c
c-----------the diameter of gas bubbles, which are assumed to be of equal size
            rfree(11) = D_o(rve)
c
c-----------the number/density of gas bubbles per unit of original pore volume
            rfree(12) = N_o(rve)
c
c-----------the number/density of gas bubbles per unit of original pore volume
            rfree(13) = p_vap(rve)
c
c-----------the number/density of gas bubbles per unit of original pore volume
            rfree(14) = p_wcav(rve)
          endif
c
          write(1,214) rfree(9), rfree(10), rfree(11), rfree(12), 
     x                 rfree(13), rfree(14), rfree(15), rfree(16), 
     x                 rfree(17), rfree(18)
c
  214     format(
     x             3x,1pe12.4,2x,
     x                ': Hcc      ',
     x                '| Henrys coefficient of pore liquid/gas ',
     x                '(iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': gamm     ',
     x                '| surface tension of pore bubbles (iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': D_o      ',
     x                '| initial bubble diameter at p_o and S_o ',
     x                '(iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': N_o      ',
     x               '| number/density bubbles per unit initial pore ',
     x                'volume(iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': p_vap    ',
     x                '| water vapor pressure relative to atm. ',
     x                'pressure (iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': p_wcav   ',
     x                '| cavitation pressure relative to atm. ',
     x                'pressure (iporo=3)',/,
     x             3x,1pe12.4,2x,
     x                ': rfree(15)',
     x                '| placeholder',/,
     x             3x,1pe12.4,2x,
     x                ': rfree(16)',
     x                '| placeholder',/,
     x             3x,1pe12.4,2x,
     x                ': rfree(17)',
     x                '| placeholder',/,
     x             3x,1pe12.4,2x,
     x                ': rfree(18)',
     x                '| placeholder')
        endif
c
c-------when Jager's generalized contact profile is being used (when imodel = 9,
c       designating a solid of revolution of form z = A_alpha * r ^ alpha),
c       we must read the power alpha = palpha
c       if(imodel(rve).eq.9) then
          write(1,217) palpha(rve)
  217     format(3x,1pe12.4,2x,
     x              ': palpha   ',
     x              '| alpha power in contact profile (when imodel=9)')
c       elseif(imodel(rve).eq.10) then
c         write(1,218) dtfctr(rve)
c 218     format(3x,1pe12.4,2x,
c    x              ': dtfctr   ')
c       endif
c
        write(1,220)
  220   format(
     x   '                                                  ',
     x   '                                                ',
     x   ' imicro',/,
     x   '       ************  Deformation-Stress Path Segments',
     x   '  **********             krotat           iflexc |',
     x   '             iplot',/,
     x   '   icontp (100000)   (10000)   (1000)    (100)      ',
     x   '(10)      (1)                 |            ',
     x   'idump  | |ibodyf    ipts2 |',/,
     x   'icontr |  rate_11 | rate_22 | rate_33 | ',
     x   'rate_12 | rate_13 | rate_23    vrate  ',
     x   'igoal   finalv  ipts |  | | |  defdot  ',
     x   '|   |',/,
     x   '------|-|---------|---------|---------',
     x   '|---------|---------|---------|---------|--',
     x   '|-|---------|----|-|--|-|--|------|----|--|')
c
        close(unit=1)
c
  201   format(a80)
c
        return
      end
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine WriteInput2(rve,istp,dirname,filename)
c
c-------this subroutin reads the input files for the simulation
c
        include 'param-dempla-0.2.2.f'
        include 'common-dempla-0.2.2.f'
c
        double precision rfree
        integer*2 iLayer,rve
c
c-------these integers will be too large for integer*2 with large assemblies
        integer*4 igrain,istp
c
        character*400 dirname
        character*400 filename
        character*800 pathname
c
        dimension ifree(100),rfree(100)
c
c-------the layer to which this RVE belongs
        iLayer = LayerRVE(rve)
c
        pathname = dirname(1:LEN_TRIM(dirname))//
     x             'I'//
     x             filename(1:LEN_TRIM(filename))
c
        open(unit=1,file=pathname,status='old',access='append')
c
        if(ivers(iLayer).le.4) then
          write(1,211) 
     x       icontr(istp,rve),(defrat(j,istp,rve),j=1,6)
     x      ,igoal(istp,rve),krotat(istp,rve)
     x      ,finalv(istp,rve),ipts(istp,rve)
     x      ,idump(istp,rve),iflexc(istp)
     x      ,imicro(istp,rve)
     x      ,0,defdot(istp,rve),ipts2(istp,rve)
     x      ,iplot(istp,rve)
c
        elseif(ivers(iLayer).eq.5 .or. ivers(iLayer).eq.6) then
c---------a newer version of input file, which can control pore fluid pressure
          write(1,212) 
     x       icontr(istp,rve),icontp(istp,rve)
     x      ,(defrat(j,istp,rve),j=1,6),defrat(8,istp,rve)
     x      ,igoal(istp,rve),krotat(istp,rve)
     x      ,finalv(istp,rve),ipts(istp,rve),idump(istp,rve)
     x      ,iflexc(istp)
     x      ,imicro(istp,rve)
     x      ,0,defdot(istp,rve)
     x      ,ipts2(istp,rve),iplot(istp,rve)
        endif
c
        close(unit=1)
c
  211   format(i6.6,6(1x,1pe9.2),1x,i2,1x,i1,1x,1pe9.2,1x,i4,1x,
     x         i1,1x,i2,1x,i1,
     x         1x,i2,1x,f6.3,1x,i4,1x,i2)
  212   format(i6.6,1x,i1,
     x         6(1x,1pe9.2),1x,1pe9.2,
     x         1x,i2,1x,i1,1x,1pe9.2,1x,i4,1x,i1,1x,i2,1x,i1,
     x         1x,i2,1x,f6.3,1x,i4,1x,i2)
c
        return
      end
c
c
c
c*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
      subroutine drypore(p_atm, pfluid, p_o, J_f, K_s, poros0, 
     x                   dm_stress, defw, itask)
c
c-------this subroutine compute pore pressure or fluid inflow for
c       an assembly with a dry pore network.  The ideal gas law 
c       (Boyle's Law) is used
c
c       Input
c         p_atm =     atmospheric pressure
c         p_o =       fluid pressure in the initial state, relative to
c                     atmospheric pressure
c         J_f =       the Jacobian of the soil skeleton
c         K_s =       bulk stiffness of soil particles
c         poros0 =    the porosity of the soil in the initial state
c         dm_stress = the change in effective stress relative to initial state
c         itask =     1 to solve for pressure
c                     1 to solve for inflos
c
c       Output or Input
c         defw =     inflow relative to initial state
c         pfluid =  fluid pressure relative to atmospheric pressure
c
        implicit double precision(a-h,o-z)
        implicit integer*2(i-n)
c
        double precision defw, dm_stress, J_f, J_w, K_s, 
     x                   p_atm, pfluid, p_o, poros0
c
        integer*2 itask
c
        if(itask.eq.1) then
c---------the fluid inflow is known (relative to the initial state).
c         Find the fluid pressure (relative to atmospheric pressure)
c
c---------Jacobian of the air's deformation gradient
          J_w = J_f - defw
c
c---------air pressure, realtive to atmospheric pressure
          pfluid = (p_o + p_atm)
     x                  * (1.d0
     x                     - (1.d0 - poros0)
     x                       *(  dm_stress / K_s
     x                         + (p_o + p_atm) / K_s
     x                        )
     x                    )
     x                  / J_w
     x                  / (1.d0 - (p_o + p_atm)
     x                            * (1.d0 - poros0)
     x                            / (K_s * J_w))
     x             - p_atm
c
        elseif(itask.eq.2) then
c---------the fluid pressure is known (relative to atmospheric pressure)
c         Find the inflow (relative to the inital state)
c
c---------Jacobian of the fluid deformation gradient
          J_w = (p_o + p_atm) / (pfluid + p_atm)
     x          * (1.d0
     x             - (1.d0 - poros0)
     x               * (    dm_stress / K_s
     x                    - (pfluid - p_o) / K_s
     x                 )
     x            )
c
c---------net influx of air
          defw = J_f - J_w
        else
          print *,' itask must be 1 or 2 in subroutin drypore'
          stop
        endif
c
        return
      end
